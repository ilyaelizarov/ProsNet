within ProsNet.Prosumers.SecondarySides;
model SF1_fmu
  "Model of a house with solar thermal, combined heat and power, and condensing boiler heat generation technologies"
// Model automatically generated by Dymola from FMI model description
public
  parameter Boolean CBControlMode = true "If true, flow temperature is controlled; otherwise, power is controlled";
  parameter Real CBDeltaT(unit = "K", displayUnit = "K", quantity = "ThermodynamicTemperature") = 20. "Temperature difference between flow and return temperature";
  parameter Real CBTmax(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 356.14999999999998 "Maximum temperature of condensing boiler";
  parameter Real CBTmin(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 293.14999999999998 "Minimum  temperature of condensing boiler";
  parameter Real CHPmax(unit = "W", displayUnit = "W", quantity = "Power") = 2000. "Maximum electric power of CHP";
  parameter Real CHPmin(unit = "W", displayUnit = "W", quantity = "Power") = 1100. "Minimum electric power of CHP";
  parameter Boolean CPC = true "If true, solar thermal collector type is CPC; otherwise, flat plate type is used";
  parameter Real alphaModule(unit = "rad", displayUnit = "deg", quantity = "Angle") = 0.6108652381980153 "Inclination angle of solar collector";
  parameter Real betaModule(unit = "rad", displayUnit = "deg", quantity = "Angle") = 3.1415926535897931 "Orientation angle of solar collector";
  parameter Integer nSeries(quantity = "Unitless") = 1 "Number of solar collectors in series";
  parameter Integer nParallel(quantity = "Unitless") = 1 "Number of solar collectors in parallel";
  parameter Real AModule(unit = "m²", displayUnit = "m²", quantity = "Area") = 1.3120000000000001 "Effective surface area of solar collector";
  parameter Real VAbsorber(unit = "m³", displayUnit = "m³", quantity = "Volume") = 1.7 "Absorber volume";
  parameter Real Tmax_TS(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 363.14999999999998 "Maximum temperature in thermal storage";
  parameter Real T0_TS(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 303.14999999999998 "Temperature for calculating stored energy e.g. return temperature of consumption";
  parameter Boolean TSLinearProfile = true "If true, the temperature profile for storage is linear; otherwise, the profile is defined by a temperature vector";
  parameter Real TSTupInit(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 313.14999999999998 "Initial temperature of upmost thermal storage layer";
  parameter Real TSTlowInit(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 313.14999999999998 "Initial temperature of lowmost thermal storage layer";
  parameter Real Tmax_DHW(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 363.14999999999998 "Maximum temperature in DHW thermal storage";
  parameter Real T0_DHW(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 288.14999999999998 "Temperature for calculating stored energy in DHW storage e.g. return temperature of consumption";
  parameter Boolean DHWLinearProfile = true "If true, the temperature profile for DHW storage is linear; otherwise, the profile is defined by a temperature vector";
  parameter Real DHWTupInit(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 313.14999999999998 "Initial temperature of upmost DHW storage layer";
  parameter Real DHWTlowInit(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 313.14999999999998 "Initial temperature of lowmost DHW storage layer";
  parameter Integer nPeople(quantity = "Unitless") = 5 "Number of people living in the building";
  parameter Integer nFloors(quantity = "Unitless") = 2 "Number of floors";
  parameter Integer nApartments(quantity = "Unitless") = 2 "Number of apartments";
  parameter Real ALH(unit = "m²", displayUnit = "m²", quantity = "Area") = 250. "Heated area (living area) e.g. 50 sq.m. per person";
  parameter Boolean UseStandardHeatNorm = true "If true, standard area-specific heating power is used; otherwise, manual definition is required";
  parameter Real QHeatNormLivingArea(unit = "W", displayUnit = "W", quantity = "HeatFlux") = 15. "Area-specific heating power e.g. modern radiators 14-15 W/sq.m., space heating 15 W/sq.m. (active if UseStandardHeatNorm is false)";
  parameter Real n(unit = "-", displayUnit = "-", quantity = "Unitless") = 1.1000000000000001 "Heating system exponent e.g. 1.3 for radiators, 1.1 for floor heatingHeating system exponent e.g. 1.3 for radiators, 1.1 for floor heating";
  parameter Real TFlowHeatNorm(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 313.14999999999998 "Normal flow temperature e.g. for radiators 55-75 deg. C, for floor heating 35-45 deg. C";
  parameter Real TReturnHeatNorm(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 303.14999999999998 "Normal return temperature e.g. for radiators 45-65 deg. C, for floor heating 28-35 deg. C";
  parameter Real TRef(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 294.14999999999998 "Reference indoor temperature";
  parameter Real qvMaxLivingZone(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlowRate") = 0.00025000000000000001 "Maximum flow rate in living area";
  parameter Real TLiving_Init(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 291.14999999999998 "Initial air temperature in the living area";
  parameter Real TRoof_Init(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 274.64999999999998 "Initial roof temperature";
  parameter Real TCellar_Init(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 280.14999999999998 "Initial air temperature in the cellar";
  parameter Boolean UseIndividualPresence = false "If true, presence data has to be provided; otherwise, standard presence is used";
  parameter String PresenceFile = "C:\\\\Users\\\\Public\\\\Documents\\\\SimulationX 4.2\\\\Modelica\\\\CoSES_Models\\\\Data\\\\Consumer\\\\Presence\\\\presence_ResidentialBuilding.txt" "File with presence timeseries: 0% - no one is at home, 100% - everyone is at home (active if UseIndividualPresence is true)";
  parameter Boolean UseIndividualElecConsumption = false "If true, individual electricity consumption data has to be provided; otherwise standard consumption is used";
  parameter String ElConsumptionFile = "C:\\\\Users\\\\Public\\\\Documents\\\\SimulationX 4.2\\\\Modelica\\\\CoSES_Models\\\\Data\\\\Consumer\\\\Electric Consumption\\\\elPower_1000kWh_per_year_VDI4655.txt" "File with electric consumption time series in kW (active if UseIndividualElecConsumption is true)";
  parameter Real YearlyElecConsumption_kWh(unit = "-", displayUnit = "-", quantity = "Unitless") = 1000. "Yearly electricity consumption in kWh (active if UseIndividualConsumption is true)";
  parameter Real ElFactor(unit = "-", displayUnit = "-", quantity = "Unitless") = 1. "Normalized electric consumption (active if UseIndividualConsumption is true)";
  parameter Boolean ActivateNightTimeReduction = false "If true, night time temperature reduction is activated";
  parameter Real NightTimeReductionStart(unit = "s", displayUnit = "s", quantity = "Time") = 82800. "Night time reduction starts at (active if ActivateNightTimeReduction is true)";
  parameter Real NightTimeReductionEnd(unit = "s", displayUnit = "s", quantity = "Time") = 25200. "Night time reduction stops at (active if ActivateNightTimeReduction is true)";
  parameter Real Tnight(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 291.14999999999998 "Room temperature at night time reduction (active if ActivateNightTimeReduction is true)";
  parameter Boolean VariableTemperatureProfile = false "If true, room temperature is reduced according to presence data";
  parameter Real TMin(unit = "K", displayUnit = "degC", nominal = 300, quantity = "ThermodynamicTemperature", min = 0) = 292.14999999999998 "Minimum temperature when nobody is at home: TRefSet = TMin + (TRef - TMin) * Presence [t] (active if VariableTemperatureProfile is true)";
  parameter Boolean DataType = true "If true, DHW consumption is expressed as volumetric flow; otherwise as power";
  parameter String File = "C:\\\\Users\\\\Public\\\\Documents\\\\SimulationX 4.2\\\\Modelica\\\\CoSES_Models\\\\Data\\\\Consumer\\\\DHW Load Profiles\\\\DHW_wholeyear_200l.txt" "DHW data file";
  parameter String Table = "V_DHW" "DHW data file File";
  parameter Real V_DHWperDay_l(unit = "-", displayUnit = "-", quantity = "Unitless") = 400. "DHW consumption per day in litres";
  parameter Real DHWfactor(unit = "-", displayUnit = "-", quantity = "Unitless") = 2. "Factor by which DHW consumption gets multiplied";
  Real SHB_QHeat(unit = "W", displayUnit = "W", quantity = "Power") "Heat power";
  Real SHB_Pel(unit = "W", displayUnit = "W", quantity = "Power") "Common electrical effective power of the zones";
  Real SHB_qv_Ref(unit = "m³/s", displayUnit = "l/min", quantity = "Flow") "Demanded volume flow of heating medium";
  Real SHB_T_Ref(unit = "K", displayUnit = "degC", quantity = "Temp") "Reference temperature of heating medium";
  Real SHB_TZone_1(unit = "K", displayUnit = "degC", quantity = "Temp") "Zone temperature of cellar";
  Real SHB_TZone_2(unit = "K", displayUnit = "degC", quantity = "Temp") "Zone temperature of living area";
  Real SHB_TZone_3(unit = "K", displayUnit = "degC", quantity = "Temp") "Zone temperature of roof";
  Real HUFT_TFlowSink(unit = "K", displayUnit = "degC", quantity = "Temp") "Flow temperature of heat sink";
  Real HUFT_TReturnSink(unit = "K", displayUnit = "degC", quantity = "Temp") "Return temperature of heat sink";
  Real DHWD_Q_DHW(unit = "W", displayUnit = "W", quantity = "Power") "Heat power domestic hot water";
  Real DHWD_E_DHW(unit = "J", displayUnit = "J", quantity = "Energy") "Heat output for hot domestic hot water";
  Real DHWD_qv_DHW(unit = "m³/s", displayUnit = "l/min", quantity = "Flow") "DHW Flow";
  Real DHWD_TColdWater(unit = "K", displayUnit = "degC", quantity = "Temp") "Cold water temperature";
  Real DHWD_THotWaterIs(unit = "K", displayUnit = "degC", quantity = "Temp") "Hot water temperature at inlet (minus losses within the valves)";
  Real DHWD_TPipe(unit = "K", displayUnit = "degC", quantity = "Temp") "Temperature of the pipe, connected to the storage";
  Real WSPU_SOC(unit = "-", displayUnit = "-", quantity = "Unitless") "State of charge";
  Real WSPU_EStorage(unit = "J", displayUnit = "J", quantity = "Energy") "Stored heat energy";
  Real WSPU_TStorage_1(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 1";
  Real WSPU_TStorage_2(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 2";
  Real WSPU_TStorage_3(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 3";
  Real WSPU_TStorage_4(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 4";
  Real WSPU_TStorage_5(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 5";
  Real WSPU_TStorage_6(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 6";
  Real WSPU_TStorage_7(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 7";
  Real WSPU_TStorage_8(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 8";
  Real WSPU_TStorage_9(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 9";
  Real WSPU_TStorage_10(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 10";
  Real WSPU_PStorage_1(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 1";
  Real WSPU_PStorage_2(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 2";
  Real WSPU_PStorage_3(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 3";
  Real WSPU_PStorage_4(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 4";
  Real WSPU_PStorage_5(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 5";
  Real WSPU_PStorage_6(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 6";
  Real WSEM_SOC(unit = "-", displayUnit = "-", quantity = "Unitless") "State of charge";
  Real WSEM_EStorage(unit = "J", displayUnit = "J", quantity = "Energy") "Stored heat energy";
  Real WSEM_TStorage_1(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 1";
  Real WSEM_TStorage_2(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 2";
  Real WSEM_TStorage_3(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 3";
  Real WSEM_TStorage_4(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 4";
  Real WSEM_TStorage_5(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 5";
  Real WSEM_TStorage_6(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 6";
  Real WSEM_TStorage_7(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer7";
  Real WSEM_TStorage_8(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 8";
  Real WSEM_TStorage_9(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 9";
  Real WSEM_TStorage_10(unit = "K", displayUnit = "degC", quantity = "Temp") "Output of heat storage temperature of layer 10";
  Real WSEM_PStorage_1(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 1";
  Real WSEM_PStorage_2(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 2";
  Real WSEM_PStorage_3(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 3";
  Real WSEM_PStorage_4(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 4";
  Real WSEM_PStorage_5(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 5";
  Real WSEM_PStorage_6(unit = "W", displayUnit = "W", quantity = "Power") "Supplied/abstracted heat power of pipe 6";
  Real WCGB_QHeat(unit = "W", displayUnit = "W", quantity = "Power") "Heat output power of CB";
  Real WCGB_PFuel(unit = "W", displayUnit = "W", quantity = "Power") "Gas power";
  Real WCGB_qvWolf(unit = "m³/s", displayUnit = "l/min", quantity = "Flow") "Volume flow";
  Real WCGB_TFlow(unit = "K", displayUnit = "degC", quantity = "Temp") "Flow temperature";
  Real WCGB_TReturn(unit = "K", displayUnit = "degC", quantity = "Temp") "Return temperature";
  Real NT_QHeat(unit = "W", displayUnit = "W", quantity = "Power") "Heat output power of CHP";
  Real NT_PGEN(unit = "W", displayUnit = "W", quantity = "Power") "Effective power of asynchronous generator";
  Real NT_PFuel(unit = "W", displayUnit = "W", quantity = "Power") "Used fuel power";
  Real NT_qv(unit = "m³/s", displayUnit = "l/min", quantity = "Flow") "Volume flow of circulation pump";
  Real NT_TFlow(unit = "K", displayUnit = "degC", quantity = "Temp") "Flow temperature of CHP";
  Real NT_TReturn(unit = "K", displayUnit = "degC", quantity = "Temp") "Return temperature of CHP";
  Real WCRK_QSolarThermal(unit = "W", displayUnit = "W", quantity = "Power") "Actual heat power supply";
  Real WCRK_etaTotal(unit = "-", displayUnit = "-", quantity = "Unitless") "Overall efficiency of solar thermal collector";
  Real WCRK_TCollector(unit = "K", displayUnit = "degC", quantity = "Temp") "Temperature of solar thermal collector";
  parameter Real _qvDHpump_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput qvDHpump(unit = "-", displayUnit = "-", quantity = "Unitless", start = _qvDHpump_start) "Reference volume flow of district heating pump - positive: feed in - negative: extraction"
  annotation (Placement(transformation(extent={{-114,65},{-94,85}})));
  parameter Real _qvDHWpump_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput qvDHWpump(unit = "-", displayUnit = "-", quantity = "Unitless", start = _qvDHWpump_start) "Reference volume flow of domestic hot water pump to charge the DHW storage"
  annotation (Placement(transformation(extent={{-114,40},{-94,60}})));
  parameter Real _qvSTpump_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput qvSTpump(unit = "-", displayUnit = "-", quantity = "Unitless", start = _qvSTpump_start) "Reference volume flow of solar thermal pump"
  annotation (Placement(transformation(extent={{-114,15},{-94,35}})));
  parameter Real _CBIn_P_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput CBIn_P(unit = "-", displayUnit = "-", quantity = "Unitless", start = _CBIn_P_start) "'input Real' as connector"
  annotation (Placement(transformation(extent={{-114,-10},{-94,10}})));
  parameter Real _CBIn_TSet_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput CBIn_TSet(unit = "K", displayUnit = "degC", quantity = "Temp", start = _CBIn_TSet_start) "Condensing boiler input - set temperature (power is constant)"
  annotation (Placement(transformation(extent={{-114,-35},{-94,-15}})));
  parameter Real _CHPIn_P_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput CHPIn_P(unit = "W", displayUnit = "W", quantity = "Power", start = _CHPIn_P_start) "CHP input - electric power"
  annotation (Placement(transformation(extent={{-114,-60},{-94,-40}})));
  parameter Real _TDH_HEXout_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput TDH_HEXout(unit = "K", displayUnit = "degC", quantity = "Temp", start = _TDH_HEXout_start) "Outlet temperature of district heating heat exchanger"
  annotation (Placement(transformation(extent={{-114,-85},{-94,-65}})));
  Modelica.Blocks.Interfaces.RealOutput qv_HEX(unit = "-", displayUnit = "-", quantity = "Unitless") "Volume flow to district heating heat exchanger"
  annotation (Placement(transformation(extent={{100,14},{140,54}})));
  Modelica.Blocks.Interfaces.RealOutput TDH_HEXin(unit = "K", displayUnit = "degC", quantity = "Temp") "Inlet temperature of district heating heat exchanger"
  annotation (Placement(transformation(extent={{100,-53},{140,-13}})));
public
  parameter String fmi_instanceName="SF1_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  constant Integer fmi_NumberOfContinuousStates = 596;
  constant Integer fmi_NumberOfEventIndicators = 94;
protected
  Real fmi_x[fmi_NumberOfContinuousStates](each fixed=false) "States";
  Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
  Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
  fmi_Functions.fmiModel fmi;
  parameter Real fmi_Initialized(fixed=false);
  Real myTime;
  Boolean fmi_StepEvent;
  Boolean fmi_NewStates;
  Boolean fmi_NewStates2(start=false,fixed=true);
  Real fmi_TNext(start=fmi_TNext_Start,fixed=true);
  parameter Real fmi_TNext_Start(fixed=false);
package fmi_Functions
  class fmiModel
  extends ExternalObject;
    function constructor "Initialize FMI model"
      extends Modelica.Icons.Function;
      input String instanceName;
      input Boolean loggingOn;
      output fmiModel fmi;
      external"C" fmi = SF1_all_inputs47999644336092_fmiInstantiateModel2(instanceName, loggingOn)
      annotation(Header="
#ifndef SF1_all_inputs47999644336092_Instantiate_C
#define SF1_all_inputs47999644336092_Instantiate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
#ifndef SF1_all_inputs47999644336092_MYSTRCMP_C
#define SF1_all_inputs47999644336092_MYSTRCMP_C 1
int SF1_all_inputs47999644336092mystrcmp(const void *_a, const void *_b) {
  char *a = _a;
  char *const *b = _b;
  return strcmp(a, *b);
}
#endif
void SF1_all_inputs47999644336092Logger(fmiComponent c, fmiString instanceName, fmiStatus status,
	 fmiString category, fmiString message, ...) {
  char msg[4096];
  char buf[4096];
  int len;
  va_list ap;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len <4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmiFatal:
      ModelicaMessage(\"[fmiFatal]: \");
      break;
    case fmiError:
      ModelicaMessage(\"[fmiError]: \");
      break;
    case fmiDiscard:
      ModelicaMessage(\"[fmiDiscard]: \");
      break;
    case fmiWarning:
      ModelicaMessage(\"[fmiWarning]: \");
      break;
    case fmiOK:
      ModelicaMessage(\"[fmiOK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * SF1_all_inputs47999644336092_fmiInstantiateModel2(const char*instanceName, fmiBoolean loggingOn) {
  static fmiMECallbackFunctions funcs = {&SF1_all_inputs47999644336092Logger, &calloc, &free};
  struct dy_Extended* res;

  res = calloc(1, sizeof(struct dy_Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"SF1_all_inputs.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (SF1_all_inputs.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiateModel=(fmiInstantiateModelFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiInstantiateModel\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInstantiateModel!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInstantiateModel\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiFreeModelInstance=(fmiFreeModelInstanceFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiFreeModelInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmiFreeModelInstance!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiFreeModelInstance\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmiSetTimeFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmiSetContinuousStatesFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmiGetContinuousStatesFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmiCompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiCompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmiCompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEventUpdate=(fmiEventUpdateFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiEventUpdate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiEventUpdate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEventUpdate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiInitialize=(fmiInitializeFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiInitialize\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInitialize!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInitialize\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmiGetDerivativesFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmiGetEventIndicatorsFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmiTerminateFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiTerminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiTerminate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiTerminate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmiSetRealFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmiGetRealFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmiSetIntegerFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmiGetIntegerFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmiSetBooleanFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmiGetBooleanFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmiSetStringFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmiGetStringFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiGetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetString!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmiSetDebugLoggingFunc)GetProcAddress(res->hInst,\"SF1_all_inputs_fmiSetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetDebugLogging!\");
      return 0;
    }
    res->m=res->dyFmiInstantiateModel(instanceName, \"{CD47A99C-964A-43EE-BD3A-FFA6BC09DB2A}\", funcs, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->dyFirstTimeEvent=1e37;res->currentMode=dyInstantiationMode;}
  }
  return res;
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                       __Dymola_CriticalRegion="SF1_all_inputs");
    end constructor;

    function destructor "Release storage of FMI model"
      extends Modelica.Icons.Function;
      input fmiModel fmi;
      external"C"
                 SF1_all_inputs47999644336092_fmiFreeModelInstance2(fmi);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_Free_C
#define SF1_all_inputs47999644336092_Free_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiFreeModelInstance2(void*m) {
  struct dy_Extended*a=m;
  if (a) {
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeModelInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                       __Dymola_CriticalRegion="SF1_all_inputs");
    end destructor;
  end fmiModel;

    function fmiSetTime
      input fmiModel fmi;
      input Real ti;
      external"C" SF1_all_inputs47999644336092_fmiSetTime2(fmi, ti);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetTime_C
#define SF1_all_inputs47999644336092_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetTime2(void*m, double ti) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyInstantiationMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti>a->dyTime || (a->currentMode==dyEventMode && ti==a->dyTime && !isModelicaEvent())){
      a->currentMode=dyContinuousTimeMode;
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti <= a->dyTime && a->currentMode == dyContinuousTimeMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK ) ModelicaError(\"SetTime failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiSetTime;

    function fmiSetContinuousStates
      input fmiModel fmi;
      input Real x[:];
      external"C" SF1_all_inputs47999644336092_fmiSetContinuousStates2(
        fmi,
        x,
        size(x, 1));
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetContinuousStates_C
#define SF1_all_inputs47999644336092_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetContinuousStates failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiSetContinuousStates;

    function fmiGetContinuousStates
      input fmiModel fmi;
      input Integer nx;
      output Real x[nx];
      external"C" SF1_all_inputs47999644336092_fmiGetContinuousStates2(
        fmi,
        x,
        nx);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetContinuousStates_C
#define SF1_all_inputs47999644336092_GetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetContinuousStates failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetContinuousStates;

    function fmiCompletedStep
      input fmiModel fmi;
      output Real crossing;
      external"C" crossing = SF1_all_inputs47999644336092_fmiCompletedStep2(fmi);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_CompletedStep_C
#define SF1_all_inputs47999644336092_CompletedStep_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double SF1_all_inputs47999644336092_fmiCompletedStep2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      fmiBoolean b=0;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->dyLastTime=a->dyTime;
      if (b) a->dyTriggered=1;
    } else status=fmiOK;
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiCompletedStep;

    function CompletedStep
      input fmiModel fmi;
      output Real crossing;
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      crossing := fmiCompletedStep(fmi);
      annotation(LateInline=true);
    end CompletedStep;

    function fmiEventUpdate
      input fmiModel fmi;
      output Real tnext;
      output Boolean stateReset;
      external"C" stateReset = SF1_all_inputs47999644336092_fmiEventUpdate2(fmi, tnext);
      annotation(Header="
#ifndef SF1_all_inputs47999644336092_EventUpdate_C
#define SF1_all_inputs47999644336092_EventUpdate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
int SF1_all_inputs47999644336092_fmiEventUpdate2(void*m, double*tnext){
  struct dy_Extended*a=m;
  fmiEventInfo ev;
  fmiStatus status=fmiFatal;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      fmiBoolean b;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->currentMode=dyEventMode;
    }
    status=a->dyFmiEventUpdate(a->m, 0, &ev);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
  }
  if (ev.terminateSimulation) terminate(\"Terminate signaled by FMU\");
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"EventUpdate failed\");
  *tnext=ev.nextEventTime;
  return ev.stateValuesChanged;
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiEventUpdate;

    function EventUpdate
      input fmiModel fmi;
      output Real tnext;
      output Boolean stateReset;
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      (tnext, stateReset) := fmiEventUpdate(fmi);
      annotation(LateInline=true);
    end EventUpdate;

    function fmiInitialize
      input fmiModel fmi;
      output Real tnext;
      output Real initialized=1;
      external"C" tnext = SF1_all_inputs47999644336092_fmiInitialize2(fmi);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_Initialize_C
#define SF1_all_inputs47999644336092_Initialize_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double SF1_all_inputs47999644336092_fmiInitialize2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  fmiBoolean toleranceControlled=fmiFalse;
  fmiReal tolerance=0;
  fmiEventInfo ev;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiInitialize(a->m, toleranceControlled, tolerance, &ev);
      a->currentMode=dyEventMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->dyFirstTimeEvent=ev.nextEventTime;
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"Initialize failed\");
  return a->dyFirstTimeEvent;
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiInitialize;

    function fmiGetDerivatives
    input fmiModel fmi;
    input Integer nx;
    output Real dx[nx];
    external"C" SF1_all_inputs47999644336092_fmiGetDerivatives2(
      fmi,
      dx,
      nx);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetDerivatives_C
#define SF1_all_inputs47999644336092_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetDerivatives failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetDerivatives;

    function GetDerivatives
      input fmiModel fmi;
      input Integer nx;
      output Real dx[nx];
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      dx := fmiGetDerivatives(fmi, nx);
      annotation(LateInline=true);
    end GetDerivatives;

    function fmiGetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      external"C" SF1_all_inputs47999644336092_fmiGetEventIndicators2(
        fmi,
        z,
        nz);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetEventIndicators_C
#define SF1_all_inputs47999644336092_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetEventIndicators(a->m, z, nz);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetEventIndicators failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetEventIndicators;

    function GetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      z := fmiGetEventIndicators(fmi, nz);
      annotation(LateInline=true);
    end GetEventIndicators;

    function GetOutput
      input fmiModel fmi;
      input Real Time;
      input Integer outputValueReference[1];
      output Real outputVariable;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1],1);
      annotation(LateInline=true);
    end GetOutput;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      output Real dummy= 1;
      external"C"
                 SF1_all_inputs47999644336092_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetReal_C
#define SF1_all_inputs47999644336092_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealParam
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
    protected
      Real oldVals[size(refs, 1)];
      external"C"
                 SF1_all_inputs47999644336092_fmiSetRealParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetRealParam_C
#define SF1_all_inputs47999644336092_SetRealParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetRealParam2(void*m, const int*refs, size_t nrefs, const double*vals, double*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetReal(a->m, refs, nrefs, oldVals);
      for(i=0; i<nrefs;++i){
        if( abs(vals[i]-oldVals[i])> 5e-16){
          ModelicaError(\"SetRealParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealParam;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      input Real dummy;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}, dummy));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      input Real preAvailable;
      external"C" SF1_all_inputs47999644336092_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetReal_C
#define SF1_all_inputs47999644336092_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetReal failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetReal;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}, dummy));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" SF1_all_inputs47999644336092_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetInteger_C
#define SF1_all_inputs47999644336092_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetInteger;

    function fmiSetInteger
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      output Real dummy= 1;
      external"C" SF1_all_inputs47999644336092_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetInteger_C
#define SF1_all_inputs47999644336092_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerParam
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" SF1_all_inputs47999644336092_fmiSetIntegerParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetIntegerParam_C
#define SF1_all_inputs47999644336092_SetIntegerParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetIntegerParam2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i=0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      for(i = 0; i< nrefs; ++i){
        if(vals[i]!=oldVals[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerParam;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}, dummy));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" SF1_all_inputs47999644336092_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetBoolean_C
#define SF1_all_inputs47999644336092_GetBoolean_C 1
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(vals));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetBoolean failed\");
  for(i=nr-1;i>=0;i--) vals[i]=((fmiBoolean*)(vals))[i];
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetBoolean;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      output Real dummy2= 1;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" SF1_all_inputs47999644336092_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetBoolean_C
#define SF1_all_inputs47999644336092_SetBoolean_C 1
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals,int*dummy) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetBooleanParam
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" SF1_all_inputs47999644336092_fmiSetBooleanParam2(
      fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetBooleanParam_C
#define SF1_all_inputs47999644336092_SetBooleanParam_C 1
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiSetBooleanParam2(void*m, const int* refs, size_t nr, const int* vals,int*dummy,int*oldVals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
    }else{
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(oldVals));
      for(i=nr-1;i>=0;i--){
        oldVals[i]=((fmiBoolean*)(oldVals))[i];
        if(oldVals[i]!=dummy[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanParam;

    function fmiGetString
      input fmiModel fmi;
      input Integer refs[:];
      output String vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" SF1_all_inputs47999644336092_fmiGetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef SF1_all_inputs47999644336092_GetString_C
#define SF1_all_inputs47999644336092_GetString_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void SF1_all_inputs47999644336092_fmiGetString2(void*m, const int*refs, size_t nrefs, fmiString* vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"StringInteger failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs");
    end fmiGetString;

    function fmiSetString
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" SF1_all_inputs47999644336092_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetString_C
#define SF1_all_inputs47999644336092_SetString_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void SF1_all_inputs47999644336092_fmiSetString2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetStringParam
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" SF1_all_inputs47999644336092_fmiSetStringParam2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef SF1_all_inputs47999644336092_SetStringParam_C
#define SF1_all_inputs47999644336092_SetStringParam_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void SF1_all_inputs47999644336092_fmiSetStringParam2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="SF1_all_inputs", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/SF1/binaries",                                         __Dymola_CriticalRegion="SF1_all_inputs",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetStringParam;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;
end fmi_Functions;
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn);
  end when;
  fmi_StepEvent = fmi_Functions.CompletedStep(fmi, myTime, {CBIn_P, CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, fill(0,0), fill(0,0))>0.5;
  der(fmi_x) = fmi_Functions.GetDerivatives(fmi, size(fmi_x, 1), myTime, {CBIn_P, CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, fill(0,0), fill(0,0));
  fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {CBIn_P, CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, fill(0,0), fill(0,0));
  for i in 1:size(fmi_z,1) loop
    fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
  end for;
  when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_StepEvent, not initial()}) then
    (fmi_TNext, fmi_NewStates) =  fmi_Functions.EventUpdate(fmi, myTime, {CBIn_P, CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, fill(0,0), fill(0,0));
    fmi_NewStates2 = if fmi_NewStates then not pre(fmi_NewStates2) else pre(fmi_NewStates2);
  end when;
  for i in 1:size(fmi_x,1) loop
    when {fmi_NewStates2, not fmi_NewStates2} then
      reinit(fmi_x[i], fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x,1))*{if i==j then 1 else 0 for j in 1:size(fmi_x,1)});
    end when;
  end for;
algorithm
  fmi_Functions.fmiSetTime(fmi, time);
  myTime := time;
  fmi_Functions.fmiSetContinuousStates(fmi, fmi_x);
initial algorithm
 // 35 Real parameters
  fmi_Functions.fmiSetRealParam(fmi, {1073741824, 1073741825, 1073741826, 1073741827, 1073741828, 1073741829, 1073741830, 1073741831, 1073741832, 1073741833, 1073741834, 1073741835, 1073741836, 1073741837, 1073741838, 1073741839, 1073741840, 1073741841, 1073741842, 1073741843, 1073741844, 1073741845, 1073741846, 1073741847, 1073741848, 1073741849, 1073741850, 1073741851, 1073741852, 1073741853, 1073741854, 1073741855, 1073741856, 1073741857, 1073741858}, {CBDeltaT, CBTmax, CBTmin, CHPmax, CHPmin, alphaModule, betaModule, AModule, VAbsorber, Tmax_TS, T0_TS, TSTupInit, TSTlowInit, Tmax_DHW, T0_DHW, DHWTupInit, DHWTlowInit, ALH, QHeatNormLivingArea, n, TFlowHeatNorm, TReturnHeatNorm, TRef, qvMaxLivingZone, TLiving_Init, TRoof_Init, TCellar_Init, YearlyElecConsumption_kWh, ElFactor, NightTimeReductionStart, NightTimeReductionEnd, Tnight, TMin, V_DHWperDay_l, DHWfactor});
 // 0 Real start values
 // 5 Integer parameters
  fmi_Functions.fmiSetIntegerParam(fmi, {1073741826, 1073741827, 1073741830, 1073741831, 1073741832}, {nSeries, nParallel, nPeople, nFloors, nApartments});
 // 0 Integer start values
 // 10 Boolean parameters
  fmi_Functions.fmiSetBooleanParam(fmi, {1073741824, 1073741825, 1073741828, 1073741829, 1073741833, 1073741834, 1073741835, 1073741836, 1073741837, 1073741838}, {CBControlMode, CPC, TSLinearProfile, DHWLinearProfile, UseStandardHeatNorm, UseIndividualPresence, UseIndividualElecConsumption, ActivateNightTimeReduction, VariableTemperatureProfile, DataType});
 // 0 Boolean start values
 // 0 Enumeration parameters
 // 0 Enumeration start values
 // 4 String parameters
  fmi_Functions.fmiSetStringParam(fmi, {1073741824, 1073741825, 1073741826, 1073741827}, {PresenceFile, ElConsumptionFile, File, Table});
 // Set InitalInputs
fmi_Functions.fmiSetReal(fmi, {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, {_CBIn_P_start, _CBIn_TSet_start, _CHPIn_P_start, _TDH_HEXout_start, _qvDHWpump_start, _qvDHpump_start, _qvSTpump_start});
  fmi_Functions.fmiSetTime(fmi, time);
  (fmi_TNext_Start,fmi_Initialized) :=fmi_Functions.fmiInitialize(fmi);
  fmi_x :=fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x, 1));
equation
    qv_HEX =  fmi_Functions.GetOutput(fmi,myTime,{805306368}, {CBIn_P, CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, fill(0,0), fill(0,0));
    TDH_HEXin =  fmi_Functions.GetOutput(fmi,myTime,{805306369}, {CBIn_P, CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870915, 536870916, 536870917, 536870918, 536870913, 536870912, 536870914}, fill(0,0), fill(0,0));
{SHB_QHeat, SHB_Pel, SHB_qv_Ref, SHB_T_Ref, SHB_TZone_1, SHB_TZone_2, SHB_TZone_3, HUFT_TFlowSink, HUFT_TReturnSink, DHWD_Q_DHW, DHWD_E_DHW, DHWD_qv_DHW, DHWD_TColdWater, DHWD_THotWaterIs, DHWD_TPipe, WSPU_SOC, WSPU_EStorage, WSPU_TStorage_1, WSPU_TStorage_2, WSPU_TStorage_3, WSPU_TStorage_4, WSPU_TStorage_5, WSPU_TStorage_6, WSPU_TStorage_7, WSPU_TStorage_8, WSPU_TStorage_9, WSPU_TStorage_10, WSPU_PStorage_1, WSPU_PStorage_2, WSPU_PStorage_3, WSPU_PStorage_4, WSPU_PStorage_5, WSPU_PStorage_6, WSEM_SOC, WSEM_EStorage, WSEM_TStorage_1, WSEM_TStorage_2, WSEM_TStorage_3, WSEM_TStorage_4, WSEM_TStorage_5, WSEM_TStorage_6, WSEM_TStorage_7, WSEM_TStorage_8, WSEM_TStorage_9, WSEM_TStorage_10, WSEM_PStorage_1, WSEM_PStorage_2, WSEM_PStorage_3, WSEM_PStorage_4, WSEM_PStorage_5, WSEM_PStorage_6, WCGB_QHeat, WCGB_PFuel, WCGB_qvWolf, WCGB_TFlow, WCGB_TReturn, NT_QHeat, NT_PGEN, NT_PFuel, NT_qv, NT_TFlow, NT_TReturn, WCRK_QSolarThermal, WCRK_etaTotal, WCRK_TCollector} = fmi_Functions.fmiGetReal(fmi, {805306370, 805306371, 805306372, 805306373, 805306374, 805306375, 805306376, 805306377, 805306378, 805306379, 805306380, 805306381, 805306382, 805306383, 805306384, 805306385, 805306386, 805306387, 805306388, 805306389, 805306390, 805306391, 805306392, 805306393, 805306394, 805306395, 805306396, 805306397, 805306398, 805306399, 805306400, 805306401, 805306402, 805306403, 805306404, 805306405, 805306406, 805306407, 805306408, 805306409, 805306410, 805306411, 805306412, 805306413, 805306414, 805306415, 805306416, 805306417, 805306418, 805306419, 805306420, 805306421, 805306422, 805306423, 805306424, 805306425, 805306426, 805306427, 805306428, 805306429, 805306430, 805306431, 805306432, 805306433, 805306434}, myTime);
  annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=0, StopTime=1, Tolerance=1e-06),
    Icon(graphics={
      Rectangle(
        extent={{-100,100},{100,-100}},
        lineColor={95,95,95},
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        lineThickness=0.5),
      Bitmap(extent={{-95,-95},{95,95}},
      fileName="modelica://SF1_fmu/Resources/Library/FMU/SF1/model.png"),
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 1.0 ME")}),
Documentation(info="<html>
<p>The FMU of the SF1 model from the Center for Combined Smart Energy Systems (CoSES) Center library: <a href=\"https://gitlab.lrz.de/coses_operation/coses_models/simulationx_models.git\">https://gitlab.lrz.de/coses_operation/coses_models/simulationx_models.git</a></p>
<p><b>ModelDescription Attributes</b></p>
<ul>
<li>fmiVersion = 1.0</li>
<li>modelName = SF1_all_inputs</li>
<li>generationTool = SimulationX 4.2.1.68046 (12/15/20)</li>
<li>generationDateAndTime = 2021-12-21T00:14:54</li>
</ul>
</html>"));
end SF1_fmu;
