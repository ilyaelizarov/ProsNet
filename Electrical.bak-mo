within ProsNet;
package Electrical "Package with models for electrical systems"
  extends Modelica.Icons.Package;

  package UsersGuide "Electrical package user's guide"
    extends Modelica.Icons.Information;
    annotation (preferredView="info",
  Documentation(info="<html>

<h4>Overview</h4>
<p>
The <a href=\"modelica://Buildings.Electrical\">Buildings.Electrical</a> package extends the
capabilities of the Buildings library with models for electrical systems, allowing
to study building-to-grid integration such as the effect of large scale PV on the
voltage of the electrical distribution grid.
The package contains models for different types of sources, loads, storage equipment,
and transmission lines for electric power. The package contains models that can be used to
represent DC, AC one-phase, and AC three-phase balanced and unbalanced systems.
The models can be used to scale from the building level up to the distribution level.
The models have been successfully validated against the IEEE four nodes test feeder.
</p>

<h4>Connectors</h4>
<p>
The <a href=\"modelica://Buildings.Electrical\">Buildings.Electrical</a> package uses a
new type of generalized connector that has been introduced by <a href=\"#RuedigerEtAl2014\">R. Franke and Wiesman (2014)</a>
and is used by the <a href=\"https://github.com/modelica/PowerSystems\">Power Systems Library</a>
and the <a href=\"http://www.modelon.com/products/modelica-libraries/electric-power-library\">
Electric Power Library</a>.
</p>
<p>
The Modelica Standard Library (MSL) version 3.2.1 has different connectors depending on the
type of electric system being modeled. For example, DC and AC continuous time systems have
a connector (<a href=\"modelica://Modelica.Electrical.Analog.Interfaces.Pin\">Modelica.Electrical.Analog.Interfaces.Pin</a>)
that differs from the one used by AC models, which use the
quasi-stationary assumption (<a href=\"modelica://Modelica.Electrical.QuasiStatic.SinglePhase.Interfaces.Pin\">
Modelica.Electrical.QuasiStatic.SinglePhase.Interfaces.Pin</a>).
</p>
<p>
The generalized electrical connector overcomes this limitation. It uses a paradigm
that is similar to the one used by the <code>Modelica.Fluid</code> connectors.
The generalized connector is as follows:
</p>

<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">connector</span>
<span style=\" font-family:'Courier New,courier';\"> Terminal </span>
<span style=\" font-family:'Courier New,courier'; color:#006400;\">&quot;Generalized electric terminal&quot;</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">extends </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.Electrical.Interfaces.BaseTerminal</span>
<span style=\" font-family:'Courier New,courier';\">;</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">replaceable package</span>
<span style=\" font-family:'Courier New,courier';\"> PhaseSystem = </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.Electrical.PhaseSystems.PartialPhaseSystem </span>
<span style=\" font-family:'Courier New,courier'; color:#006400;\">&quot;Phase system&quot;</span>
<span style=\" font-family:'Courier New,courier';\">;</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">PhaseSystem.Voltage</span>
<span style=\" font-family:'Courier New,courier';\"> v[PhaseSystem.n] </span>
<span style=\" font-family:'Courier New,courier'; color:#006400;\">&quot;Voltage vector&quot;</span>
<span style=\" font-family:'Courier New,courier';\">;</span
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">flow </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">PhaseSystem.Current</span>
<span style=\" font-family:'Courier New,courier';\"> i[PhaseSystem.n] </span>
<span style=\" font-family:'Courier New,courier'; color:#006400;\">&quot;Current vector&quot;</span>
<span style=\" font-family:'Courier New,courier';\">;</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">PhaseSystem.ReferenceAngle</span>
<span style=\" font-family:'Courier New,courier';\"> theta[PhaseSystem.m] </span>
<span style=\" font-family:'Courier New,courier'; color:#006400;\">&quot;Optional vector of phase angles&quot;</span>
<span style=\" font-family:'Courier New,courier';\">;</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">end </span>
<span style=\" font-family:'Courier New,courier';\">Terminal;</span>
</p>

<p>
The connector has a package called <code>PhaseSystem</code> that contains constants, functions,
and equations of the specific electric domain. This allows to represent different electrical domains using the
same connector, reusing the same standardized interfaces.
</p>

<p>
As the electrical connectors of the Modelica Standard Library, the <code>Terminal</code> has a vector of voltages as effort variables and
a vector of currents as flow variables. The connector has an additional vector that represents the
reference angle <code>theta[PhaseSystem.m]</code>. If <code>PhaseSystem.m &gt; 0</code> the connector is overdetermined
because the number of effort variables is higher than the number of flow variables.
The over-determined connectors are defined and used in such a way that a Modelica tool is able
to remove the superfluous but consistent equations, arriving at a balanced set of equations based on a
graph analysis of the connection structure. The models in the library uses constructs specified
by the Modelica language to handle this situation <a href=\"#Olsson2008\">Olsson Et Al. (2008)</a>.
</p>

<h4>PhaseSystem</h4>

<p>
The connector has a package called <code>PhaseSystem</code> that allows to represent different
electrical domains using the same connector, reusing the same standardized interfaces.
The available <code>PhaseSystems</code> are contained in the package
<a href=\"modelica://Buildings.Electrical.PhaseSystems\">
Buildings.Electrical.PhaseSystems</a>.
</p>
<p>
Each of the available packages represent a different type of electrical systems.
The electrical systems represented are:
</p>
<ul>
<li>DC systems,</li>
<li>DC systems with two conductors,</li>
<li>one-phase AC systems,</li>
<li>three-phase resistive balanced AC systems,</li>
<li>three-phase balanced AC systems,</li>
<li>three-phase unbalanced AC systems (dq0 representation).</li>
</ul>

<h4>Linearized models and homotopy initialization</h4>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Loads/simpleLoad.png\"/>
</p>
<p>
Consider the simple DC circuit shown above, where <i>V<sub>S</sub></i> is a
constant voltage source and <i>R</i> is a line resistance. The load has a voltage <i>V</i> across
its electrical pins and a current <i>i</i>. If the power consumed
by the load is <i>P<sub>LOAD</sub></i>, the equation that describes the circuit is nonlinear.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/UsersGuide/nonlinearEq.png\"/>
</p>

<p>
If the number of loads increases, as typically happens in grid simulations, the size of the system of
nonlinear equations to be solved increases too, causing the numerical solver to slow the simulation.
A linearized load model can solve such a problem. All the load models in the
<a href=\"modelica://Buildings.Electrical\">Buildings.Electrical</a> package have a linearized version.
The linearized version of the model can be selected by setting the boolean flag <code>linearized = true</code>.
Details about the implementation of the linearized models can be found in
<a href=\"modelica://Buildings.Electrical.DC.Loads.Conductor\">Buildings.Electrical.DC.Loads.Conductor</a>
or
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Resistive\">Buildings.Electrical.AC.OnePhase.Loads.Resistive</a>.
</p>

<p>
When multiple loads are connected in a grid through cables that cause voltage drops,
the dimension of the system of nonlinear equations increases linearly with the number of loads.
This nonlinear system of equations introduces challenges during the initialization, as Newton solvers
may diverge if initialized far from a solution.
The initialization problem can be simplified using the homotopy
operator. The homotopy operator uses two different types of equations to compute the value of a
variable: the actual one and a simplified one. The actual equation is the one used during the normal
operation. During initialization, the simplified equation is first solved and then slowly replaced with the
actual equation to compute the initial values for the nonlinear systems of equations.
The load model uses the homotopy operator, with the linearized model being used
as the simplified equation. This numerical expedient has proven useful
when simulating models with more than ten connected loads.
All the load models of the <a href=\"modelica://Buildings.Electrical\">Buildings.Electrical</a> package use the
the homotopy operator during the initialization. The parameter <code>initMode</code> is used to select which
simplified equation should be used by the homotopy operator:
</p>
<ul>
<li><code>Buildings.Electrical.Types.InitMode.zeroCurrent</code></li>
<li><code>Buildings.Electrical.Types.InitMode.linearized</code></li>
</ul>

<h4>Nominal values</h4>
<p>
Most components have a parameters for the nominal operating conditions.
These parameters have names that end in <code>_nominal</code> and
they should be set to the values that the component typically
have if they are run at design conditions. Depending on the model, these
parameters are used differently, and the respective model documentation or code
should be consulted for details. However, the table below shows the typical use of
the parameters in various models to help the user understand how they are used.
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
<th>Parameter</th>
<th>Model</th>
<th>Functionality</th>
</tr>
<tr>
  <td>V_nominal<br/>
      P_nominal</td>
  <td>Load models</td>
  <td>
  <code>V_nominal</code> is the RMS (Root Mean Square) voltage at which the load consumes the
  nominal real power (measured in [W]) <code>P_nominal</code>.
  When the load model are linearized, the linearization is done for <code>V = V_nominal</code>.
  </td>
</tr>
<tr>
  <td>V_nominal<br/>
      P_nominal</td>
  <td>Transmission line models
  </td>
  <td>
  <code>V_nominal</code> is the RMS (Root Mean Square) voltage at which the line operates
  while <code>P_nominal</code> is the power flowing through it. These values are used in some
  cases to automatically select the right cable properties.
  </td>
</tr>
<tr>
  <td>V_nominal</td>
  <td>Storage<br/>
      PVs<br/>
      Wind turbine
  </td>
  <td>
  <code>V_nominal</code> is the RMS (Root Mean Square) voltage at which these components
  typically operate. Since these model contain load models, <code>V_nominal</code> can be used
  for linearization purposes.
  </td>
</tr>
<tr>
  <td>V_nominal</td>
  <td>Sensors</td>
  <td>
  <code>V_nominal</code> is the RMS (Root Mean Square) voltage of the system
  that is currently measured, it can be used to measure quantities in per unit [pu].
  </td>
</tr>
</table>

<h4>Other information</h4>
<p>
Other information about the models and the packages can be found in the
info section of each model or sub-packages.
</p>

<h4>Awards</h4>
<p>
The paper titled <a href=\"modelica://Buildings/Resources/Images/Electrical/UsersGuide/2014-BauSim-BonviniWetterNouidui.pdf\">
A Modelica package for building-to-electrical grid integration</a> won the best paper
award at the BauSIM 2014 conference.
</p>

<h4>References</h4>
<p>
<a name=\"BonviniEtAl2014\"/>
Marco Bonvini, Michael Wetter, and Thierry Stephane Nouidui.<br/>
<a href=\"modelica://Buildings/Resources/Images/Electrical/UsersGuide/2014-BauSim-BonviniWetterNouidui.pdf\">
A Modelica package for building-to-electrical grid integration</a><br/>
<i>BauSIM 2014 Conference</i>, Aachen, Germany, September 2014.<br/>
</p>

<p>
<a name=\"RuedigerEtAl2014\"/>
Rudiger Franke and Hansjorg Wiesmann.<br/>
<a href=\"https://www.modelica.org/events/modelica2014/proceedings/html/submissions/ECP14096515_FrankeWiesmann.pdf\">
Flexible modeling of electrical power systems - the Modelica PowerSystems library</a>.<br/>
Proc. of the 10th Modelica Conference, Lund, Sweden, March 2014.<br/>
</p>

<p>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.<br/>
</p>
</html>",   revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created User's guide.
</li>
</ul>
</html>"));
  end UsersGuide;

  package AC "Package for electrical systems in which the frequency is modeled as quasi-stationary"
    extends Modelica.Icons.Package;

  package UsersGuide "User's Guide"
    extends Modelica.Icons.Information;

      annotation (preferredView="info",
  Documentation(info="<html>
<p>
The package
<a href=\"modelica://Buildings.Electrical.AC\">Buildings.Electrical.AC</a>
models alternate current electrical systems.
</p>

<h4>Modeling assumptions</h4>
<p>
The package <a href=\"modelica://Buildings.Electrical.AC\">Buildings.Electrical.AC</a> contains
component models for AC systems. The mathematics that describes AC systems is contained in the package
<a href=\"modelica://Buildings.Electrical.PhaseSystems.OnePhase\">Buildings.Electrical.PhaseSystems.OnePhase</a>,
in which <code>n = 2</code> and <code>m = 1</code>. The AC models that are part of the library can use two different assumptions.
</p>
<p>
The first assumption is that the frequency is modeled as quasi-stationary, assuming a perfect sine
wave with no higher harmonics. Voltages and currents are considered as sine waves and just their
amplitudes and phase shifts are taken into account during the analysis.
With such an assumption, electric quantities can be represented with a phasor, i.e., a vector
in the complex plane.
</p>
<p>
The second assumption is the so-called dynamic phasorial representation. The basic idea of the
dynamic phasorial representation is to account for dynamic variations of the amplitude and
the angle of the phasors. With such an approach, it is possible to analyze faster dynamics
without directly representing all the electromagnetic effects and high-order harmonics
(for more details, see <a href=\"#Stankovic1999\">Stankovic Et Al. 1999</a>, and
<a href=\"#Stankovic2000\">Stankovic A.M. and Aydin T.</a>).
</p>

<h4>Phasorial representation</h4>
<p>
Both the quasi-stationary and the dynamic phasors represent electric
quantities such as voltages and currents using phasors.
The phasors are described by complex numbers that internally are represented as a vector
with two components. The vectors can be represented in the so called Argand plane where on the x-axis
are represented Real numbers while on the y-axis imaginary numbers.
</p>
<p>
With such a representation the complex voltages, currents, and powers are represented as
</p>
<p align=\"center\" style=\"font-style:italic;\">
<span style=\"text-decoration: overline;\">V</span> = V<sub>Re</sub> + j V<sub>Im</sub>,
</p>
<p align=\"center\" style=\"font-style:italic;\">
<span style=\"text-decoration: overline;\">I</span> = I<sub>Re</sub> + j I<sub>Im</sub>,
</p>
<p align=\"center\" style=\"font-style:italic;\">
<span style=\"text-decoration: overline;\">S</span> = P + j Q,
</p>

<p>
The images below shows how the complex power vector <i><span style=\"text-decoration: overline;\">S</span></i>
changes depending on the type of load.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/ComplexPower.png\"/>
</p>

<p>
where the subscripts indicates a
</p>

<ul>
<li><i>R</i> - purely resistive load</li>
<li><i>L</i> - purely inductive load</li>
<li><i>C</i> - purely capacitive load</li>
<li><i>RL</i> - resistive inductive load</li>
<li><i>RC</i> - resistive capacitive load</li>
</ul>

<h4>Reference angle for AC systems</h4>
<p>
The AC connector has an additional vector that represents the
reference angle <code>theta[PhaseSystem.m]</code>. The reference angle is used, for example in the
AC single phase systems to describe the phase angle of the reference voltage.
This extra information in the connector makes it overdetermined
because the number of effort variables is higher than the number of flow variables.
The over-determined connectors are defined and used in such a way that a Modelica tool is able
to remove the superfluous but consistent equations, arriving at a balanced set of equations based on a
graph analysis of the connection structure. The models in the library uses constructs specified
by the Modelica language to handle this situation, as described by <a href=\"#Olsson2008\">Olsson et al. (2008)</a>.
</p>
<p>
The reference angles are usually defined by the sources (e.g., voltage sources or generators) and
their values need to be propagated to all the components connected to them.
If more than one generator are connected to the same network, the Modelica tool is able to remove the superfluous equations,
arriving at a balanced set of equations based on a graph analysis of the connection structure.
The flags <code>potentialReference</code> and <code>definiteReference</code> are used to help the
Modelica tool during the selection of the reference angle. If <code>definiteReference = true</code>,
then the reference angle of the source has to be used as reference, while if
<code>potentialReference = true</code>, the reference angle is used only if there are no
definite sources defined.
</p>
<p>
When a model is set as definite source an icon representing a phase angle is placed close to its
electrical terminal.
</p>


<h4>References</h4>
<p>
<a name=\"Stankovic1999\"/>
A.M. Stankovic, B.C. Lesieutre, T. Aydin; Modeling and analysis of single-pahse
induction machines with dynamic phasors<br/>
<a href=\"http://www.ece.neu.edu/faculty/stankovic/Jour_papers/pwrs299im.pdf\">
<i>IEEE Transactions on Power Systems</i>, 14(1), Feb. 1999, pp. 9-14.</a><br/>
<a name=\"Stankovic2000\"/>
A.M. Stankovic, T. Aydin; Analysis of asymmetrical faults in power systems using
dynamic phasors<br/>
<a href=\"http://www.ece.neu.edu/faculty/stankovic/Jour_papers/pwrs299im.pdf\">
<i>IEEE Transactions on Power Systems</i>, 15(3), 2000, pp. 1062-1068 .</a><br/>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.<br/>
</p>

</html>"));
  end UsersGuide;

    package OnePhase "One phase AC systems"
    extends Modelica.Icons.VariantsPackage;

      package Basics "Package with basic models"
      extends Modelica.Icons.BasesPackage;

        model Ground "Ground connection"
          extends ProsNet.Electrical.Interfaces.Ground(redeclare package
              PhaseSystem = PhaseSystems.OnePhase, redeclare
              Interfaces.Terminal_n terminal);
          annotation (
            defaultComponentName="gnd",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{0,90},{0,0}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Line(
                  points={{-80,0},{80,0}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Line(
                  points={{-60,-20},{60,-20}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Line(
                  points={{-40,-40},{40,-40}},
                  color={0,120,120},
                  smooth=Smooth.None)}), Documentation(info="<html>
<p>
This model represents a connection to the ground.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
        end Ground;
      annotation (Documentation(info="<html>
<p>
This package contains simple models used in AC single phase networks.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Basics;

      package Conversion "Package with models for AC/AC and AC/DC conversion"
        extends Modelica.Icons.Package;

        model ACACConverter "AC AC converter single phase systems"
          extends ProsNet.Electrical.Icons.RefAngleConversion;
          extends ProsNet.Electrical.Interfaces.PartialConversion(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n
              constrainedby Interfaces.Terminal_n(i(start=zeros(PhaseSystem_n.n),
                  each stateSelect=StateSelect.prefer)),
            redeclare replaceable Interfaces.Terminal_p terminal_p
              constrainedby Interfaces.Terminal_p(i(start=zeros(PhaseSystem_p.n),
                  each stateSelect=StateSelect.prefer)));
          parameter Real conversionFactor(min = Modelica.Constants.eps)
            "Ratio of QS rms voltage on side 2 / QS rms voltage on side 1";
          parameter Real eta(min=0, max=1)
            "Converter efficiency, pLoss = (1-eta) * Ptr";
          parameter Boolean ground_1 = false
            "If true, connect side 1 of converter to ground"
             annotation(Evaluate=true,Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true
            "If true, connect side 2 of converter to ground"
            annotation(Evaluate=true, Dialog(tab = "Ground", group="side 2"));
          Modelica.Units.SI.Power LossPower[2] "Loss power";
        protected
          Modelica.Units.SI.Power P_p[2]=PhaseSystem_p.phasePowers_vi(terminal_p.v,
              terminal_p.i) "Power transmitted at pin p";
          Modelica.Units.SI.Power P_n[2]=PhaseSystem_n.phasePowers_vi(terminal_n.v,
              terminal_n.i) "Power transmitted at pin n";
        equation

          // Ideal transformation
          terminal_p.v = conversionFactor*terminal_n.v;

          // Power loss term
          terminal_p.i[1] = terminal_n.i[1]/conversionFactor*
            Buildings.Utilities.Math.Functions.spliceFunction(eta-2, 1/(eta-2), P_p[1], deltax=0.1);
          terminal_p.i[2] = terminal_n.i[2]/conversionFactor*
            Buildings.Utilities.Math.Functions.spliceFunction(eta-2, 1/(eta-2), P_p[1], deltax=0.1);
          LossPower = P_p + P_n;

          // The two sides have the same reference angle
          terminal_p.theta = terminal_n.theta;

          if ground_1 then
            Connections.potentialRoot(terminal_n.theta);
          end if;
          if ground_2 then
            Connections.root(terminal_p.theta);
          end if;

          annotation (
          defaultComponentName="conACAC",
         Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                              graphics={
                Line(
                  points={{2,60},{2,60},{82,60},{2,60},{82,-60},{2,-60},{2,60},{2,-60}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Line(
                  points={{-2,60},{-2,60},{-82,60},{-2,60},{-82,-60},{-2,-60},{-2,60},{
                      -2,-60}},
                  color={11,193,87},
                  smooth=Smooth.None),
                Text(
                  extent={{-100,92},{100,60}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%conversionFactor"),
                Text(
                  extent={{-100,-100},{100,-132}},
                  textColor={0,120,120},
                  textString="%eta"),
                Text(
                  extent={{-132,78},{-72,38}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-88,52},{-28,12}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{32,52},{92,12}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,78},{130,38}},
                  textColor={0,120,120},
                  textString="2")}),
            Documentation(info="<html>
<p>
This is an AC/AC converter, based on a power balance between both circuit sides.
The parameter <i>conversionFactor</i> defines the ratio between the RMS voltages
as
</p>

<p align=\"center\" style=\"font-style:italic;\">
V<sub>2</sub> = conversionFactor  V<sub>1</sub>
</p>

<p>
where <i>V<sub>1</sub></i> and <i>V<sub>2</sub></i> are the RMS voltages
at the primary and secondary sides of the transformer, i.e., the
connector N and P, respectively.
</p>

<p>
The loss of the converter is proportional to the power transmitted.
The parameter <code>eta</code> is the efficiency of the transfer.
The loss is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
P<sub>loss</sub> = (1-&eta;) P<sub>tr</sub>,
</p>
<p>
where <i>P<sub>tr</sub></i> is the power transmitted. The model is bi-directional
and the power can flow from the primary to the secondary side and vice-versa.
Furthermore, reactive power on both side are set to zero.
</p>
<h4>Note:</h4>
<p>
This model is derived from
<a href=\"modelica://Modelica.Electrical.QuasiStatic.SinglePhase.Utilities.IdealACDCConverter\">
Modelica.Electrical.QuasiStatic.SinglePhase.Utilities.IdealACDCConverter</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added missing <code>replaceable</code> for the terminal.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 9, 2014, by Marco Bonvini:<br/>
Revised implementation and added <code>stateSelect</code> statement to use
the current <code>i[:]</code> on the connectors as iteration variable for the
initialization problem.
</li>
<li>
January 29, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACConverter;

        model ACACTransformer "AC AC transformer simplified equivalent circuit"
          extends ProsNet.Electrical.Icons.RefAngleConversion;
          extends ProsNet.Electrical.Interfaces.PartialConversion(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n
              constrainedby Interfaces.Terminal_n(i(start=zeros(PhaseSystem_n.n),
                  each stateSelect=StateSelect.prefer)),
            redeclare replaceable Interfaces.Terminal_p terminal_p
              constrainedby Interfaces.Terminal_p(i(start=zeros(PhaseSystem_p.n),
                  each stateSelect=StateSelect.prefer)));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false
            "If true, connect side 1 of converter to ground"
            annotation(Evaluate=true,Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true
            "If true, connect side 2 of converter to ground"
            annotation(Evaluate=true, Dialog(tab = "Ground", group="side 2"));
          parameter Modelica.Units.SI.Angle phi_1=0
            "Angle of the voltage side 1 at initialization"
            annotation (Evaluate=true, Dialog(tab="Initialization"));
          parameter Modelica.Units.SI.Angle phi_2=phi_1
            "Angle of the voltage side 2 at initialization"
            annotation (Evaluate=true, Dialog(tab="Initialization"));
          Modelica.Units.SI.Efficiency eta "Efficiency";
          Modelica.Units.SI.Power PLoss[2] "Loss power";

          Modelica.Units.SI.Voltage V1[2](start=PhaseSystem_n.phaseVoltages(VHigh,
                phi_1)) "Voltage at the winding - primary side";
          Modelica.Units.SI.Voltage V2[2](start=PhaseSystem_p.phaseVoltages(VLow, phi_2))
            "Voltage at the winding - secondary side";
        protected
          Real N = VHigh/VLow "Winding ratio";
          Modelica.Units.SI.Current IHigh=VABase/VHigh
            "Nominal current on primary side";
          Modelica.Units.SI.Current ILow=VABase/VLow
            "Nominal current on secondary side";
          Modelica.Units.SI.Current IscHigh=IHigh/Zperc
            "Short circuit current on primary side";
          Modelica.Units.SI.Current IscLow=ILow/Zperc
            "Short circuit current on secondary side";
          Modelica.Units.SI.Impedance Zp=VHigh/IscHigh
            "Impedance of the primary side (module)";
          Modelica.Units.SI.Impedance Z1[2]={Zp*cos(atan(XoverR)),Zp*sin(atan(XoverR))}
            "Impedance of the primary side of the transformer";
          Modelica.Units.SI.Impedance Zs=VLow/IscLow
            "Impedance of the secondary side (module)";
          Modelica.Units.SI.Impedance Z2[2]={Zs*cos(atan(XoverR)),Zs*sin(atan(XoverR))}
            "Impedance of the secondary side of the transformer";
          Modelica.Units.SI.Power P_p[2]=PhaseSystem_p.phasePowers_vi(terminal_p.v,
              terminal_p.i) "Power transmitted at pin p (secondary)";
          Modelica.Units.SI.Power P_n[2]=PhaseSystem_n.phasePowers_vi(terminal_n.v,
              terminal_n.i) "Power transmitted at pin n (primary)";
          Modelica.Units.SI.Power S_p=Modelica.Fluid.Utilities.regRoot(P_p[1]^2 + P_p[2]
              ^2, delta=0.1) "Apparent power at terminal p";
          Modelica.Units.SI.Power S_n=Modelica.Fluid.Utilities.regRoot(P_n[1]^2 + P_n[2]
              ^2, delta=0.1) "Apparent power at terminal n";

        equation
          // Efficiency
          eta = Buildings.Utilities.Math.Functions.smoothMin(
                x1=
                Modelica.Fluid.Utilities.regRoot(P_p[1]^2 + P_p[2]^2, delta=0.01)/
                Modelica.Fluid.Utilities.regRoot(P_n[1]^2 + P_n[2]^2 + 1e-6, delta=0.01),
                x2=
                Modelica.Fluid.Utilities.regRoot(P_n[1]^2 + P_n[2]^2, delta=0.01)/
                Modelica.Fluid.Utilities.regRoot(P_p[1]^2 + P_p[2]^2 + 1e-6, delta=0.01),
                deltaX = 0.01);

          // Ideal transformation
          V2 = V1/N;
          terminal_p.i[1] + terminal_n.i[1]*N = 0;
          terminal_p.i[2] + terminal_n.i[2]*N = 0;

          // Losses due to the impedance
          terminal_n.v = V1 + ProsNet.Electrical.PhaseSystems.OnePhase.product(
            terminal_n.i, Z1);
          V2 = terminal_p.v;

          // Loss of power
          PLoss = P_p + P_n;

          // The two sides have the same reference angle
          terminal_p.theta = terminal_n.theta;

          if ground_1 then
            Connections.potentialRoot(terminal_n.theta);
          end if;
          if ground_2 then
            Connections.root(terminal_p.theta);
          end if;

          annotation (
          defaultComponentName="traACAC",
         Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                              graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L")}),
            Documentation(info="<html>
<p>
This is a simplified equivalent transformer model.
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent both the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>VHigh</code> - RMS voltage at primary side,</li>
<li><code>VLow</code> - RMS voltage at secondary side,</li>
<li><code>VABase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions,the model computes the values of the resistance and the inductance.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added missing <code>replaceable</code> for the terminal.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Made voltage public to allow setting a start value in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.UnbalancedStepUp.DY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.UnbalancedStepUp.DY</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>June 17, 2014, by Marco Bonvini:<br/>
Adde parameter <code>phi_1</code> and <code>phi_2</code> that are
used during initialization to specify the angle of the voltage phasor.
</li>
<li>
June 9, 2014, by Marco Bonvini:<br/>
Revised implementation and added <code>stateSelect</code> statement to use
the current <code>i[:]</code> on the connectors as iteration variable for the
initialization problem.
</li>
<li>
January 29, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformer;

        model ACACTransformerFull "AC AC transformer with detailed equivalent circuit"
          extends ProsNet.Electrical.Icons.RefAngleConversion;
          extends ProsNet.Electrical.Interfaces.PartialConversion(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n
              constrainedby Interfaces.Terminal_n(i(start=zeros(PhaseSystem_n.n),
                  each stateSelect=StateSelect.prefer)),
            redeclare replaceable Interfaces.Terminal_p terminal_p
              constrainedby Interfaces.Terminal_p(i(start=zeros(PhaseSystem_p.n),
                  each stateSelect=StateSelect.prefer)));
          parameter Modelica.Units.SI.Voltage VHigh
            "RMS voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "RMS voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Modelica.Units.SI.Frequency f(start=60) "Nominal frequency";
          parameter ProsNet.Electrical.Types.PerUnit R1(min=0)
            "Resistance on side 1 of the transformer (pu)";
          parameter ProsNet.Electrical.Types.PerUnit L1(min=0)
            "Inductance on side 1 of the transformer (pu)";
          parameter ProsNet.Electrical.Types.PerUnit R2(min=0)
            "Resistance on side 2 of the transformer (pu)";
          parameter ProsNet.Electrical.Types.PerUnit L2(min=0)
            "Inductance on side 2 of the transformer (pu)";
          parameter Boolean magEffects = false
            "If true, introduce magnetization effects"
            annotation(Evaluate=true, Dialog(group="Magnetization"));
          parameter ProsNet.Electrical.Types.PerUnit Rm(min=0)
            "Magnetization resistance (pu)" annotation (Evaluate=true, Dialog(
                group="Magnetization", enable=magEffects));
          parameter ProsNet.Electrical.Types.PerUnit Lm(min=0)
            "Magnetization inductance (pu)" annotation (Evaluate=true, Dialog(
                group="Magnetization", enable=magEffects));
          parameter Boolean ground_1 = false "Connect side 1 of converter to ground"
           annotation(Evaluate=true,Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of converter to ground"
           annotation(Evaluate=true, Dialog(tab = "Ground", group="side 2"));
          parameter Modelica.Units.SI.Angle phi_1=0
            "Angle of the voltage side 1 at initialization"
            annotation (Evaluate=true, Dialog(tab="Initialization"));
          parameter Modelica.Units.SI.Angle phi_2=phi_1
            "Angle of the voltage side 2 at initialization"
            annotation (Evaluate=true, Dialog(tab="Initialization"));
          Modelica.Units.SI.Efficiency eta "Efficiency";
          Modelica.Units.SI.Power PLoss[2] "Loss power";

          Modelica.Units.SI.Voltage V1[2](start=PhaseSystem_n.phaseVoltages(VHigh,
                phi_1)) "Voltage at the winding - primary side";
          Modelica.Units.SI.Voltage V2[2](start=PhaseSystem_n.phaseVoltages(VLow, phi_2))
            "Voltage at the winding - secondary side";
        protected
          parameter Modelica.Units.SI.AngularVelocity omega_n=2*Modelica.Constants.pi*f;
          parameter Real N = VHigh/VLow "Winding ratio";
          parameter Modelica.Units.SI.Resistance RBaseHigh=VHigh^2/VABase
            "Base impedance of the primary side";
          parameter Modelica.Units.SI.Resistance RBaseLow=VLow^2/VABase
            "Base impedance of the secondary side";
          Modelica.Units.SI.Impedance Z1[2]={RBaseHigh*R1,omega*L1*RBaseHigh/omega_n}
            "Impedance of the primary side of the transformer";
          Modelica.Units.SI.Impedance Z2[2]={RBaseLow*R2,omega*L2*RBaseLow/omega_n}
            "Impedance of the secondary side of the transformer";
          Modelica.Units.SI.Impedance Zrm[2]={RBaseHigh*Rm,0}
            "Magnetization impedance - resistance";
          Modelica.Units.SI.Impedance Zlm[2]={0,omega*Lm*RBaseHigh/omega_n}
            "Magnetization impedance - impedence";
          Modelica.Units.SI.Power P_p[2]=PhaseSystem_p.phasePowers_vi(terminal_p.v,
              terminal_p.i) "Power transmitted at pin p (secondary)";
          Modelica.Units.SI.Power P_n[2]=PhaseSystem_n.phasePowers_vi(terminal_n.v,
              terminal_n.i) "Power transmitted at pin n (primary)";
          Modelica.Units.SI.Power S_p=Modelica.Fluid.Utilities.regRoot(P_p[1]^2 + P_p[2]
              ^2, delta=0.1) "Apparent power at terminal p";
          Modelica.Units.SI.Power S_n=Modelica.Fluid.Utilities.regRoot(P_n[1]^2 + P_n[2]
              ^2, delta=0.1) "Apparent power at terminal n";
          Modelica.Units.SI.AngularVelocity omega "Angular velocity";
          Modelica.Units.SI.Current Im[2] "Magnetization current";
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";
        equation
          assert(sqrt(P_p[1]^2 + P_p[2]^2) <= VABase*1.01,
            "The load power of the transformer is higher than VABase");

          // Angular velocity
          theRef = PhaseSystem_p.thetaRef(terminal_p.theta);
          omega = der(theRef);

          // Efficiency
          eta = Buildings.Utilities.Math.Functions.smoothMin(
                x1=
                Modelica.Fluid.Utilities.regRoot(P_p[1]^2 + P_p[2]^2, delta=0.01)/
                Modelica.Fluid.Utilities.regRoot(P_n[1]^2 + P_n[2]^2 + 1e-6, delta=0.01),
                x2=
                Modelica.Fluid.Utilities.regRoot(P_n[1]^2 + P_n[2]^2, delta=0.01)/
                Modelica.Fluid.Utilities.regRoot(P_p[1]^2 + P_p[2]^2 + 1e-6, delta=0.01),
                deltaX = 0.01);

          // Ideal transformation
          V2 = V1/N;
          terminal_p.i[1] + (terminal_n.i[1] - Im[1])*N = 0;
          terminal_p.i[2] + (terminal_n.i[2] - Im[2])*N = 0;

          // Magnetization current
          if magEffects then
            Im = ProsNet.Electrical.PhaseSystems.OnePhase.divide(V1, Zrm) +
              ProsNet.Electrical.PhaseSystems.OnePhase.divide(V1, Zlm);
          else
            Im = zeros(2);
          end if;

          // Losses due to the impedance - primary side
          terminal_n.v = V1 + ProsNet.Electrical.PhaseSystems.OnePhase.product(
            terminal_n.i, Z1);

          // Losses due to the impedance - secondary side
          terminal_p.v = V2 + ProsNet.Electrical.PhaseSystems.OnePhase.product(
            terminal_p.i, Z2);

          // Loss of power
          PLoss = P_p + P_n;

          // The two sides have the same reference angle
          terminal_p.theta = terminal_n.theta;

          if ground_1 then
            Connections.potentialRoot(terminal_n.theta);
          end if;
          if ground_2 then
            Connections.root(terminal_p.theta);
          end if;

          annotation (
        defaultComponentName="traACAC",
         Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                              graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-140,60},{-80,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{80,60},{140,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-100,40},{-94,40},{-92,44},{-88,36},{-84,44},{-80,36},{-76,44},
                      {-72,36},{-70,40},{-64,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-64,46},{-52,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-52,46},{-40,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-40,46},{-28,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-64,40},{-26,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{0,40},{0,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-6,20},{6,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,8},{6,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,-4},{6,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-10,20},{0,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{0,-16},{0,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{0,-40},{-90,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{14,40},{14,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{20,20},{8,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,8},{8,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,-4},{8,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{24,20},{14,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{14,-16},{14,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{100,-40},{14,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-80,60},{-64,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-54,60},{-38,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{66,40},{72,40},{74,44},{78,36},{82,44},{86,36},{90,44},{94,36},
                      {96,40},{100,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-54,-6.61288e-15}},
                  color={0,127,127},
                  origin={14,40},
                  rotation=180),
                Ellipse(
                  extent={{26,46},{38,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{38,46},{50,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{50,46},{62,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{26,40},{62,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Text(
                  extent={{76,60},{92,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{36,60},{52,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{-26,-1},{-10,-1},{-9,4},{-5,-4},{-1,4},{3,-4},{7,4},{10,-5},{
                      12,-1},{22,-1}},
                  color={0,127,127},
                  smooth=Smooth.None,
                  origin={-45,2},
                  rotation=90),
                Ellipse(
                  extent={{-36,18},{-24,6}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-36,6},{-24,-6}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-36,-6},{-24,-18}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-40,18},{-30,-18}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-28,-2.09669e-15}},
                  color={0,127,127},
                  origin={-28,40},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-1.53415e-16,-6}},
                  color={0,127,127},
                  origin={-30,18},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-1.53415e-16,-6}},
                  color={0,127,127},
                  origin={-30,-24},
                  rotation=180),
                Line(
                  points={{-44,24},{-20,24},{-20,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{-44,-24},{-20,-24},{-20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-70,22},{-54,10}},
                  textColor={0,120,120},
                  textString="Rm"),
                Text(
                  extent={{-70,-8},{-54,-20}},
                  textColor={0,120,120},
                  textString="Lm")}),
            Documentation(info="<html>
<p>
This is a detailed transformer model that takes into account the winding Joule losses
and the leakage reactances on both primary and secondary side. The model also describes
the core or iron losses and the losses due to magnetization effects.
</p>
<p>
The losses are represented by a series of resistances <i>R<sub>1</sub></i>, <i>R<sub>2</sub></i>,
<i>R<sub>m</sub></i> and inductances <i>L<sub>1</sub></i>, <i>L<sub>2</sub></i>, and
<i>L<sub>m</sub></i>.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>VHigh</code> - RMS voltage at primary side,</li>
<li><code>VLow</code> - RMS voltage at secondary side,</li>
<li><code>VABase</code> - apparent nominal power of the transformer,</li>
<li><code>f</code> - frequency,</li>
<li><code>R_1, L_1</code> - resistance and inductance at primary side (per unit),</li>
<li><code>R_2, L_2</code> - resistance and inductance at secondary side (per unit), and</li>
<li><code>R_m, L_m</code> - resistance and inductance for magnetization effects (per unit).</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the nominal impedances
at both primary and secondary side. Given these values, the per unit values are transformed into
the actual values of the resistances and inductances.
</p>
<p>
The magnetization losses can be enabled or disabled using the boolean flag <code>magEffects</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added missing <code>replaceable</code> for the terminal.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Made voltage public to allow setting a start value.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>June 17, 2014, by Marco Bonvini:<br/>
Adde parameter <code>phi_1</code> and <code>phi_2</code> that are
used during initialization to specify the angle of the voltage phasor.
</li>
<li>
June 9, 2014, by Marco Bonvini:<br/>
Revised implementation and added <code>stateSelect</code> statement to use
the current <code>i[:]</code> on the connectors as iteration variable for the
initialization problem.
</li>
<li>
January 29, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformerFull;

        model ACDCConverter "AC DC converter"
          extends ProsNet.Electrical.Interfaces.PartialConversion(
            redeclare package PhaseSystem_p = PhaseSystems.TwoConductor,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n
              constrainedby Interfaces.Terminal_n(i(start=zeros(PhaseSystem_n.n),
                  each stateSelect=StateSelect.prefer)),
            redeclare DC.Interfaces.Terminal_p terminal_p(i(start=zeros(
                    PhaseSystem_p.n), each stateSelect=StateSelect.prefer)));
          parameter Real conversionFactor(min = Modelica.Constants.eps)
            "Ratio of DC voltage / AC RMS voltage";
          parameter Real eta(min=0, max=1)
            "Converter efficiency, pLoss = (1-eta) * Ptr";
          Modelica.Units.SI.Power PLoss "Loss power";
          parameter Boolean ground_AC = false "Connect AC side of converter to ground" annotation(Evaluate=true, Dialog(tab = "Ground", group="AC side"));
          parameter Boolean ground_DC = true "Connect DC side of converter to ground" annotation(Evaluate=true, Dialog(tab = "Ground", group="DC side"));
        protected
          PhaseSystem_p.Current i_dc "DC current";
          PhaseSystem_p.Voltage v_dc "DC voltage";
          Modelica.Units.SI.Power P_p[2]=PhaseSystem_p.phasePowers_vi(terminal_p.v,
              terminal_p.i) "Power transmitted at pin p (secondary)";
          Modelica.Units.SI.Power P_n[2](each start=0) = PhaseSystem_n.phasePowers_vi(
            terminal_n.v, terminal_n.i) "Power transmitted at pin n (primary)";
        equation
          //voltage relation
          v_p = v_n*conversionFactor;

          // Power losses
          PLoss = (1-eta)*
            Buildings.Utilities.Math.Functions.spliceFunction(P_p[1], P_n[1], i_p, deltax=0.1);
          P_n + P_p = {PLoss, 0};

          if ground_AC then
            Connections.potentialRoot(terminal_n.theta);
          end if;

          if ground_DC then
            v_dc = 0;
            Connections.root(terminal_p.theta);
          else
            i_dc = 0;
            Connections.potentialRoot(terminal_p.theta);
          end if;

          v_dc = terminal_p.v[2];
          sum(terminal_p.i) + i_dc = 0;

          annotation (
        defaultComponentName="conACDC",
         Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}),
                                              graphics={
                Line(
                  points={{2,60},{2,60},{82,60},{2,60},{82,-60},{2,-60},{2,60},{2,-60}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Text(
                  extent={{36,54},{96,14}},
                  textColor={0,0,255},
                  textString="DC"),
                Line(
                  points={{-2,60},{-2,60},{-82,60},{-2,60},{-82,-60},{-2,-60},{-2,60},{
                      -2,-60}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Text(
                  extent={{-100,52},{-40,12}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{-100,92},{100,60}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%conversionFactor"),
                Text(
                  extent={{-100,-100},{100,-132}},
                  textColor={0,0,0},
                  textString="%eta"),
                Line(visible = ground_DC == true,
                  points={{100,-100},{100,-12}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(visible = ground_DC == true,
                  points={{80,-100},{120,-100}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(visible = ground_DC == true,
                  points={{88,-106},{112,-106}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(visible = ground_DC == true,
                  points={{94,-112},{108,-112}},
                  color={0,0,255},
                  smooth=Smooth.None),
                Line(visible = ground_AC == true,
                  points={{-80,-40},{-120,-40}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(visible = ground_AC == true,
                  points={{-80,-40},{-106,-14}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(visible = ground_AC == true,
                  points={{-102,-16},{-114,-24},{-118,-42}},
                  color={0,120,120},
                  smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>
This is an AC/DC converter, based on a power balance between both circuit sides.
The parameter <code>conversionFactor</code> defines the ratio between the RMS voltages
as
</p>

<p align=\"center\" style=\"font-style:italic;\">
V<sub>DC</sub> = conversionFactor V<sub>AC</sub>,
</p>

<p>
where <i>V<sub>DC</sub></i> is the voltage of the DC circuit and <i>V<sub>AC</sub></i>
is the RMS voltage at the primary side of the transformer.
</p>

<p>
The loss of the converter is proportional to the power transmitted.
The parameter <code>eta</code> is the efficiency of the transfer.
The loss is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
P<sub>loss</sub> = (1-&eta;) P<sub>tr</sub>
</p>
<p>
where <i>P<sub>tr</sub></i> is the power transmitted. The model is bi-directional
and the power can flow from both the primary to the secondary side and vice-versa.
Furthermore, reactive power on both side are set to <i>0</i>.
</p>
<h4>Note:</h4>
<p>
This model is derived from
<a href=\"modelica://Modelica.Electrical.QuasiStatic.SinglePhase.Utilities.IdealACDCConverter\">
Modelica.Electrical.QuasiStatic.SinglePhase.Utilities.IdealACDCConverter</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added missing <code>replaceable</code> for the terminal.
</li>
<li>
March 30, 2015, by Michael Wetter:<br/>
Added missing <code>each</code>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 9, 2014, by Marco Bonvini:<br/>
Revised implementation and added <code>stateSelect</code> statement to use
the current <code>i[:]</code> on the connectors as iteration variable for the
initialization problem.
</li>
<li>
January 4, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACDCConverter;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model ACACConverter
            "This example illustrates how to use the AC/AC converter model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACConverter conACAC(eta=0.9,
                conversionFactor=60/120) "ACAC transformer"
              annotation (Placement(transformation(extent={{-10,0},{10,20}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-60,10})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive load(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
                V_nominal=60) "Load model"
              annotation (Placement(transformation(extent={{24,0},{44,20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              duration=0.5,
              startTime=0.3,
              height=2000,
              offset=-1000) "Power consumed by the model"
              annotation (Placement(transformation(extent={{80,0},{60,20}})));
          equation
            connect(sou.terminal, conACAC.terminal_n) annotation (Line(
                points={{-50,10},{-10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(conACAC.terminal_p, load.terminal)     annotation (Line(
                points={{10,10},{24,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow) annotation (Line(
                points={{59,10},{44,10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of a model that converts AC voltage to AC voltage.
The transformer model assumes a linear loss when transmitting the power.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Conversion/Examples/ACACConverter.mos"
                  "Simulate and plot"));
          end ACACConverter;

          model ACACTransformer
            "This example illustrates how to use the AC/AC simplified transformer model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer tra_load(
              Zperc=0.03,
              VABase=4000,
              XoverR=8,
              VHigh=120,
              VLow=60) "Transformer with load"
              annotation (Placement(transformation(extent={{-18,40},{2,60}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,50})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive load(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              pf=0.8,
              V_nominal=60) "Load model"
              annotation (Placement(transformation(extent={{10,40},{30,60}})));
            Modelica.Blocks.Sources.Ramp ramp(
              duration=0.5,
              startTime=0.3,
              offset=0,
              height=-4000*0.8) "Load power consumption profile"
              annotation (Placement(transformation(extent={{70,40},{50,60}})));
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer tra_cc(
              XoverR=8,
              Zperc=0.03,
              VABase=4000,
              VHigh=120,
              VLow=60) "Transformer with short circuit"
              annotation (Placement(transformation(extent={{-16,0},{4,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance shortCircuit(R=1e-8)
              "Short circuit"
              annotation (Placement(transformation(extent={{10,0},{30,20}})));
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer tra_void(
              XoverR=8,
              Zperc=0.03,
              VABase=4000,
              VHigh=120,
              VLow=60) "Transformer with secondary not connected" annotation (
                Placement(transformation(extent={{-16,-30},{4,-10}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou1(
              definiteReference=true,
              f=60,
              V=120) "Voltage source for open and short circuit tests"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    origin={-70,10})));
          equation
            connect(sou.terminal, tra_load.terminal_n)
                                                      annotation (Line(
                points={{-60,50},{-18,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(tra_load.terminal_p, load.terminal)    annotation (Line(
                points={{2,50},{10,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow) annotation (Line(
                points={{49,50},{30,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(tra_cc.terminal_p, shortCircuit.terminal) annotation (Line(
                points={{4,10},{10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_cc.terminal_n) annotation (Line(
                points={{-60,10},{-16,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_void.terminal_n) annotation (Line(
                points={{-60,10},{-38,10},{-38,-20},{-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of a the AC/AC transformer model.
The example shows three different configurations:
</p>
<ul>
<li>With a load connected,</li>
<li>without a load connected, and</li>
<li>with a short circuit connection.</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Conversion/Examples/ACACTransformer.mos"
                  "Simulate and plot"));
          end ACACTransformer;

          model ACACTransformerFull
            "This example illustrates how to use the AC/AC transformer model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull tra_load(
              R1=0.0001,
              L1=0.0001,
              R2=0.0001,
              L2=0.0001,
              VABase=4000,
              magEffects=true,
              Rm=10,
              Lm=10,
              VHigh=120,
              VLow=60,
              f=60) "Transformer with load"
              annotation (Placement(transformation(extent={{-18,40},{2,60}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,50})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive load(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              pf=0.8,
              V_nominal=60) "Load model"
              annotation (Placement(transformation(extent={{10,40},{30,60}})));
            Modelica.Blocks.Sources.Ramp ramp(
              duration=0.5,
              startTime=0.3,
              offset=0,
              height=-4000*0.8) "Load power consumption profile"
              annotation (Placement(transformation(extent={{70,40},{50,60}})));
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull tra_cc(
              VABase=4000,
              R1=0.01,
              L1=0.01,
              R2=0.01,
              L2=0.01,
              magEffects=false,
              Rm=100,
              Lm=100,
              VHigh=120,
              VLow=60,
              f=60) "Transformer with short circuit connection"
              annotation (Placement(transformation(extent={{-16,0},{4,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance shortCircuit(R=1e-8)
              "Short circuit"
              annotation (Placement(transformation(extent={{10,0},{30,20}})));
            ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull tra_void(
              VABase=4000,
              R1=0.01,
              L1=0.01,
              R2=0.01,
              L2=0.01,
              magEffects=false,
              Rm=100,
              Lm=100,
              VHigh=120,
              VLow=60,
              f=60) "Transformer with open connection" annotation (Placement(
                  transformation(extent={{-16,-30},{4,-10}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou1(
              definiteReference=true,
              f=60,
              V=120) "Voltage source for short circuit and open tests "
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    origin={-70,10})));
          equation
            connect(sou.terminal, tra_load.terminal_n)
                                                      annotation (Line(
                points={{-60,50},{-18,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(tra_load.terminal_p, load.terminal)    annotation (Line(
                points={{2,50},{10,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow) annotation (Line(
                points={{49,50},{30,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(tra_cc.terminal_p, shortCircuit.terminal) annotation (Line(
                points={{4,10},{10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_cc.terminal_n) annotation (Line(
                points={{-60,10},{-16,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_void.terminal_n) annotation (Line(
                points={{-60,10},{-38,10},{-38,-20},{-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of the AC/AC transformer model
that includes losses at the primary and secondary side and magnetization
effects.
The example shows three different configurations:
</p>
<ul>
<li>With a load connected,</li>
<li>without a load connected, and</li>
<li>with a short circuit connection.</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Conversion/Examples/ACACTransformerFull.mos"
                  "Simulate and plot"));
          end ACACTransformerFull;

          model ACDCConverter
            "This example illustrates how to use the AC/DC converter model"
            extends Modelica.Icons.Example;

            ProsNet.Electrical.DC.Loads.Resistor res(R=1, V_nominal=60)
              "Resistive load" annotation (Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={50,10})));
            ProsNet.Electrical.AC.OnePhase.Conversion.ACDCConverter conversion(
              eta=0.9,
              ground_AC=false,
              ground_DC=true,
              conversionFactor=60/120) "AC/DC transformer"
              annotation (Placement(transformation(extent={{-10,0},{10,20}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-62,10})));
            ProsNet.Electrical.DC.Loads.Conductor load(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
                V_nominal=60) "Variable resistive load" annotation (Placement(
                  transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={50,-10})));
            Modelica.Blocks.Sources.Ramp pow(
              duration=0.5,
              startTime=0.2,
              offset=-200,
              height=5200) "Variable load profile"
              annotation (Placement(transformation(extent={{90,-20},{70,0}})));
          equation
            connect(sou.terminal, conversion.terminal_n) annotation (Line(
                points={{-52,10},{-10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(conversion.terminal_p, res.terminal) annotation (Line(
                points={{10,10},{40,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(conversion.terminal_p, load.terminal) annotation (Line(
                points={{10,10},{30,10},{30,-10},{40,-10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(pow.y, load.Pow) annotation (Line(
                points={{69,-10},{60,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of a model that converts AC voltage to DC voltage.
The transformer model assumes a linear loss when transmitting the power.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Conversion/Examples/ACDCConverter.mos"
                  "Simulate and plot"));
          end ACDCConverter;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion\">
Buildings.Electrical.AC.OnePhase.Conversion</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for AC/AC and AC/DC conversion.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Conversion;

      package Lines "Package with models for AC electrical lines"
        extends Modelica.Icons.Package;

        model Line "Model of an electrical line"
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialLine(
            V_nominal(start=110),
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n,
            redeclare replaceable Interfaces.Terminal_p terminal_p,
            commercialCable=
                ProsNet.Electrical.Transmission.Functions.selectCable_low(
                P_nominal, V_nominal));
        protected
          replaceable TwoPortRL line(
            R=R/3,
            L=L/3,
            mode=modelMode) constrainedby
            ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortRLC(
              useHeatPort=true,
              M=M,
              T_ref=T_ref) "Model of the line"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

        equation
          connect(cableTemp.port, line.heatPort)       annotation (Line(
              points={{-40,22},{-28,22},{-28,-10},{4.44089e-16,-10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(line.terminal_n, terminal_n)       annotation (Line(
              points={{-10,4.44089e-16},{-48,4.44089e-16},{-48,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_p, line.terminal_p)       annotation (Line(
              points={{100,0},{56,0},{56,4.44089e-16},{10,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));

          annotation (
        defaultComponentName="line",
         Icon(graphics={
                Ellipse(
                  extent={{-70,10},{-50,-10}},
                  lineColor={0,0,0},
                  fillColor={0,94,94},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,10},{60,-10}},
                  fillColor={0,94,94},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{50,10},{70,-10}},
                  lineColor={0,0,0},
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-70,0},{-90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,10},{60,10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,-10},{60,-10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{96,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(
        info="<html>
<p>
This model represents an AC single phase cable. The model is based on
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines.TwoPortRLC\">
Buildings.Electrical.AC.OnePhase.Lines.TwoPortRLC</a>
and provides functionalities to parametrize the values of <i>R</i>, <i>L</i> and <i>C</i>,
either using commercial cables or using default values.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Added <code>replaceable</code> to terminal redeclaration as they are redeclared by
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Lines.Line\">
Buildings.Electrical.AC.ThreePhasesBalanced.Lines.Line</a>.
</li>
<li>
November 8, 2016, by Michael Wetter:<br/>
Corrected wrong assignment of parameter <code>mode</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/571\">#571</a>.
</li>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Moved here the default declaration of the parameter <code>commercialCable</code>.<br/>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">
<span style=\" font-family:'Courier New,courier';\">commercialCable = </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\"> Buildings.Electrical.Transmission.Functions.selectCable_low</span>
<span style=\" font-family:'Courier New,courier';\">(P_nominal, V_nominal)</span>
</p>
</li>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Line;

        model Network "Single phase AC network"
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialNetwork(
            V_nominal(start=110),
            redeclare Interfaces.Terminal_p terminal,
            redeclare replaceable Transmission.Grids.TestGrid2Nodes grid,
            redeclare Line lines(
              commercialCable=grid.cables,
              each use_C=use_C,
              each modelMode=modelMode));
          parameter Boolean use_C = false "If true, model the cable capacity"
            annotation(Dialog(tab="Model", group="Assumptions"));
          parameter ProsNet.Electrical.Types.Load modelMode=Types.Load.FixedZ_steady_state
            "Select between steady state and dynamic model" annotation (Dialog(
              tab="Model",
              group="Assumptions",
              enable=use_C), choices(choice=Buildings.Electrical.Types.Load.FixedZ_steady_state
                "Steady state", choice=Buildings.Electrical.Types.Load.FixedZ_dynamic
                "Dynamic"));
          Modelica.Units.SI.Voltage VAbs[grid.nNodes] "RMS voltage of the grid nodes";
        equation
          for i in 1:grid.nLinks loop
            connect(lines[i].terminal_p, terminal[grid.fromTo[i,1]]);
            connect(lines[i].terminal_n, terminal[grid.fromTo[i,2]]);
          end for;

          for i in 1:grid.nNodes loop
            VAbs[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].v);
          end for;

          annotation (
            defaultComponentName="net",
        Icon(graphics={             Line(
                  points={{-92,-60},{-72,-20},{-52,-60},{-32,-100},{-12,-60}},
                  color={0,0,0},
                  smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This model represents a generalized electrical AC single phase network.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialNetwork\">
Buildings.Electrical.Transmission.BaseClasses.PartialNetwork</a>
for information about the network model.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.Grids.PartialGrid\">
Buildings.Electrical.Transmission.Grids.PartialGrid</a>
for more information about the topology of the network, such as
the number of nodes, how they are connected, and the length of each connection.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Network;

        model TwoPortInductance
          "Model of an inductive element with two electrical ports"
          extends
            ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortInductance(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n,
            redeclare replaceable Interfaces.Terminal_p terminal_p);
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.VariableZ_y_input)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
        protected
          Modelica.Units.SI.AngularVelocity omega
            "Frequency of the quasi-stationary sine waves";
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";

        equation
          theRef = PhaseSystem_p.thetaRef(terminal_p.theta);
          omega = der(theRef);

          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
            // Dynamics of the system
            der(L*terminal_p.i) + L*omega*PhaseSystem_p.j(terminal_p.i) = terminal_p.v - terminal_n.v;

          else
            // Steady state relationship
            L*omega*PhaseSystem_p.j(terminal_p.i) = terminal_p.v - terminal_n.v;

          end if;

          annotation (
            defaultComponentName="lineL",
          Diagram(graphics={
                  Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,0}),
                  Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                  Line(points={{70,0},{90,0}}, color={0,0,0})}),     Icon(
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                  Text(
                    extent={{-140,80},{140,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This model represents an inductance that connects two AC one phase interfaces.
This model can be used to represent a single phase cable in a AC grid.
</p>
<p>
The model represents the lumped inductance as shown in the figure below.
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Lines/twoPortL.png\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
        end TwoPortInductance;

        model TwoPortRL
          "Model of a resistive-inductive element with two electrical ports"
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortRLC(
            final V_nominal=0,
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n,
            redeclare replaceable Interfaces.Terminal_p terminal_p,
            final C=0);
          parameter Modelica.Units.SI.Current i_start[PhaseSystem_p.n]=zeros(
              PhaseSystem_p.n)
            "Initial current phasor of the line (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.FixedZ_dynamic)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
        protected
          Modelica.Units.SI.Current i_p[2](start=i_start, each stateSelect=StateSelect.prefer)
            "Current phasor at terminal p";
          Modelica.Units.SI.AngularVelocity omega
            "Frequency of the quasi-stationary sine waves";
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";

        initial equation
          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
            i_p = i_start;
          end if;
        equation
          theRef = PhaseSystem_p.thetaRef(terminal_p.theta);
          omega = der(theRef);

          terminal_p.i = - terminal_n.i;
          i_p = terminal_p.i;

          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
            // Dynamics of the system
            der(L*i_p) + L*omega*PhaseSystem_p.j(i_p) +
              i_p*diagonal(ones(PhaseSystem_p.n)*R_actual)
               = terminal_p.v - terminal_n.v;

          else
            // steady state relationship
            L*omega*PhaseSystem_p.j(i_p) +
              i_p*diagonal(ones(PhaseSystem_p.n)*R_actual)
              = terminal_p.v - terminal_n.v;
          end if;

          // Joule losses
          LossPower = R_actual*(i_p[1]^2 + i_p[2]^2);

          annotation (
        defaultComponentName="lineRL",
        Diagram(graphics={
                  Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,0}),
                  Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                  Line(points={{70,0},{90,0}}, color={0,0,0})}),     Icon(
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                          graphics={
                  Text(
                    extent={{-140,80},{140,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This model represents a resistance and an inductance connected in series with
two AC one phase interfaces. This model can be used
to represent a single phase cable in a AC grid.
</p>
<p>
The model represents the lumped RL cable as shown in the figure below.
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Lines/twoPortRL.png\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>
March 9, 2015, by Marco Bonvini:<br/>
Added parameter for start value of the current.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
        end TwoPortRL;

        model TwoPortRLC "Model of an RLC element with two electrical ports"
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortRLC(
            V_nominal(start=110),
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n(redeclare
                package PhaseSystem = PhaseSystem_n),
            redeclare replaceable Interfaces.Terminal_p terminal_p(redeclare
                package PhaseSystem = PhaseSystem_p));
          parameter Modelica.Units.SI.Voltage Vc_start[2]={V_nominal,0}
            "Initial voltage phasor of the capacitance located in the middle of the line"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.FixedZ_dynamic)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
        protected
          Modelica.Units.SI.Voltage Vc[2](start=Vc_start, each stateSelect=StateSelect.prefer)
            "Voltage of the Capacitance located in the middle of the line";
          Modelica.Units.SI.Current Ic[2]
            "Currenbt of the capacitance located in the middle of the line";
          Modelica.Units.SI.AngularVelocity omega
            "Frequency of the quasi-stationary sine waves";
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";

        initial equation
          if C > 0 and mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
            Vc = Vc_start;
          end if;
        equation
          theRef = PhaseSystem_p.thetaRef(terminal_p.theta);
          omega = der(theRef);

          terminal_p.i + terminal_n.i = Ic;

          L/2*omega*ProsNet.Electrical.PhaseSystems.OnePhase.j(terminal_p.i) +
            terminal_p.i*diagonal(ones(PhaseSystem_p.n)*R_actual/2) =
            terminal_p.v - Vc;
          L/2*omega*ProsNet.Electrical.PhaseSystems.OnePhase.j(terminal_n.i) +
            terminal_n.i*diagonal(ones(PhaseSystem_n.n)*R_actual/2) =
            terminal_n.v - Vc;

          if C > 0 then
            if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
              // Dynamics of the system
              C*der(Vc) + omega*C*ProsNet.Electrical.PhaseSystems.OnePhase.j(Vc)
                = Ic;
            else
              // steady state relationship
              omega*C*ProsNet.Electrical.PhaseSystems.OnePhase.j(Vc) = Ic;
            end if;
          else
            // No capacitive effect, the voltage in the middle of the line is the linear
            // interpolation of the two phasors
            Vc = (terminal_p.v + terminal_n.v)/2;
          end if;

          // Joule losses
          LossPower = R_actual/2*(terminal_p.i[1]^2 + terminal_p.i[2]^2) +
                      R_actual/2*(terminal_n.i[1]^2 + terminal_n.i[2]^2);

          annotation (
          defaultComponentName="lineRLC",
        Diagram(graphics={
                  Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,0}),
                  Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                  Line(points={{70,0},{90,0}}, color={0,0,0})}),     Icon(
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                          graphics={
                  Text(
                    extent={{-140,80},{140,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
This model represents a series of two resistive-inductive impedances and a capacitance
that connects two AC single phase interfaces.
This model can be used to represent a cable in a AC grid.
</p>
<p>
The model represents the lumped resistances and capacity, as a T-model, as shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Lines/twoPortRLC.png\"/>
</p>
<p>
As can be seen in the figure, the resistance <i>R</i> and the inductance <i>L</i> are split in two halves
and the capacitance is located in the center.
The capacitance in the center is optional. If it is not present, set the
parameter <code>C=0</code>.
The model is either dynamic or static depending on the
presence of the capacitive effect.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Added <code>replaceable</code> to terminal redeclaration as they are redeclared by
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortRLC\">
Buildings.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortRLC</a>.
</li>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>
March 9, 2015, by Marco Bonvini:<br/>
Added parameter for start value of the voltage.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
        end TwoPortRLC;

        model TwoPortResistance "Model of a resistance with two electrical ports"
          extends
            ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortResistance(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal_n,
            redeclare replaceable Interfaces.Terminal_p terminal_p);
        equation
          terminal_p.v - terminal_n.v = terminal_p.i*diagonal(ones(PhaseSystem_p.n)*R_actual);

          // Joule losses
          LossPower = R_actual*(terminal_p.i[1]^2 + terminal_p.i[2]^2);
          annotation (
            defaultComponentName="lineR",
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                              graphics={
                  Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,0}),
                  Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                  Line(points={{70,0},{90,0}}, color={0,0,0})}),     Icon(
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                          graphics={
                  Text(
                    extent={{-140,80},{140,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(
        info="<html>
<p>
This model represents a resistance that connects two AC one phase interfaces.
This model can be used to represent a single phase cable in a AC grid.
</p>
<p>
The model represents the lumped resistance as shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Lines/twoPortR.png\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
        end TwoPortResistance;

        package Examples "Package with example models"
        extends Modelica.Icons.ExamplesPackage;

          model ACLine
            "Test model for a single phase line that uses commercial cable information"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(      definiteReference=true,
              f=60,
              V=120) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            Line line_1(
              P_nominal=5000,
              l=2000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              V_nominal=120) "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Line line_2a(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=1000,
              V_nominal=120) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Loads.Impedance R2(
              R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Line line_2b(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=1000,
              V_nominal=120) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-32,-30},{-12,-10}})));
            Line line_3a(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=4000,
              V_nominal=120) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            Line line_3b(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=4000,
              V_nominal=120) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-70},{-40,-50}})));
            Loads.Impedance R3(
              R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
            Line line_sc(
              P_nominal=5000,
              l=2000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              V_nominal=120) "Line that connects the source and the short circuit"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Loads.Impedance load_sc(R=0) "Short circuit"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
          equation
            connect(line_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,0},{-24,0},{-24,6.66134e-16},{-4.44089e-16,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_1.terminal_n) annotation (Line(
                points={{-80,4.44089e-16},{-60,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_2a.terminal_n) annotation (Line(
                points={{-80,4.44089e-16},{-70,4.44089e-16},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2a.terminal_p, line_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-32,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-12,-20},{0,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-40},{-20,-40},{-20,-50},{0,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-60},{-20,-60},{-20,-50},{-5.55112e-16,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-40},{-60,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-60},{-60,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_sc.terminal_p, load_sc.terminal) annotation (Line(
                points={{-40,30},{-4.44089e-16,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Lines/Examples/ACLine.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a line model to connect
a source to a load that uses commercial cable information.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the impedance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations,
however the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>
</html>"));
          end ACLine;

          model ACLine_L "Test model for a single phase inductive line"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Inductance Lbase=10/2/Modelica.Constants.pi/60
              "Base value for the line inductances";
            Sources.FixedVoltage E(      definiteReference=true,
              f=60,
              V=120) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance R2(
              R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance R3(
              R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-62},{20,-42}})));
            Loads.Impedance load_sc(R=0) "Short circuit"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            TwoPortInductance Lline_sc(L=Lbase)
              "Inductive line connected to the short circuit"
              annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
            TwoPortInductance Lline_1(L=Lbase) "Inductive line connected to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            TwoPortInductance Lline_2a(L=0.5*Lbase) "Inductive line connected to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            TwoPortInductance Lline_2b(L=0.5*Lbase) "Inductive line connected to load 2"
              annotation (Placement(transformation(extent={{-36,-30},{-16,-10}})));
            TwoPortInductance Lline_3(L=2*Lbase) "Inductive line connected to load 3"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            TwoPortInductance Lline_3b(L=2*Lbase) "Inductive line connected to load 3"
              annotation (Placement(transformation(extent={{-60,-70},{-40,-50}})));
          equation
            connect(E.terminal, Lline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_sc.terminal_p, load_sc.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_2a.terminal_p, Lline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-36,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-16,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_3.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-40},{-60,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-60},{-60,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_3.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-40},{-20,-40},{-20,-52},{0,-52}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-60},{-20,-60},{-20,-52},{0,-52}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Lines/Examples/ACLine_L.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a purely inductive line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the inductance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations,
however the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draw the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>"));
          end ACLine_L;

          model ACLine_R "Test model for a single phase resistive line"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(definiteReference=true,
              f=60,
              V=120) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance R2(
              R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance R3(
              R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance sc_load(R=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            TwoPortResistance Rline_sc(R=10, useHeatPort=false)
              "Resistive line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            TwoPortResistance Rline_1(R=10) "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            TwoPortResistance Rline_2a(R=5) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            TwoPortResistance Rline_2b(R=5) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-36,-30},{-16,-10}})));
            TwoPortResistance Rline_3a(R=20) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            TwoPortResistance Rline_3b(R=20) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(E.terminal, Rline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-36,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-16,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Lines/Examples/ACLine_R.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a resistive line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the resistance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations,
however the equivalent resistance between each load and the source is the same.
Since the equivalent resistances are the same, each load draw the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>"));
          end ACLine_R;

          model ACLine_RL "Test model for a single phase inductive-resistive line"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Resistance Rbase=10
              "Base value for the line resistance";
            parameter Modelica.Units.SI.Inductance Lbase=Rbase/2/Modelica.Constants.pi/60
              "Base value for the line inductance";
            Sources.FixedVoltage E(      definiteReference=true,
              f=60,
              V=120) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance load_sc_1(R=0) "Short circuit 1"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Loads.Impedance load_sc_2(R=0) "Short circuit 2"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            TwoPortRL RL_2(R=Rbase, L=Lbase)
              "Resistive-Inductive line connected to short circuit 2"
              annotation (Placement(transformation(extent={{-48,-10},{-28,10}})));
            TwoPortResistance R_1(R=Rbase) "Resistance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            TwoPortInductance L_1(L=Lbase) "Inductance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-30,20},{-10,40}})));
            TwoPortRL RL_3(
              R=Rbase,
              L=Lbase,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic,
              i_start={0,0})
              "Dynamic resistive-inductive line connected to short circuit 3"
              annotation (Placement(transformation(extent={{-48,-40},{-28,-20}})));
            Loads.Impedance load_sc_3(R=0) "Short circuit 3"
              annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          equation
            connect(E.terminal, R_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(R_1.terminal_p, L_1.terminal_n) annotation (Line(
                points={{-40,30},{-30,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(L_1.terminal_p, load_sc_1.terminal) annotation (Line(
                points={{-10,30},{0,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_2.terminal_n) annotation (Line(
                points={{-80,0},{-48,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RL_2.terminal_p, load_sc_2.terminal) annotation (Line(
                points={{-28,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_3.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-30},{-48,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RL_3.terminal_p, load_sc_3.terminal) annotation (Line(
                points={{-28,-30},{0,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Lines/Examples/ACLine_RL.mos"
                  "Simulate and plot"),
            Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a resistive-inductive line model to connect
a source to a load.
</p>
<p>
The model has three loads <code>load_sc_1</code>, <code>load_sc_2</code>,
and <code>load_sc_3</code> representing short circuits <i>R=0</i>.
The current that flows through the load depends on the impedance of the line.
</p>
<p>
Each load is connected to the source with different configurations,
however the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draw the same current.
</p>
<p>
<b>Note:</b>
The line model <code>RL_3</code> is the same as <code>RL_2</code> but it uses
dynamic phasors.
</p>
</html>"));
          end ACLine_RL;

          model ACSimpleGrid "Test model for a network model"
            extends Modelica.Icons.Example;
            Network network(
              redeclare ProsNet.Electrical.Transmission.Grids.TestGrid2Nodes   grid,
              V_nominal=120)
              "Network model that represents the connection between the source and the load"
              annotation (Placement(transformation(extent={{20,-10},{0,10}})));
            Loads.Inductive load(
              mode=Types.Load.VariableZ_P_input,
              V_nominal=120) "Load connected to the network"
              annotation (Placement(transformation(extent={{-28,10},{-48,30}})));
            Sources.FixedVoltage E(f=60, V=120) "Voltage source"
                                                    annotation (Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={-70,0})));
            Modelica.Blocks.Sources.Ramp load_inputs(
              height=5000,
              duration=2,
              offset=-2000,
              startTime=0.5) "Input signal for the power consumption of the loads"
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          equation
            connect(load.terminal, network.terminal[2]) annotation (Line(
                points={{-28,20},{-20,20},{-20,4.44089e-16},{-4.44089e-16,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, network.terminal[1]) annotation (Line(
                points={{-60,-8.88178e-16},{-56,-8.88178e-16},{-56,4.44089e-16},{-4.44089e-16,
                    4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow) annotation (Line(
                points={{-59,30},{-54,30},{-54,20},{-48,20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
          __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Lines/Examples/ACSimpleGrid.mos"
                  "Simulate and plot"),
          Documentation(revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a network model to connect
a source to a load. In this simple case the network has two nodes
that are connected by a commercial line cable.
</p>
<p>
At the beginning of the simulation the load consumes power while at the
and it produces power. The voltage at the load at the beginning is lower
than the nominal RMS voltage (120 V) while at the end of the simulation it is higher.
The voltage drop and increase are due to the presence of the cable between
the source and the load.
</p>
<p>
The network uses cables of the type <code>LowVoltageCable.Cu35</code> with
a length of <i>200</i> m.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
</html>"));
          end ACSimpleGrid;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines\">
Buildings.Electrical.AC.OnePhase.Lines</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Icon(graphics={
            Ellipse(
              extent={{40,8},{16,-28}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{28,8},{-54,8},{-64,8},{-72,-10},{-64,-28},{-52,-28},{28,-28}},
              color={0,0,0},
              smooth=Smooth.Bezier),
            Line(
              points={{-70,-10},{-88,-10}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{54,-10},{28,-10}},
              color={0,0,0},
              smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package contains models for transmission lines and electrical networks.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Lines;

      package Loads "Package with load models for one phase AC systems"
        extends Modelica.Icons.VariantsPackage;

        model Capacitive "Model of a capacitive and resistive load"
          extends ProsNet.Electrical.Interfaces.CapacitiveLoad(
            redeclare package PhaseSystem = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal,
            V_nominal(start=110));

        protected
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";

        initial equation
          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
            // q = Y[2]*{V_nominal, 0}/omega;
            // Steady state initialization
            der(q) = zeros(PhaseSystem.n);
          end if;
        equation
          theRef = PhaseSystem.thetaRef(terminal.theta);
          omega = der(theRef);

          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then

            // Use the dynamic phasorial representation
            Y[1] = -(P_nominal/pf)*pf/V_nominal^2;
            Y[2] = -(P_nominal/pf)*Modelica.Fluid.Utilities.regRoot(1 - pf^2, delta=0.001)/V_nominal^2;

            // Electric charge
            q = Y[2]*{v[1], v[2]}/omega;

            // Dynamics of the system
            der(q) + omega*j(q) + Y[1]*v = i;

          else

            // Use the power specified by the parameter or inputs
            if linearized then
              i[1] = -homotopy(actual= (v[2]*Q + v[1]*P)/(V_nominal^2), simplified= v[1]*Modelica.Constants.eps*1e3);
              i[2] = -homotopy(actual= (v[2]*P - v[1]*Q)/(V_nominal^2), simplified= v[2]*Modelica.Constants.eps*1e3);
            else
              if initMode == ProsNet.Electrical.Types.InitMode.zero_current then
                i[1] = -homotopy(actual=(v[2]*Q + v[1]*P)/(v[1]^2 + v[2]^2), simplified=0.0);
                i[2] = -homotopy(actual=(v[2]*P - v[1]*Q)/(v[1]^2 + v[2]^2), simplified=0.0);
              else
                i[1] = -homotopy(actual=(v[2]*Q + v[1]*P)/(v[1]^2 + v[2]^2), simplified=(v[2]*Q + v[1]*P)/(V_nominal^2));
                i[2] = -homotopy(actual=(v[2]*P - v[1]*Q)/(v[1]^2 + v[2]^2), simplified=(v[2]*P - v[1]*Q)/(V_nominal^2));
              end if;

            end if;

            Y = {0, 0};
            q = {0, 0};

          end if;

          annotation (
            defaultComponentName="loa",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),      graphics={
                Rectangle(
                  extent={{-80,40},{80,-40}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,28},{0,-28}},
                  color={0,0,0},
                  origin={48,0},
                  rotation=180),
                Line(
                  points={{0,28},{0,-28}},
                  color={0,0,0},
                  origin={40,0},
                  rotation=180),
                  Line(points={{-42,-5.14335e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-2,0},
                  rotation=180),
                  Line(points={{-26,-3.18398e-15},{0,0}},
                                                 color={0,0,0},
                  origin={48,0},
                  rotation=180),
                  Line(points={{-10,-1.22461e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-42,1},
                  rotation=90),
                Text(
                  extent={{-120,80},{120,40}},
                  textColor={0,0,0},
                  textString="%name")}), Documentation(info="<html>

<p>
Model of an capacitive load. It may be used to model a bank of capacitors.
</p>
<p>
The model computes the complex power vector as
<p align=\"center\" style=\"font-style:italic;\">
S = P + jQ = V &sdot; i<sup>*</sup>
</p>
<p>
where <i>V</i> is the voltage phasor and <i>i<sup>*</sup></i> is the complex
conjugate of the current phasor. The voltage and current phasors are shifted
by an angle <i>&phi;</i>.
</p>

<p>
The load model takes as input the power consumed by the inductive load and
the power factor <i>pf=cos(&phi;)</i>. The power
can be either fixed using the parameter <code>P_nominal</code>, or
it is possible to specify a variable power using the inputs <code>y</code> or
<code>Pow</code>.

The power factor can be either specified by the parameter <code>pf</code>
or using the input variable <code>pf_in</code>.

The different modes can be selected with the parameter
<code>mode</code> and <code>use_pf_in</code>, see <a href=\"modelica://Buildings.Electrical.Interfaces.Load\">
Buildings.Electrical.Interfaces.Load</a> and
<a href=\"modelica://Buildings.Electrical.Interfaces.CapacitiveLoad\">
Buildings.Electrical.Interfaces.CapacitiveLoad</a> for more information.
</p>

<p>
Given the active power <i>P</i> and the power factor <i>pf</i> the complex
power <i>Q</i> is computed as
</p>

<p align=\"center\" style=\"font-style:italic;\">
Q = - P  tan(arccos(pf)).
</p>

<p>
The equations of the model can be rewritten as
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = (P V<sub>1</sub> + Q V<sub>2</sub>)/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>),
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = (P V<sub>2</sub> - Q V<sub>1</sub>)/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>),
</p>

<p>
where <i>i<sub>1</sub></i>, <i>i<sub>2</sub></i>, <i>V<sub>1</sub></i>, and <i>V<sub>2</sub></i>
are the real and imaginary parts of the current and voltage phasors.
</p>
<p>
The nonlinearity of the model is due to the fact that the load consumes the power specified by the variables <i>P</i>
and <i>Q</i> irrespectively of the voltage of the load.
</p>
<p>
When multiple loads are connected in a grid through cables that cause voltage drops,
the dimension of the system of nonlinear equations increases linearly with the number of loads.
This nonlinear system of equations introduces challenges during the initialization,
as Newton solvers may diverge if initialized far from a solution, as well during the simulation.
In this situation, the model can be parameterized to use a linear approximation
as discussed in the next section.
</p>

<h4>Linearized model</h4>
<p>
Given the constraints and the two-dimensional nature of the problem, it is difficult to
find a linearized version of the AC load model. A solution could be to divide the voltage
domain into sectors, and for each sector compute the best linear approximation.
However the selection of the proper approximation depending on the value of the
voltage can generate events that increase the simulation time. For these reasons, the
linearized model assumes a voltage that is equal to the nominal value
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = (P V<sub>1</sub> + Q V<sub>2</sub>)/V<sub>RMS</sub><sup>2</sup>,
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = (P V<sub>2</sub> - Q V<sub>1</sub>)/V<sub>RMS</sub><sup>2</sup>,
</p>
<p>
where <i>V<sub>RMS</sub></i> is the Root Mean Square voltage os the AC system.
Even though this linearized version of the load model introduces an approximation
error in the current, it satisfies the constraints related to the ratio of the
active and reactive powers.
</p>

<h4>Initialization</h4>
<p>
The initialization problem can be simplified using the homotopy operator. The homotopy operator
uses two different types of equations to compute the value of a variable: the actual one
and a simplified one. The actual equation is the one used during the normal operation.
During initialization, the simplified equation is first solved and then slowly replaced
with the actual equation to compute the initial values for the nonlinear systems of
equations. The load model uses the homotopy operator, with the linearized model being used
as the simplified equation. This numerical expedient has proven useful when simulating models
with more than ten connected loads.
</p>
<p>
The load model has a parameter <code>initMode</code> that can be used to select
the assumption to use during the initialization phase by the homotopy operator.
The choices are between a null current or the linearized model.
</p>


</html>",     revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>September 4, 2014, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Capacitive;

        model Impedance "Model of a generic impedance"
          extends ProsNet.Electrical.Interfaces.Impedance(redeclare
              replaceable package PhaseSystem = PhaseSystems.OnePhase,
              redeclare replaceable Interfaces.Terminal_n terminal);

        protected
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";
          Modelica.Units.SI.AngularVelocity omega
            "Frequency of the quasi-stationary sine waves";
          Modelica.Units.SI.Reactance X(start=1) "Complex component of the impedance";
        equation
          theRef = PhaseSystem.thetaRef(terminal.theta);
          omega = der(theRef);

          if inductive then
            X = omega*L_internal;
          else
            X = -1/(omega*C_internal);
          end if;

          terminal.v = {{R_internal,-X}*terminal.i, {X,R_internal}*terminal.i};
          annotation (
            defaultComponentName="imp",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,40},{80,-40}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={0,3.55271e-15},
                  rotation=180),
                  Line(points={{0,0},{12,0}},  color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,-40},{120,-80}},
                  textColor={0,0,0},
                  textString="%name")}),
                  Documentation(info="<html>
<p>
Model of an impedance. This model can be used to represent any type
of resistive, inductive or capacitive load.
</p>
<p>
Note that the power consumed by the impedance model will drecrease if its voltage
decreases.
</p>
<p>
The model of the impedance is
</p>

<p align=\"center\" style=\"font-style:italic;\">
V = Z i,
</p>

<p>
where <i>Z = R + j X</i> is the impedance. The value of the resistance <i>R</i> and the
reactance <i>X</i> depend on the type of impedance. Different types of impedances
can be selected using the boolean parameters <code>inductive</code>, <code>use_R_in</code>,
<code>use_L_in</code>, and <code>use_C_in</code>. See
<a href=\"modelica://Buildings.Electrical.Interfaces.Impedance\">
Buildings.Electrical.Interfaces.Impedance</a> for more details.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>
March 30, 2015, by Michael Wetter:<br/>
Made <code>PhaseSystem</code> and <code>terminal</code> replaceable. This was detected
by the OpenModelica regression tests.
</li>
<li>September 4, 2014, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Impedance;

        model Inductive "Model of an inductive and resistive load"
          extends ProsNet.Electrical.Interfaces.InductiveLoad(
            redeclare package PhaseSystem = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal,
            V_nominal(start=110));

        protected
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";

        initial equation
          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then
            // psi = Z[2]*{P_nominal/V_nominal, 0}/omega;
            // Steady state initialization
            der(psi) = zeros(PhaseSystem.n);
          end if;
        equation
          theRef = PhaseSystem.thetaRef(terminal.theta);
          omega = der(theRef);

          if mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic then

            // Use the dynamic phasorial representation
            Z[1] = -pf*(V_nominal^2)/(P_nominal/pf);
            Z[2] = -Modelica.Fluid.Utilities.regRoot(1-pf^2, delta=0.001)*(V_nominal^2)/(P_nominal/pf);

            // Dynamics of the system
            der(psi) + omega*j(psi) + Z[1]*i = v;

            // Magnetic flux
            psi = Z[2]*{i[1], i[2]}/omega;

          else

            // Use the power specified by the parameter or inputs
            if linearized then
              i[1] = -homotopy(actual= (v[2]*Q + v[1]*P)/(V_nominal^2), simplified= v[1]*Modelica.Constants.eps*1e3);
              i[2] = -homotopy(actual= (v[2]*P - v[1]*Q)/(V_nominal^2), simplified= v[2]*Modelica.Constants.eps*1e3);
            else
              //PhaseSystem.phasePowers_vi(terminal.v, terminal.i) = PhaseSystem.phasePowers(P, Q);
              if initMode == ProsNet.Electrical.Types.InitMode.zero_current then
                i[1] = -homotopy(actual = (v[2]*Q + v[1]*P)/(v[1]^2 + v[2]^2), simplified= 0.0);
                i[2] = -homotopy(actual = (v[2]*P - v[1]*Q)/(v[1]^2 + v[2]^2), simplified= 0.0);
              else
                i[1] = -homotopy(actual = (v[2]*Q + v[1]*P)/(v[1]^2 + v[2]^2), simplified= (v[2]*Q + v[1]*P)/(V_nominal^2));
                i[2] = -homotopy(actual = (v[2]*P - v[1]*Q)/(v[1]^2 + v[2]^2), simplified= (v[2]*P - v[1]*Q)/(V_nominal^2));
              end if;
            end if;

            Z = {0,0};
            psi = {0,0};

          end if;
          annotation (
            defaultComponentName="loa",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-80,40},{80,-40}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                           Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={10,0},
                  rotation=360),
                Ellipse(extent={{40,-10},{60,10}}),
                Ellipse(extent={{20,-10},{40,10}}),
                Rectangle(
                  extent={{0,0},{60,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,0}},    color={0,0,0},
                  rotation=180),
                  Line(points={{0,0},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={70,0},
                  rotation=180),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-42,1},
                  rotation=90),
                  Line(points={{-10,-1.22461e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,80},{120,40}},
                  textColor={0,0,0},
                  textString="%name")}),    Documentation(info="<html>

<p>
Model of an inductive load. It may be used to model an inductive motor.
</p>
<p>
The model computes the complex power vector as
<p align=\"center\" style=\"font-style:italic;\">
S = P + jQ = V &sdot; i<sup>*</sup>,
</p>
<p>
where <i>V</i> is the voltage phasor and <i>i<sup>*</sup></i> is the complex
conjugate of the current phasor. The voltage and current phasors are shifted
by an angle <i>&phi;</i>.
</p>

<p>
The load model takes as input the power consumed by the inductive load and
the power factor <i>pf=cos(&phi;)</i>. The power
can be either fixed using the parameter <code>P_nominal</code>, or
it is possible to specify a variable power using the inputs <code>y</code> or
<code>Pow</code>.

The power factor can be either specified by the parameter <code>pf</code>
or using the input connector <code>pf_in</code>.

The different modes can be selected with the parameter
<code>mode</code> and <code>use_pf_in</code>, see <a href=\"modelica://Buildings.Electrical.Interfaces.Load\">
Buildings.Electrical.Interfaces.Load</a> and
<a href=\"modelica://Buildings.Electrical.Interfaces.InductiveLoad\">
Buildings.Electrical.Interfaces.InductiveLoad</a> for more information.
</p>

<p>
Given the active power <i>P</i> and the power factor <i>pf</i>, the complex
power <i>Q</i> is computed as
</p>

<p align=\"center\" style=\"font-style:italic;\">
Q = P  tan(arccos(pf)).
</p>

<p>
The equations of the model can be rewritten as
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = (P V<sub>1</sub> + Q V<sub>2</sub>)/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>),
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = (P V<sub>2</sub> - Q V<sub>1</sub>)/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>),
</p>

<p>
where <i>i<sub>1</sub></i>, <i>i<sub>2</sub></i>, <i>V<sub>1</sub></i>, and <i>V<sub>2</sub></i>
are the real and imaginary parts of the current and voltage phasors.
</p>
<p>
The nonlinearity of the model is due to the fact that the load consumes the power specified by the variables <i>P</i>
and <i>Q</i>, irrespectively of the voltage of the load.
</p>
<p>
When multiple loads are connected in a grid through cables that cause voltage drops,
the dimension of the system of nonlinear equations increases linearly with the number of loads.
This nonlinear system of equations introduces challenges during the initialization,
as Newton solvers may diverge if initialized far from a solution, as well during the simulation.
In this situation, the model can be parameterized to use a linear approximation
as discussed in the next section.
</p>

<h4>Linearized model</h4>
<p>
Given the constraints and the two-dimensional nature of the problem, it is difficult to
find a linearized version of the AC load model. A solution could be to divide the voltage
domain into sectors, and for each sector compute the best linear approximation.
However the selection of the proper approximation depending on the value of the
voltage can generate events that increase the simulation time. For these reasons, the
linearized model assumes a voltage that is equal to the nominal value
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = (P V<sub>1</sub> + Q V<sub>2</sub>)/V<sub>RMS</sub><sup>2</sup>,
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = (P V<sub>2</sub> - Q V<sub>1</sub>)/V<sub>RMS</sub><sup>2</sup>,
</p>
<p>
where <i>V<sub>RMS</sub></i> is the Root Mean Square voltage of the AC system.
Even though this linearized version of the load model introduces an approximation
error in the current, it satisfies the constraints related to the ratio of the
active and reactive powers.
</p>

<h4>Initialization</h4>
<p>
The initialization problem can be simplified using the homotopy operator. The homotopy operator
uses two different types of equations to compute the value of a variable: the actual one
and a simplified one. The actual equation is the one used during the normal operation.
During initialization, the simplified equation is first solved and then slowly replaced
with the actual equation to compute the initial values for the nonlinear systems of
equations. The load model uses the homotopy operator, with the linearized model being used
as the simplified equation. This numerical expedient has proven useful when simulating models
with more than ten connected loads.
</p>
<p>
The load model has a parameter <code>initMode</code> that can be used to select
the assumption to use during the initialization phase by the homotopy operator.
The choices are between a null current or the linearized model.
</p>


</html>",         revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Added <code>replaceable</code> to terminal redeclaration as they are redeclared by
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Loads.Inductive\">
Buildings.Electrical.AC.ThreePhasesBalanced.Loads.Inductive</a>.
</li>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>September 4, 2014, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>June 17, 2014, by Marco Bonvini:<br/>
Adde parameter <code>initMode</code> that can be used to
select the assumption to be used during initialization phase
by the homotopy operator.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Inductive;

        model Resistive "Model of a resistive load"
          extends ProsNet.Electrical.Interfaces.ResistiveLoad(
            redeclare package PhaseSystem = PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_n terminal,
            V_nominal(start=110));
        equation

          if linearized then
            i[1] = -homotopy(actual = v[1]*P/V_nominal^2, simplified = v[1]*Modelica.Constants.eps*1e3);
            i[2] = -homotopy(actual = v[2]*P/V_nominal^2, simplified = v[2]*Modelica.Constants.eps*1e3);
          else
            if initMode == ProsNet.Electrical.Types.InitMode.zero_current then
              i[1] = -homotopy(actual= v[1]*P/(v[1]^2 + v[2]^2),  simplified= 0.0);
              i[2] = -homotopy(actual= v[2]*P/(v[1]^2 + v[2]^2),  simplified= 0.0);
            else
              i[1] = -homotopy(actual= v[1]*P/(v[1]^2 + v[2]^2),
                               simplified= v[1]*P/V_nominal^2);
              i[2] = -homotopy(actual= v[2]*P/(v[1]^2 + v[2]^2),
                               simplified= v[2]*P/V_nominal^2);
            end if;
          end if;
          annotation (
            defaultComponentName="loa",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,40},{80,-40}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={0,3.55271e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,80},{120,40}},
                  textColor={0,0,0},
                  textString="%name")}),
                  Documentation(info="<html>
<p>
Model of a resistive load. It may be used to model a load that has
a power factor of one.
</p>
<p>
The model computes the complex power vector as
<p align=\"center\" style=\"font-style:italic;\">
S = P + jQ = V &sdot; i<sup>*</sup>
</p>
<p>
where <i>V</i> is the voltage phasor and <i>i<sup>*</sup></i> is the complex
conjugate of the current phasor.
</p>

<p>
The load model takes as input the power consumed by the inductive load and
the power factor <i>pf=cos(&phi;)</i>. The power
can be either fixed using the parameter <code>P_nominal</code>, or
it is possible to specify a variable power using the inputs <code>y</code> or
<code>Pow</code>. The different modes can be selected with the parameter
<code>mode</code>, see <a href=\"modelica://Buildings.Electrical.Interfaces.Load\">
Buildings.Electrical.Interfaces.Load</a> for more information.
</p>

<p>
The equations of the model can be rewritten as
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = (P V<sub>1</sub> + Q V<sub>2</sub>)/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>),
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = (P V<sub>2</sub> - Q V<sub>1</sub>)/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>),
</p>

<p>
where <i>i<sub>1</sub></i>, <i>i<sub>2</sub></i>, <i>V<sub>1</sub></i>, and <i>V<sub>2</sub></i>
are the real and imaginary parts of the current and voltage phasors.
</p>

<p>
Since the model represents a load with a power factor of one, the complex
power is <i>Q = 0</i>. This leads to the following equations where
there are nonlinear equations that relate the current to the voltage
</p>

<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = P V<sub>1</sub>/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>)
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = P V<sub>2</sub>/(V<sub>1</sub><sup>2</sup> + V<sub>2</sub><sup>2</sup>)
</p>

<p>
The non-linearity is due to the fact that the load consumes the power specified by the variable <i>P</i>,
irrespectively of the voltage of the load. The figure below shows the relationship
between the real part of the current phasor and the real and imaginary voltages of the load.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Loads/NonlinearLoad_labels.png\"/>
</p>

<p>
When multiple loads are connected in a grid through cables that cause voltage drops,
the dimension of the system of nonlinear equations increases linearly with the number of loads.
This nonlinear system of equations introduces challenges during the initialization,
as Newton solvers may diverge if initialized far from a solution, as well during the simulation.
In this situation, the model can be parameterized to use a linear approximation
as discussed in the next section.
</p>

<h4>Linearized model</h4>
<p>
Given the constraints and the two-dimensional nature of the problem, it is difficult to
find a linearized version of the AC load model. A solution could be to divide the voltage
domain into sectors, and for each sector compute the best linear approximation.
However, the selection of the proper approximation depending on the value of the
voltage can generate events that increase the simulation time. For these reasons, the
linearized model assumes a voltage that is equal to the nominal value
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>1</sub> = P V<sub>1</sub>/V<sub>RMS</sub><sup>2</sup>
</p>
<p align=\"center\" style=\"font-style:italic;\">
i<sub>2</sub> = P V<sub>2</sub>/V<sub>RMS</sub><sup>2</sup>
</p>
<p>
where <i>V<sub>RMS</sub></i> is the Root Mean Square voltage of the AC system.
Even though this linearized version of the load model introduces an approximation
error in the current, it satisfies the constraints related to the ratio of the
active and reactive powers.
</p>
<p>
The image below show the linearized function
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Loads/LinearLoad_labels.png\"/>
</p>

<h4>Initialization</h4>
<p>
The initialization problem can be simplified using the homotopy operator. The homotopy operator
uses two different types of equations to compute the value of a variable: the actual one
 and a simplified one. The actual equation is the one used during the normal operation.
During initialization, the simplified equation is first solved and then slowly replaced
with the actual equation to compute the initial values for the nonlinear system of
equations. The load model uses the homotopy operator, with the linearized model being used
as the simplified equation. This numerical expedient has proven useful when simulating models
with more than ten connected loads.
</p>
<p>
The load model has a parameter <code>initMode</code> that can be used to select
the assumption to use during the initialization phase by the homotopy operator.
The choices are between a null current or the linearized model.
</p>

</html>",         revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>May 14, 2015, by Marco Bonvini:<br/>
Changed parent class to <a href=\"modelica://Buildings.Electrical.Interfaces.ResistiveLoad\">
Buildings.Electrical.Interfaces.ResistiveLoad</a> in order
to help openmodelica parsing the model. This fixes issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/415\">#415</a>.
</li>
<li>September 4, 2014, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>June 17, 2014, by Marco Bonvini:<br/>
Added parameter <code>initMode</code> that can be used to
select the assumption to be used during initialization phase
by the homotopy operator.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Resistive;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model DynamicLoads "Example that illustrates the use of dynamic loads"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage source(f=60, V=
                  120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,10})));
            ProsNet.Electrical.AC.OnePhase.Loads.Capacitive dynRC(
              pf=0.8,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic,
              P_nominal=-1200,
              V_nominal=120) "Dynamic RC load"
              annotation (Placement(transformation(extent={{0,-20},{20,0}})));
            ProsNet.Electrical.AC.OnePhase.Lines.TwoPortResistance line(R=0.1)
              "Line resistance"
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive dynRL(
              pf=0.8,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic,
              P_nominal=-1200,
              V_nominal=120) "Dynamic RL load"
              annotation (Placement(transformation(extent={{0,10},{20,30}})));
          equation
            connect(source.terminal, line.terminal_n) annotation (Line(
                points={{-60,10},{-40,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line.terminal_p, dynRC.terminal) annotation (Line(
                points={{-20,10},{-10,10},{-10,-10},{-4.44089e-16,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(dynRL.terminal, line.terminal_p) annotation (Line(
                points={{-4.44089e-16,20},{-10,20},{-10,10},{-20,10}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
              Documentation(info="<html>
<p>
This model compares two dynamic load models that use the dynamic
phasors.
</p>
<p>
The loads at nominal conditions should consume an active power equal
to <i>1.2</i> kW. Because of the line resistance the voltage at the load is
attenuated and they consume less power.
</p>
<p>
As expected the real part of the current vector drawn by the loads are
the same while the complex parts have opposite signs.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 3, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Loads/Examples/DynamicLoads.mos"
                  "Simulate and plot"));
          end DynamicLoads;

          model ParallelLoads
            "Example that illustrates the use of the load models at constant voltage"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive varRL(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              linearized=false,
              V_nominal=120) "Variable inductor and resistor" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}}, origin={10,
                      50})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage source(f=60, V=
                  120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,10})));
            Modelica.Blocks.Sources.Ramp load_y(duration=0.5, startTime=0.2)
              "Input signal for RC load"
              annotation (Placement(transformation(extent={{60,0},{40,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive RL(
              P_nominal=-1e3,
              linearized=false,
              V_nominal=120) "Constant inductor and resistor" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}}, origin={10,
                      30})));
            ProsNet.Electrical.AC.OnePhase.Loads.Capacitive varRC(
              mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
              P_nominal=-1e3,
              linearized=false,
              V_nominal=120) "Variable conductor and resistor" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}}, origin={10,
                      10})));
            ProsNet.Electrical.AC.OnePhase.Loads.Capacitive RC(
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              P_nominal=-1e3,
              linearized=false,
              V_nominal=120) "Constant conductor and resistor" annotation (
                Placement(transformation(extent={{-10,-10},{10,10}}, origin={10,
                      -10})));
            ProsNet.Electrical.AC.OnePhase.Loads.Resistive R(
              P_nominal=-1e3,
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              linearized=false,
              V_nominal=120) "Resistive load" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}}, origin={10,-30})));
            Modelica.Blocks.Sources.Ramp load_P(
              startTime=0.2,
              duration=0.5,
              height=-2000,
              offset=1000) "Power signal for load varRL"
              annotation (Placement(transformation(extent={{60,40},{40,60}})));
          equation
            connect(source.terminal, varRL.terminal)  annotation (Line(
                points={{-60,10},{-30,10},{-30,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(source.terminal, RL.terminal)  annotation (Line(
                points={{-60,10},{-30,10},{-30,30},{0,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(source.terminal, varRC.terminal)  annotation (Line(
                points={{-60,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(source.terminal, R.terminal)
                                                annotation (Line(
                points={{-60,10},{-30,10},{-30,-30},{0,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RC.terminal, R.terminal) annotation (Line(
                points={{0,-10},{-30,-10},{-30,-30},{-5.55112e-16,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load_y.y, varRC.y)
                                     annotation (Line(
                points={{39,10},{20,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load_P.y, varRL.Pow)
                                        annotation (Line(
                points={{39,50},{20,50}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (
              experiment(StopTime=1.0, Tolerance=1e-6),
              Documentation(info="<html>
<p>
This model illustrates the use of the load models.
The first two lines are inductive loads, followed by two capacitive loads and a resistive load.

The inductive load <code>varRL</code> and the capacitive load <code>varRC</code>
have a variable load specified by the inputs <code>Pow</code> and <code>y</code>
respectively.

All the loads have a nominal power of 1kW, and <code>varRL</code> is the only one
that at <i>t=0</i> produces power 1kW and as the time increases it start to
consume up to 1kW.

</p>
</html>",     revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 3, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Loads/Examples/ParallelLoads.mos"
                  "Simulate and plot"));
          end ParallelLoads;

          model ParallelResistors
            "Example that illustrates the use of the load models at constant voltage"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage source(f=60, V=
                  120) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,10})));
            Modelica.Blocks.Sources.Ramp load(duration=0.5, startTime=0.2,
              height=2400,
              offset=-1200) "Power signal for load R"
              annotation (Placement(transformation(extent={{40,0},{20,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Resistive R(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
                V_nominal=120) "Variable resistive load" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}}, origin={-22,10})));
            ProsNet.Electrical.AC.OnePhase.Loads.Resistive R1(
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              P_nominal=-1.2e3,
              V_nominal=120) "Fixed resistive load" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}}, origin={-22,-10})));
          equation
            connect(source.terminal, R.terminal) annotation (Line(
                points={{-60,10},{-32,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, R.Pow) annotation (Line(
                points={{19,10},{-12,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(source.terminal, R1.terminal) annotation (Line(
                points={{-60,10},{-46,10},{-46,-10},{-32,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (
              experiment(StopTime=1.0, Tolerance=1e-6),
              Documentation(info="<html>
<p>
This model compares two resistive loads. Model <code>R</code> consumes or produces
a variable amount of power, while model <code>R1</code> consumes a fixed power.
</p>
<p>
At time <i>t=0</i> <code>R</code> and <code>R1</code> consumes the same amount of power
while at <i>t=1</i> <code>R</code> produces the same power consumed by <code>R1</code>.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 3, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Loads/Examples/ParallelResistors.mos"
                  "Simulate and plot"));
          end ParallelResistors;

          model TestImpedance "Example that illustrates the use of the impedances"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage V(f=60, V=120)
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z1(
              R=0,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Inductive impedance"
              annotation (Placement(transformation(extent={{-20,20},{0,40}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z2(
              R=0,
              inductive=false,
              C=1/(2*Modelica.Constants.pi*60)) "Capacitive impedance"
              annotation (Placement(transformation(extent={{-20,0},{0,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z3(R=1)
              "Resistive impedance"
              annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z4(R=1, L=1/(2*
                  Modelica.Constants.pi*60)) "Inductive-resistive impedance"
              annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z5(
              R=1,
              inductive=false,
              C=1/(2*Modelica.Constants.pi*60))
              "Capacitive-resistive impedance" annotation (Placement(
                  transformation(extent={{-20,-60},{0,-40}})));
          equation
            connect(V.terminal, Z1.terminal)  annotation (Line(
                points={{-60,30},{-20,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(V.terminal, Z2.terminal) annotation (Line(
                points={{-60,30},{-40,30},{-40,10},{-20,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(V.terminal, Z3.terminal) annotation (Line(
                points={{-60,30},{-40,30},{-40,-10},{-20,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(V.terminal, Z4.terminal) annotation (Line(
                points={{-60,30},{-40,30},{-40,-30},{-20,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(V.terminal, Z5.terminal) annotation (Line(
                points={{-60,30},{-40,30},{-40,-50},{-20,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-06),
              __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Loads/Examples/TestImpedance.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This model shows how to use the impedance model in different configurations:
</p>
<ul>
<li>Resistive (model <code>Z3</code>)</li>
<li>Inductive (model <code>Z1</code>)</li>
<li>Capacitive (model <code>Z2</code>)</li>
<li>Resistive-Inductive (model <code>Z4</code>)</li>
<li>Resistive-Capacitive (model <code>Z5</code>)</li>
</ul>
</html>",           revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
          end TestImpedance;

          model ThreePhases
            "Examples that illustrates how to replicate a three-phase balanced system"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage Va(
              definiteReference=true,
              f=60,
              V=120) "Source phase A" annotation (Placement(transformation(
                    extent={{-40,40},{-20,60}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Za(
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              R=12) "Impedance phase A"
              annotation (Placement(transformation(extent={{20,40},{40,60}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage Vb(
              definiteReference=true,
              phiSou=-2.0943951023932,
              f=60,
              V=120) "Source phase B"
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Zb(
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              R=12) "Impedance phase B"
              annotation (Placement(transformation(extent={{20,0},{40,20}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage Vc(
              definiteReference=true,
              phiSou=2.0943951023932,
              f=60,
              V=120) "Source phase C" annotation (Placement(transformation(
                    extent={{-40,-40},{-20,-20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Zc(
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              R=12) "Impedance phase C" annotation (Placement(transformation(
                    extent={{20,-40},{40,-20}})));
          equation
            connect(Va.terminal, Za.terminal) annotation (Line(
                points={{-20,50},{20,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Vb.terminal, Zb.terminal) annotation (Line(
                points={{-20,10},{20,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Vc.terminal, Zc.terminal) annotation (Line(
                points={{-20,-30},{20,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-06),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Loads/Examples/ThreePhases.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This model shows how a balanced three phase system can be represented with three
independent single phase circuits.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
          end ThreePhases;

          model VariableImpedance
            "Example that illustrates how using variable impedances"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage V(f=60, V=120)
              "Voltage source" annotation (Placement(transformation(extent={{-80,
                      -10},{-60,10}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z_L(
              R=0,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              use_L_in=true,
              LMin=1/(2*Modelica.Constants.pi*60),
              LMax=2/(2*Modelica.Constants.pi*60)) "Impedance with variable L"
              annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z_C(
              R=0,
              inductive=false,
              C=1/(2*Modelica.Constants.pi*60),
              use_C_in=true,
              CMin=1/(2*Modelica.Constants.pi*60),
              CMax=2/(2*Modelica.Constants.pi*60)) "Impedance with variable C"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Impedance Z_R(
              R=1,
              RMin=1,
              RMax=2,
              use_R_in=true,
              L=0) "Impedance with variable R"
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Modelica.Blocks.Sources.Ramp load(duration=0.5, startTime=0.2,
              height=1,
              offset=0) "Input signal for the loads"
              annotation (Placement(transformation(extent={{60,-10},{40,10}})));
          equation
            connect(V.terminal, Z_L.terminal) annotation (Line(
                points={{-60,6.66134e-16},{-40,6.66134e-16},{-40,-50},{-20,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(V.terminal, Z_C.terminal)
                                             annotation (Line(
                points={{-60,6.66134e-16},{-20,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(V.terminal, Z_R.terminal)
                                             annotation (Line(
                points={{-60,6.66134e-16},{-40,6.66134e-16},{-40,50},{-20,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, Z_R.y_R) annotation (Line(
                points={{39,0},{30,0},{30,80},{-14,80},{-14,60}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.y, Z_C.y_C) annotation (Line(
                points={{39,4.44089e-16},{30,4.44089e-16},{30,20},{-10,20},{-10,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.y, Z_L.y_L) annotation (Line(
                points={{39,6.66134e-16},{34,6.66134e-16},{34,0},{30,0},{30,-20},{-6,-20},
                    {-6,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-06),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Loads/Examples/VariableImpedance.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This model shows how to vary the resistance,
capacitance or inductance of an impedance model.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"));
          end VariableImpedance;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
</p>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models that represent different types of AC single phase loads.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Loads;

      package Sensors "Package with sensors for AC electrical systems"
      extends Modelica.Icons.SensorsPackage;

        model GeneralizedSensor "Sensor for power, voltage and current"
          extends ProsNet.Electrical.Icons.GeneralizedSensor;
          extends ProsNet.Electrical.Interfaces.PartialTwoPort(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare Interfaces.Terminal_n terminal_n,
            redeclare Interfaces.Terminal_p terminal_p);
          Modelica.Blocks.Interfaces.RealOutput V(final quantity="ElectricPotential",
                                                  final unit="V")=
              ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(  terminal_n.v)
            "Voltage"
              annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-50}),   iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-90})));
          Modelica.Blocks.Interfaces.RealOutput I(final quantity="ElectricCurrent",
                                                  final unit="A")=
            ProsNet.Electrical.PhaseSystems.OnePhase.systemCurrent(  terminal_n.i)
            "Current"
            annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={60,-50}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={60,-90})));
          Modelica.Blocks.Interfaces.RealOutput S[PhaseSystems.OnePhase.n](
                                                  each final quantity="Power",
                                                  each final unit="W")=
             ProsNet.Electrical.PhaseSystems.OnePhase.phasePowers_vi(  v=terminal_n.v, i=terminal_n.i)
            "Phase powers"
             annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-50}),iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-90})));
        equation
          connect(terminal_n, terminal_p) annotation (Line(
              points={{-100,0},{2,0},{2,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (defaultComponentName="sen",
          Documentation(info="<html>
<p>
Ideal sensor that measures power, voltage and current.
The two components of the power <i>S</i> are the active and reactive power.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Fixed bug. The model was referencing the wrong PhaseSystem.
</li>
<li>September 4, 2014, by Michael Wetter:<br/>
Revised model, changed <code>equation</code> section to
avoid mixing graphical and textual modeling.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(graphics={
                Text(
                  extent={{-120,-42},{0,-82}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="S")}));
        end GeneralizedSensor;

        model Probe "Model of a probe that measures RMS voltage and angle"
          extends Icons.GeneralizedProbe;
          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
            "Nominal voltage (V_nominal >= 0)";
          parameter Boolean perUnit = true "If true, display voltage in p.u.";
          replaceable Interfaces.Terminal_n term "Electrical connector" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-90})));
          Modelica.Blocks.Interfaces.RealOutput V(unit=if perUnit then "1" else "V")
            "Voltage phasor magnitude"                                                                          annotation (Placement(
                transformation(extent={{60,20},{80,40}}), iconTransformation(extent={{60,
                    20},{80,40}})));
          Modelica.Blocks.Interfaces.RealOutput theta(unit="rad", displayUnit="deg")
            "Voltage phasor angle"
                                 annotation (Placement(
                transformation(extent={{60,-40},{80,-20}}), iconTransformation(extent={{60,
                    -40},{80,-20}})));
        equation
          theta = ProsNet.Electrical.PhaseSystems.OnePhase.phase(term.v);
          if perUnit then
            V = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(term.v)/
              V_nominal;
          else
            V = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(term.v);
          end if;
          term.i = zeros(ProsNet.Electrical.PhaseSystems.OnePhase.n);
          annotation (
          defaultComponentName="sen",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Text(
                  extent={{40,60},{100,40}},
                  textColor={0,0,0},
                  pattern=LinePattern.Dash,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid,
                  textString="V"), Text(
                  extent={{18,-40},{140,-60}},
                  textColor={0,0,0},
                  pattern=LinePattern.Dash,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid,
                  textString="theta")}),    Documentation(info="<html>
<p>
This model represents a probe that measures the RMS voltage and the angle
of the voltage phasor at a given point.
</p>
<p>
Optionally, given a reference voltage, the model can compute the voltage in per unit.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 30, 2015, by Michael Wetter:<br/>
Made <code>term</code> replaceable. This was detected
by the OpenModelica regression tests.
</li>
<li>September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Probe;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model GeneralizedSensor
            "This example illustrates how to use the generalized sensor model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sensors.GeneralizedSensor sen
              "Sensor that measures V, I, and S"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Capacitive loa(
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic,
              P_nominal=-100,
              V_nominal=120) "Constant load"
              annotation (Placement(transformation(extent={{40,0},{60,20}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(f=60, V=120)
              "Voltage source"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            ProsNet.Electrical.AC.OnePhase.Lines.TwoPortResistance res(R=0.05)
              "Line resistance"
              annotation (Placement(transformation(extent={{-32,0},{-12,20}})));
          equation
            connect(sen.terminal_p, loa.terminal)
              annotation (Line(points={{20,10},{40,10}},          smooth=Smooth.None));
            connect(sou.terminal, res.terminal_n) annotation (Line(
                points={{-40,10},{-32,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(res.terminal_p, sen.terminal_n) annotation (Line(
                points={{-12,10},{-4.44089e-16,10}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            Documentation(
            info="<html>
<p>
This example illustrates the use of the generalized sensor.
</p>
</html>", revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),__Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Sensors/Examples/GeneralizedSensor.mos"
                  "Simulate and plot"));
          end GeneralizedSensor;

          model Probe "This example illustrates how to use the probe model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Loads.Capacitive loaRC(
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              P_nominal=-10000,
              V_nominal=120) "Constant load"
              annotation (Placement(transformation(extent={{10,0},{30,20}})));
            ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(f=60, V=120)
              "Voltage source" annotation (Placement(transformation(extent={{-60,
                      -30},{-40,-10}})));
            ProsNet.Electrical.AC.OnePhase.Lines.TwoPortResistance res1(R=0.1)
              "First line resistance"
              annotation (Placement(transformation(extent={{-26,0},{-6,20}})));
            ProsNet.Electrical.AC.OnePhase.Sensors.Probe probe_source(V_nominal
                =120) "Probe that measures at the voltage source" annotation (
                Placement(transformation(extent={{-50,30},{-30,50}})));
            ProsNet.Electrical.AC.OnePhase.Sensors.Probe probe_loadRC(V_nominal
                =120) "Probe that measures at the RC load"
              annotation (Placement(transformation(extent={{-10,30},{10,50}})));
            ProsNet.Electrical.AC.OnePhase.Lines.TwoPortResistance res2(R=0.1)
              "Second line resistance" annotation (Placement(transformation(
                    extent={{-26,-70},{-6,-50}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive loaRL(
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              P_nominal=-10000,
              V_nominal=120) "Constant load" annotation (Placement(
                  transformation(extent={{10,-70},{30,-50}})));
            ProsNet.Electrical.AC.OnePhase.Sensors.Probe probe_loadRL(V_nominal
                =120) "Probe that measures at the RL load" annotation (
                Placement(transformation(extent={{-10,-28},{10,-8}})));
          equation
            connect(sou.terminal, res1.terminal_n) annotation (Line(
                points={{-40,-20},{-40,10},{-26,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(res1.terminal_p, loaRC.terminal) annotation (Line(
                points={{-6,10},{10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, probe_source.term) annotation (Line(
                points={{-40,-20},{-40,31}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(loaRC.terminal, probe_loadRC.term) annotation (Line(
                points={{10,10},{6.66134e-16,10},{6.66134e-16,31}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, res2.terminal_n) annotation (Line(
                points={{-40,-20},{-40,-60},{-26,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(res2.terminal_p, loaRL.terminal) annotation (Line(
                points={{-6,-60},{10,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(loaRL.terminal, probe_loadRL.term) annotation (Line(
                points={{10,-60},{6.66134e-16,-60},{6.66134e-16,-27}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            Documentation(
            info="<html>
<p>
This example illustrates the use of the probe model.
</p>
</html>", revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"),__Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Sensors/Examples/Probe.mos"
                  "Simulate and plot"));
          end Probe;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sensors\">
Buildings.Electrical.AC.OnePhase.Sensors</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for voltage, current and power sensors.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Sensors;

      package Sources "Package with sources models for one phase AC systems"
        extends Modelica.Icons.SourcesPackage;

        model FixedVoltage "Fixed single phase AC voltage source"
          extends ProsNet.Electrical.Interfaces.Source(redeclare package
              PhaseSystem = PhaseSystems.OnePhase, redeclare replaceable
              Interfaces.Terminal_p terminal);
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Voltage V(start=110) "RMS voltage of the source";
          parameter Modelica.Units.SI.Angle phiSou=0 "Phase shift of the source";
        protected
          Modelica.Units.SI.Angle thetaRel
            "Absolute angle of rotating system as offset to thetaRef";
        equation
          if Connections.isRoot(terminal.theta) then
            PhaseSystem.thetaRef(terminal.theta) =  2*Modelica.Constants.pi*f*time;
          end if;
          thetaRel = PhaseSystem.thetaRel(terminal.theta);
          terminal.v = PhaseSystem.phaseVoltages(V, thetaRel + phiSou);

          annotation (
            defaultComponentName="fixVol",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                           graphics={
                Ellipse(
                  extent={{-60,60},{60,-60}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Line(
                  points={{-44,0},{-24,40},{-4,0},{16,-40},{36,0}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{-120,100},{120,60}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{60,0},{90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(visible = definiteReference == true,
                  points={{80,-46},{120,-46}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(visible = definiteReference == true,
                  points={{80,-46},{106,-20}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(visible = definiteReference == true,
                  points={{102,-22},{114,-30},{118,-48}},
                  color={0,120,120},
                  smooth=Smooth.Bezier),
                Text(
                  extent={{-118,-60},{122,-100}},
                  textColor={0,0,0},
                  textString="V = %V")}),
              Documentation(info="<html>
<p>
This is a constant voltage source. The complex voltage is specified by the RMS voltage
and the phase shift.
</p>
</html>",revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Added <code>replaceable</code> to terminal redeclaration as they are redeclared by
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage\">
Buildings.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage</a>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised documentation.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end FixedVoltage;

        model Generator "Model of a generator"
          extends ProsNet.Electrical.Interfaces.Source(redeclare package
              PhaseSystem = PhaseSystems.OnePhase, redeclare replaceable
              Interfaces.Terminal_p terminal);
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Angle phiGen(displayUnit="deg") = 0
            "Phase shift of the source";
          Modelica.Units.SI.Current I "value of current";
          Modelica.Blocks.Interfaces.RealInput P
            "Variable power generated by the source"
             annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                origin={-100,0}),iconTransformation(
                extent={{-20,-20},{20,20}},
                origin={-100,0})));
        protected
          Modelica.Units.SI.Angle thetaRel
            "Absolute angle of rotating system as offset to thetaRef";
        equation
          if Connections.isRoot(terminal.theta) then
              PhaseSystem.thetaRef(terminal.theta) =  2*Modelica.Constants.pi*f*time;
          end if;

          thetaRel = PhaseSystem.thetaRel(terminal.theta);

          terminal.i = PhaseSystem.phaseCurrents(I, thetaRel+phiGen);
          0 = PhaseSystem.activePower(terminal.v, terminal.i) + P;

          annotation (
              defaultComponentName="gen",
              Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                                 graphics={Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,48},{-52,-52},{60,-16},{60,12},{-52,48}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-120,130},{120,100}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(visible = definiteReference == true,
                  points={{-20,-128},{20,-128}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(visible = definiteReference == true,
                  points={{-20,-128},{6,-102}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(visible = definiteReference == true,
                  points={{2,-104},{14,-112},{18,-130}},
                  color={0,120,120},
                  smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>
Model of a generator that produces real power
<code>P</code> with a given phase shift <code>phiGen</code>.
</p>
<p>
This model must be used with
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.Grid\">
Buildings.Electrical.AC.OnePhase.Sources.Grid</a>
or with a voltage source from the package
<a href=\"modelica://Modelica.Electrical.QuasiStatic.SinglePhase.Sources\">
Modelica.Electrical.QuasiStatic.SinglePhase.Sources</a>.
Otherwise, there will be no equation that defines the phase
angle of the voltage.
</p>
<p>
The boolean flags <code>potentialReference</code> and
<code>definiteReference</code> allows to select the phase angle of the
generator as reference for the models connected to it. More info about
these flags are available in
<a href=\"modelica://Buildings.Electrical.AC.UsersGuide\">
Buildings.Electrical.AC.UsersGuide</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 4, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generator;

        model Grid "Electrical grid"

          replaceable ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_p terminal
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}}),
                iconTransformation(extent={{-10,-110},{10,-90}})));
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Voltage V(start=110) "RMS voltage of the source";
          parameter Modelica.Units.SI.Angle phiSou=0 "Phase shift angle of the source";
          ProsNet.Electrical.AC.Interfaces.PowerOutput P
            "Power consumed from grid if positive, or fed to grid if negative"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          replaceable ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage sou(
            potentialReference=true,
            definiteReference=true,
            final f=f,
            final V=V,
            final phiSou=phiSou) "Voltage source" annotation (Placement(
                transformation(extent={{10,-10},{-10,10}}, origin={10,0})));
        equation
          P.real = -sou.S[1];
          P.apparent = Modelica.Fluid.Utilities.regRoot(sou.S[2]^2 + sou.S[1]^2, delta = 0.01);
          P.phi = sou.phi;
          P.cosPhi = cos(sou.phi);
          connect(sou.terminal, terminal) annotation (Line(
              points={{-4.44089e-16,6.66134e-16},{-4.44089e-16,-100},{4.44089e-16,-100}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="gri",
            Documentation(info="<html>
<p>
Model that can be used to represent the electrical grid supply.
</p>
<p>
The model has an output connector named <code>P</code> that
contains information about the power supplied by the grid to the network.
The convention is that <code>P.real</code> is positive if real power is
consumed from the grid, and negative if it is fed into the grid.
</p>
<p>
The parameter <code>V</code> is the root means square of the voltage.
In US households, this is <i>120</i> Volts at <i>60</i> Hz,
in Europe it is <i>230</i> Volts at <i>50</i> Hz.
</p>
</html>",revisions="<html>
<ul>
<li>
August 31, 2016, by Michael Wetter:<br/>
Corrected sign error in documentation string of variable <code>P</code>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-120,130},{120,100}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{-60,-32},{-60,-72}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-74,-32},{-44,-32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-72,-38},{-48,-28},{-28,-16},{-16,-2},{-12,14}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-46,-38},{-22,-28},{-2,-16},{10,-2},{14,14}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-72,-32},{-72,-38}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-46,-32},{-46,-38}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-14,20},{16,20}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,20},{0,-20}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-12,20},{-12,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{14,20},{14,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{14,14},{38,24},{58,36},{70,50},{74,66}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-12,14},{12,24},{32,36},{44,50},{48,66}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{60,72},{60,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{46,72},{76,72}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{48,72},{48,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{74,72},{74,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-100,-76},{-96,-74},{-88,-68},{-76,-54},{-72,-38}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-100,-88},{-82,-80},{-62,-68},{-50,-54},{-46,-38}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{48,68},{72,78},{92,90},{98,94},{100,96}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{74,68},{84,72},{100,82}},
                  color={175,175,175},
                  smooth=Smooth.Bezier)}));
        end Grid;

        model PVSimple "Simple PV model"
          extends ProsNet.Electrical.Interfaces.PartialAcDcParameters;
          extends ProsNet.Electrical.Interfaces.PartialPV(
            redeclare package PhaseSystem =
                ProsNet.Electrical.PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_p terminal,
            V_nominal(start=110));
          parameter Boolean linearized=false
            "If =true, introduce a linearization in the load";
          replaceable ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load(
            mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            final pf=pf,
            final V_nominal=V_nominal,
            final P_nominal=0,
            final linearized=linearized) "Load model"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
        protected
          Modelica.Blocks.Math.Gain gain_DCAC(final k=eta_DCAC)
            "Gain that represents the DCAC conversion losses"
            annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={36,0})));
        equation
          connect(load.terminal, terminal) annotation (Line(
              points={{-40,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(gain_DCAC.y, load.Pow) annotation (Line(
              points={{25,1.33227e-15},{2,1.33227e-15},{2,0},{-20,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(gain_DCAC.u, solarPower.y)
            annotation (Line(points={{48,0},{70,0}}, color={0,0,127}));
          connect(gain_DCAC.y, P) annotation (Line(points={{25,1.33227e-15},{20,1.33227e-15},
                  {20,70},{110,70}}, color={0,0,127}));
          annotation (
        defaultComponentName="pv",
        Documentation(info="<html>
<p>
Model of a simple photovoltaic array.
</p>
<p>
The electrical connector is an AC interface.
</p>
<p>
This model computes the active power as
<p align=\"center\" style=\"font-style:italic;\">
P=A &nbsp; f<sub>act</sub> &nbsp; &eta; &nbsp; G &nbsp; &eta;<sub>DCAC</sub>,
</p>
<p>
where <i>A</i> is the panel area,
<i>f<sub>act</sub></i> is the fraction of the aperture area,
<i>&eta;</i> is the panel efficiency,
<i>G</i> is the total solar irradiation, which is the
sum of direct and diffuse irradiation, and
<i>&eta;<sub>DCAC</sub></i> is the efficiency of the conversion
between DC and AC.
</p>
<p>
This active power is equal to <i>P</i>,
while the reactive power is equal to <i>Q = P &nbsp; tan(acos(pf)) </i>
where <i>pf</i> is the power factor.
</p>
<p>
<b>Note:</b> This model takes as input the total solar irradiation on the panel.
This has to be computed converting the incoming radiation to take tilt and azimuth into account.
For a model that implements this conversion, use
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code>.
</li>
<li>
February 26, 2016, by Michael Wetter:<br/>
In load, set <code>P_nominal = 0</code> as it is not used.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end PVSimple;

        model PVSimpleOriented "Simple PV model with orientation"
          extends ProsNet.Electrical.Interfaces.PartialAcDcParameters;
          extends ProsNet.Electrical.Interfaces.PartialPVOriented(
            redeclare package PhaseSystem =
                ProsNet.Electrical.PhaseSystems.OnePhase,
            V_nominal(start=110),
            redeclare replaceable Interfaces.Terminal_p terminal,
            redeclare replaceable
              ProsNet.Electrical.AC.OnePhase.Sources.PVSimple panel(
              pf=pf,
              eta_DCAC=eta_DCAC,
              V_nominal=V_nominal,
              linearized=linearized));
          parameter Boolean linearized=false "If =true, linearize the load";
          annotation (
        defaultComponentName="pv",
            Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Line(points={{-90,0},{-59,0}}, color={0,0,0})}),
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",
        info="<html>
<p>
Model of a simple photovoltaic array.
</p>
<p>
This model takes as an input the direct and diffuse solar radiation from
the weather bus.
The electrical connector is an AC one phase interface.
</p>
<p>
This model computes the active power as
<p align=\"center\" style=\"font-style:italic;\">
P=A &nbsp; f<sub>act</sub> &nbsp; &eta; &nbsp; G &nbsp; &eta;<sub>DCAC</sub>,
</p>
<p>
where <i>A</i> is the panel area,
<i>f<sub>act</sub></i> is the fraction of the aperture area,
<i>&eta;</i> is the panel efficiency,
<i>G</i> is the total solar irradiation, which is the
sum of direct and diffuse irradiation, and
<i>&eta;<sub>DCAC</sub></i> is the efficiency of the conversion between DC and AC.
The model takes into account the location and the orientation of the PV panel,
specified by the surface tilt, latitude and azimuth.
</p>
<p>
This active power is equal to <i>P</i>, while the reactive power is equal to <i>Q = P &nbsp; tan(acos(pf))</i>,
where <i>pf</i> is the power factor.
</p>
</html>"));
        end PVSimpleOriented;

        model WindTurbine "Simple wind turbine model"
          extends ProsNet.Electrical.BaseClasses.WindTurbine.PartialWindTurbine(
            redeclare package PhaseSystem =
                ProsNet.Electrical.PhaseSystems.OnePhase,
            redeclare replaceable Interfaces.Terminal_p terminal,
            V_nominal(start=110));

          parameter Real pf(min=0, max=1) = 0.9 "Power factor"
            annotation (Dialog(group="AC-Conversion"));
          parameter Real eta_DCAC(min=0, max=1) = 0.9 "Efficiency of DC/AC conversion"
            annotation (Dialog(group="AC-Conversion"));
          replaceable ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load(
            final mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            final pf=pf,
            final P_nominal=0,
            final V_nominal=V_nominal) "Load model"
            annotation (Placement(transformation(extent={{12,-10},{32,10}})));
        protected
          Modelica.Blocks.Math.Gain gain_DCAC(final k=eta_DCAC) annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={52,0})));
        equation
          connect(load.terminal, terminal) annotation (Line(
              points={{12,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(gain_DCAC.y, load.Pow) annotation (Line(
              points={{41,0},{32,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(gain.y, gain_DCAC.u) annotation (Line(
              points={{23,30},{80,30},{80,0},{64,0}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
        defaultComponentName="winTur",
         Documentation(info="<html>
<p>
Model of a wind turbine whose power is computed as a function of wind-speed as defined in a table.
</p>
<p>
Input to the model is the local wind speed.
The model requires the specification of a table that maps wind speed in meters per second to generated
power <i>P<sub>t</sub></i> in Watts.
The model has a parameter called <code>scale</code> with a default value of one
that can be used to scale the power generated by the wind turbine.
The generated active electrical power is
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>t</sub> scale &eta;<sub>DCAC</sub>
</p>
<p>
where <i>&eta;<sub>DCAC</sub></i> is the efficiency of the conversion of the DC electrical power to AC.
For example, the following specification (with default <code>scale=1</code>) of a wind turbine
</p>
<pre>
  WindTurbine_Table tur(
    table=[3.5, 0;
           5.5,   100;
           12, 900;
           14, 1000;
           25, 1000]) \"Wind turbine\";
</pre>
<p>
yields the performance shown below. In this example, the cut-in wind speed is <i>3.5</i> meters per second,
and the cut-out wind speed is <i>25</i> meters per second,
as entered by the first and last entry of the wind speed column.
Below and above these wind speeds, the generated power is zero.
</p>
<p align=\"center\">
<img alt=\"alt-image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Sources/WindTurbine_Table.png\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
January 29, 2019, by Michael Wetter:<br/>
Added <code>replaceable</code> for terminal.
</li>
<li>
February 26, 2016, by Michael Wetter:<br/>
In load, set <code>P_nominal = 0</code> as it is not used.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end WindTurbine;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model FixedVoltageSource
            "This example illustrates how using a fixed voltage source"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive RL(
              P_nominal=-300,
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              V_nominal=120) "Load model"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            FixedVoltage grid(
              f=60,
              V=120,
              phiSou=0.34906585039887) "AC one phase electrical grid"
                     annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
            Sensors.Probe sen(V_nominal=120)
              "Probe that measures the voltage at the load"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          equation
            connect(grid.terminal, RL.terminal)
                                               annotation (Line(
                points={{-20,4.44089e-16},{-20,0},{20,0},{20,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, sen.term) annotation (Line(
                points={{-20,6.66134e-16},{0,6.66134e-16},{0,21},{4.44089e-16,21}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=1.0, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Sources/Examples/FixedVoltageSource.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a fixed voltage generator model.
</p>
</html>"));
          end FixedVoltageSource;

          model PVPanels "This example illustrates how to use PV panel models"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive RL(
              mode=Types.Load.VariableZ_y_input,
              P_nominal=-2000,
              V_nominal=120) "Load taht consumes the power generted by the PVs"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
            ProsNet.Electrical.AC.OnePhase.Sources.Grid grid(f=60, V=120)
              "Electrical grid model" annotation (Placement(transformation(
                    extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Sources.Constant  load(k=0.5) "Load consumption"
              annotation (Placement(transformation(extent={{78,-50},{58,-30}})));
            Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Diffuse irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,72},{-32,92}})));
            Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Direct irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,32},{-32,52}})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false, filNam=
                  Modelica.Utilities.Files.loadResource(
                  "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              annotation (Placement(transformation(extent={{-100,72},{-80,92}})));
            Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
              annotation (Placement(transformation(extent={{-12,52},{8,72}})));
            PVSimple pvSimple(A=10, V_nominal=120) "PV array simplified"
              annotation (Placement(transformation(extent={{40,0},{60,20}})));
            PVSimpleOriented pvOriented(
              A=10,
              til=0.34906585039887,
              azi=-0.78539816339745,
              V_nominal=120) "PV array oriented"
              annotation (Placement(transformation(extent={{-10,0},{10,20}})));
          equation
            connect(grid.terminal, RL.terminal)
                                               annotation (Line(
                points={{-50,-20},{-50,-40},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, RL.y)
                                 annotation (Line(
                points={{57,-40},{40,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(weaDat.weaBus,HDifTil. weaBus) annotation (Line(
                points={{-80,82},{-52,82}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaDat.weaBus,HDirTil. weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,42},{-52,42}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(HDifTil.H,G. u1) annotation (Line(
                points={{-31,82},{-24,82},{-24,68},{-14,68}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(HDirTil.H,G. u2) annotation (Line(
                points={{-31,42},{-24,42},{-24,56},{-14,56}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(G.y,pvSimple. G) annotation (Line(
                points={{9,62},{50,62},{50,22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pvSimple.terminal, RL.terminal) annotation (Line(
                points={{40,10},{20,10},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(weaDat.weaBus, pvOriented.weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,26},{4.44089e-16,26},{4.44089e-16,19}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(pvOriented.terminal, RL.terminal) annotation (Line(
                points={{-10,10},{-28,10},{-28,-40},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Sources/Examples/PVPanels.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed assignment of parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a simple PV model without orientation
as well a PV model with orientation. The power produced by the PV is
partially consumed by the load while the remaining part is fed into
the grid.
</p>
</html>"));
          end PVPanels;

          model VariablePowerSource
            "This example illustrates how using a variable power source"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.Generator generator(phiGen(
                  displayUnit="deg") = 0.26179938779915, f=60)
              "AC generator model" annotation (Placement(transformation(extent=
                      {{-50,-10},{-30,10}})));
            Modelica.Blocks.Sources.Sine generation(
              offset=200,
              startTime=1,
              amplitude=100,
              f=0.05) "Generated power"
              annotation (Placement(transformation(extent={{-92,-10},{-72,10}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Inductive RL(
              mode=Types.Load.VariableZ_y_input,
              P_nominal=-300,
              V_nominal=120) "Load model"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            ProsNet.Electrical.AC.OnePhase.Sources.Grid grid(f=60, V=120)
              "AC one phase electrical grid"
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Modelica.Blocks.Sources.Trapezoid load(
              rising=2,
              width=3,
              falling=3,
              period=10,
              startTime=1,
              amplitude=0.8,
              offset=0.2) "Power consumption profile"
              annotation (Placement(transformation(extent={{80,-10},{60,10}})));
          equation
            connect(generation.y, generator.P) annotation (Line(
                points={{-71,0},{-50,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(generator.terminal, RL.terminal)
                                                    annotation (Line(
                points={{-30,0},{20,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, RL.terminal)
                                               annotation (Line(
                points={{-10,40},{-10,0},{20,0},{20,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, RL.y)
                                 annotation (Line(
                points={{59,0},{40,0}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=1.0, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Sources/Examples/VariablePowerSource.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a variable generator model. The model has to be used
together with a voltage source generator.
</p>
</html>"));
          end VariablePowerSource;

          model WindTurbine "Example for the WindTurbine AC model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine tur(
              table=[3.5,0; 5.5,100; 12,900; 14,1000; 25,1000],
              h=10,
              scale=10,
              V_nominal=120) "Wind turbine" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}}, origin={60,0})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false, filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              "Weather data"
              annotation (Placement(transformation(extent={{-52,36},{-32,56}})));
            Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
              annotation (Placement(transformation(extent={{16,36},{36,56}})));
            ProsNet.Electrical.AC.OnePhase.Loads.Resistive res(P_nominal=-500,
                V_nominal=120) "Resistive line" annotation (Placement(
                  transformation(extent={{-22,-30},{-2,-10}})));
            ProsNet.Electrical.AC.OnePhase.Sources.Grid sou(f=60, V=120)
              "Voltage source" annotation (Placement(transformation(extent={{-80,
                      10},{-60,30}})));
            ProsNet.Electrical.AC.OnePhase.Lines.TwoPortResistance lin(R=0.1)
              "Transmission line" annotation (Placement(transformation(extent={
                      {-22,-10},{-2,10}})));
            ProsNet.Electrical.AC.OnePhase.Sensors.GeneralizedSensor sen
              "Generalized sensor"
              annotation (Placement(transformation(extent={{8,-10},{28,10}})));
          equation
            connect(weaDat.weaBus,weaBus)  annotation (Line(
                points={{-32,46},{26,46}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaBus.winSpe,tur. vWin) annotation (Line(
                points={{26,46},{60,46},{60,12}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(sou.terminal, lin.terminal_n) annotation (Line(
                points={{-70,10},{-70,0},{-22,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, res.terminal) annotation (Line(
                points={{-70,10},{-70,-20},{-22,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(lin.terminal_p, sen.terminal_n) annotation (Line(
                points={{-2,0},{8,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_p, tur.terminal) annotation (Line(
                points={{28,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=172800, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This model illustrates the use of the wind turbine model which is connected to a AC voltage source and a resistance.
This voltage source can represent the grid to which the
circuit is connected.
Wind data for San Francisco, CA, are used.
The turbine cut-in wind speed is <i>3.5</i> m/s,
and hence it is off in the first day when the wind speed is low.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Sources/Examples/WindTurbine.mos"
                  "Simulate and plot"));
          end WindTurbine;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources\">
Buildings.Electrical.AC.OnePhase.Sources</a>.
</p>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models of AC sources.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Sources;

      package Storage "Package with models for electrical storage with a AC one phase connector"
        extends Modelica.Icons.Package;

        model Battery "Simple model of a battery"
         extends ProsNet.Electrical.Interfaces.PartialAcDcParameters;
         replaceable package PhaseSystem =
              ProsNet.Electrical.PhaseSystems.OnePhase constrainedby
            ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
            annotation (choicesAllMatching=true);
          parameter Modelica.Units.SI.Efficiency etaCha(max=1) = 0.9
            "Efficiency during charging";
          parameter Modelica.Units.SI.Efficiency etaDis(max=1) = 0.9
            "Efficiency during discharging";
          parameter Real SOC_start(start=0.1) "Initial charge";
          parameter Modelica.Units.SI.Energy EMax(min=0, displayUnit="kW.h")
            "Maximum available charge";
          parameter Modelica.Units.SI.Voltage V_nominal(start=110)
            "Nominal voltage (V_nominal >= 0)";
          parameter Boolean linearized=false
            "If =true introduce a linearization in the load";
          parameter ProsNet.Electrical.Types.InitMode initMode(
            min=ProsNet.Electrical.Types.InitMode.zero_current,
            max=ProsNet.Electrical.Types.InitMode.linearized)=ProsNet.Electrical.Types.InitMode.zero_current
            "Initialization mode for homotopy operator"
            annotation (Dialog(tab="Initialization"));
         Modelica.Blocks.Interfaces.RealInput P(unit="W")
            "Power stored in battery (if positive), or extracted from battery (if negative)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,108}),
                iconTransformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,100})));
          Modelica.Blocks.Interfaces.RealOutput SOC "State of charge"
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          replaceable ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_p terminal
            "Generalized terminal" annotation (Placement(transformation(extent=
                    {{-110,-10},{-90,10}})));

        protected
          ProsNet.Electrical.DC.Storage.BaseClasses.Charge cha(
            final EMax=EMax,
            final SOC_start=SOC_start,
            final etaCha=etaCha,
            final etaDis=etaDis) "Charge model"
            annotation (Placement(transformation(extent={{40,50},{60,70}})));
          replaceable ProsNet.Electrical.AC.OnePhase.Loads.Resistive bat
            constrainedby ProsNet.Electrical.Interfaces.Load(
            final initMode=initMode,
            final mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            final V_nominal=V_nominal,
            final linearized=linearized) "Power exchanged with battery pack"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          Modelica.Blocks.Math.Gain gain(final k=-1)
            "Gain that invert sign of the power (P<0 -> the load is consumed)"
            annotation (Placement(transformation(extent={{20,10},{40,30}})));

          Modelica.Blocks.Math.Gain acdc_con_dis(final k = 2 - eta_DCAC)
            "Losses when P < 0"
            annotation (Placement(transformation(extent={{-68,10},{-48,30}})));
          Buildings.Utilities.Math.Splice spl(deltax=1e-2)
            "Splice function that attributes the losses due to AC/DC conversion"
            annotation (Placement(transformation(extent={{-36,30},{-16,50}})));
          Modelica.Blocks.Math.Gain acdc_con_cha(final k=eta_DCAC) "Losses when P > 0"
            annotation (Placement(transformation(extent={{-68,50},{-48,70}})));
        equation
          connect(cha.SOC, SOC)    annotation (Line(
              points={{61,60},{110,60}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(gain.y, bat.Pow) annotation (Line(
              points={{41,20},{68,20},{68,8.88178e-16},{60,8.88178e-16}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(bat.terminal, terminal) annotation (Line(
              points={{40,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(P, acdc_con_dis.u) annotation (Line(
              points={{8.88178e-16,108},{0,108},{0,80},{-80,80},{-80,20},{-70,20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(P, acdc_con_cha.u) annotation (Line(
              points={{8.88178e-16,108},{8.88178e-16,80},{-80,80},{-80,60},{-70,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(acdc_con_cha.y, spl.u1) annotation (Line(
              points={{-47,60},{-42,60},{-42,46},{-38,46}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(acdc_con_dis.y, spl.u2) annotation (Line(
              points={{-47,20},{-42,20},{-42,34},{-38,34}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(P, spl.x) annotation (Line(
              points={{8.88178e-16,108},{8.88178e-16,80},{-80,80},{-80,40},{-38,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(spl.y, cha.P) annotation (Line(
              points={{-15,40},{20,40},{20,60},{38,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(P, gain.u)
            annotation (Line(points={{0,108},{0,20},{18,20}}, color={0,0,127}));
          annotation (
        defaultComponentName="bat",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                graphics={
                Polygon(
                  points={{-62,40},{-62,-40},{72,-40},{72,40},{-62,40}},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Polygon(
                  points={{58,32},{58,-30},{32,-30},{10,32},{58,32}},
                  smooth=Smooth.None,
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-34,32},{-12,-30},{-32,-30},{-54,32},{-34,32}},
                  smooth=Smooth.None,
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-2,32},{20,-30},{0,-30},{-22,32},{-2,32}},
                  smooth=Smooth.None,
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={0,127,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-74,12},{-74,-12},{-62,-12},{-62,12},{-74,12}},
                  smooth=Smooth.None,
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Text(
                  extent={{-50,68},{-20,100}},
                  textColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  textString="P"),
                Line(
                  points={{-74,0},{-100,0},{-100,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{44,70},{100,116}},
                  textColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  textString="SOC"),
                Text(
                  extent={{44,154},{134,112}},
                  textColor={0,0,0},
                  textString="%name")}),
            Documentation(
        info="<html>
<p>
Simple model of a battery.
</p>
<p>
This model takes as an input the power to be extracted from the AC line and
stored in the battery (if <i>P &gt; 0</i>)
or to be fed into the AC line after being extracted from the battery.
The actual power stored or extracted in the battery differs from <i>P</i> due
to AC/DC conversion losses and battery charge and discharge efficiencies.
</p>
<p>
The output connector <code>SOC</code> is the state of charge of the battery.
This model does not enforce that the state of charge is between zero and one.
However, each time the state of charge crosses zero or one, a warning will
be written to the simulation log file.
The model also does not limit the current through the battery. The user should
provide a control so that only a reasonable amount of power is exchanged,
and that the state of charge remains between zero and one.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 6, 2021, by Michael Wetter:<br/>
Corrected wrong unit string.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2798\">issue 2798</a>.
</li>
<li>
April 2, 2020 by Michael Wetter:<br/>
Corrected model and improved the documentation. The previous model extracted from
the AC connector the input power <code>P</code> plus the AC/DC conversion losses, but <code>P</code>
should be the power exchanged at the AC connector. Conversion losses are now only
accounted for in the energy exchange at the battery.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1865\">issue 1865</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Corrected problem, the losses due to AC/DC conversion have to
affect both during the charge and the discharge. The input P is the
power that is taken, due to conversions the actual power drain
from the battery is higher.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 8, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Battery;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model AcBattery "This example shows how to use the AC battery model"
            extends Modelica.Icons.Example;
            Battery bat_ideal(
              eta_DCAC=1,
              etaCha=1,
              etaDis=1,
              SOC_start=0.5,
              EMax=749999.88,
              V_nominal=120) "Ideal battery without losses"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            Sources.FixedVoltage fixVol(f=60, V=120)
              annotation (Placement(transformation(extent={{-42,-10},{-22,10}})));
            Modelica.Blocks.Sources.Pulse pow(
              offset=-500,
              amplitude=1000,
              width=50,
              period=1200)
              "Signal that indicates how much power should be stored in the battery"
              annotation (Placement(transformation(extent={{-20,60},{0,80}})));
            Battery bat_loss_acdc(
              etaCha=1,
              etaDis=1,
              SOC_start=0.5,
              eta_DCAC=0.95,
              EMax=749999.88,
              V_nominal=120) "Battery with losses for AC/DC conversion"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            Battery bat(
              SOC_start=0.5,
              eta_DCAC=0.95,
              EMax=749999.88,
              V_nominal=120)
              "Battery with losses for AC/DC conversion and charge/discharge"
              annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
          equation
            connect(fixVol.terminal, bat_ideal.terminal) annotation (Line(
                points={{-22,0},{0,0},{0,30},{20,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(pow.y, bat_ideal.P) annotation (Line(
                points={{1,70},{30,70},{30,40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(fixVol.terminal, bat_loss_acdc.terminal) annotation (Line(
                points={{-22,0},{20,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(fixVol.terminal, bat.terminal) annotation (Line(
                points={{-22,0},{0,0},{0,-30},{20,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(pow.y, bat_loss_acdc.P) annotation (Line(
                points={{1,70},{50,70},{50,20},{30,20},{30,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pow.y, bat.P) annotation (Line(
                points={{1,70},{66,70},{66,-10},{30,-10},{30,-20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (            experiment(
                StopTime=3600,
                Tolerance=1e-6),
                      __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Storage/Examples/AcBattery.mos"
                  "Simulate and plot"),
                    Documentation(revisions="<html>
<ul>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use an AC battery model.
</p>
<p>
The example compares three different batteries. The battery named
<code>bat_ideal</code> is ideal and it does not account for any losses.
The battery named <code>bat_loss_acdc</code> accounts for conversion losses when converting
between AC and DC.
The battery named <code>bat</code> accounts for both conversion losses and inefficiencies
during both the charge and discharge phases.
</p>
<p>
All the batteries start from the same initial condition, which is 50% of their total capacity.
The batteries are charged and discharged in the same way. The input signal <code>pow.y</code>
is the power that each battery should store or release. The signal has a duty cycle equal to 50%.
Therefore, if there are no losses the same amount of power stored into the battery will be
released and after one cycle the State of Charge (SOC) has to be equal.
</p>
<p>
The image below shows the SOC of the three batteries.
</p>
<p align=\"center\">
<img alt=\"alt-image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Storage/Examples/SOCs.png\"/>
</p>
<p>
As expected the red line (ideal battery) maintains the SOC over the time.
The other two batteries loose some
of the initial energy due to the losses.
</p>
</html>"));
          end AcBattery;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Storage\">
Buildings.Electrical.AC.OnePhase.Storage</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added package with example and unit test.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for storage elements with an AC one phase connector.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Storage;

      package Examples "Package with example models"
      extends Modelica.Icons.ExamplesPackage;

        model GeneratorLoadGrid "Generator with a load and grid connection"
          extends Modelica.Icons.Example;

          Sources.Grid grid(
            f=60,
            V=120,
            phiSou=0.5235987755983) "Electrical grid"
            annotation (Placement(transformation(extent={{0,40},{20,60}})));
          Sources.Generator sou(f=60, phiGen(displayUnit="rad")) "Gas turbine"
                            annotation (Placement(transformation(
                extent={{-10,10},{10,-10}},
                origin={-30,-10})));
          ProsNet.Electrical.AC.OnePhase.Loads.Inductive res(
            mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            P_nominal=-5e3,
            V_nominal=120,
            pf=1) "Inductive load" annotation (Placement(transformation(extent=
                    {{-10,-10},{10,10}}, origin={30,-10})));
          Modelica.Blocks.Sources.Ramp ramp(
            height=1e4,
            duration=0.6,
            startTime=0.1,
            offset=0)
            annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
        equation
          connect(ramp.y, sou.P) annotation (Line(
              points={{-59,-10},{-40,-10}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sou.terminal, grid.terminal) annotation (Line(
              points={{-20,-10},{10,-10},{10,40}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(res.terminal, grid.terminal) annotation (Line(
              points={{20,-10},{10,-10},{10,40}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (experiment(
              StopTime=1.0,
              Tolerance=1e-6),
              __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Examples/GeneratorLoadGrid.mos"
                "Simulate and plot"),
                Documentation(info="<html>
<p>
This model illustrates a generator, an inductive load and a grid connection.
The power output of the generator is equal to its input signal, which is
a ramp function.
The output <code>grid.P</code> shows
the actual and apparent power, the power factor and
the phase angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GeneratorLoadGrid;

        model GridDCLoad "Model of a DC load connected to the grid"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.AC.OnePhase.Sources.Grid grid(
            f=60,
            phiSou=0,
            V=120)
            annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
          ProsNet.Electrical.AC.OnePhase.Conversion.ACDCConverter idealACDCConverter1(
            eta=0.9,
            ground_AC=false,
            conversionFactor=12/120) annotation (Placement(transformation(
                  extent={{-50,-40},{-30,-20}})));
          ProsNet.Electrical.DC.Loads.Resistor resistor(R=1, V_nominal=12)
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                  origin={10,-30})));
        equation
          connect(grid.terminal, idealACDCConverter1.terminal_n) annotation (Line(
              points={{-70,-20},{-70,-30},{-50,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(idealACDCConverter1.terminal_p, resistor.terminal) annotation (Line(
              points={{-30,-30},{0,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (experiment(
              StopTime=1.0,
              Tolerance=1e-6),
            __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/OnePhase/Examples/GridDCLoad.mos"
                "Simulate and plot"),
        Documentation(info="<html>
<p>
This model illustrates the use of a model for inductive load. The circuit on the left hand side
uses an inductive load, whereas the circuit on the right hand side uses a resistor and inductance in
series.
The parameters of the inductor and resistor are such that the real power and the phase angle are
identical (up to the numerical precision of the parameters) for the two systems.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 2, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GridDCLoad;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.OnePhase\">
Buildings.Electrical.AC.OnePhase</a>.
</p>
</html>"));
      end Examples;

      package Interfaces "Package with interfaces for one phase AC systems"
        extends Modelica.Icons.InterfacesPackage;

        connector Terminal_n "Terminal n for AC one phase systems"
          extends ProsNet.Electrical.Interfaces.Terminal(redeclare replaceable
              package PhaseSystem = ProsNet.Electrical.PhaseSystems.OnePhase);
          annotation (defaultComponentName = "term_p",
          Documentation(info="<html>
<p>Electric connector for AC one phase systems.</p>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={           Text(
                  extent={{-60,60},{60,-60}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{0,100},{-100,0},{0,-100},{100,0},{0,100}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Text(
                  extent={{-120,120},{100,60}},
                  textColor={0,120,120},
                  textString="%name"),
                Text(
                  extent={{14,16},{114,-84}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{-50,50},{-100,0},{-50,-50},{0,0},{-50,50}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end Terminal_n;

        connector Terminal_p "Terminal p for AC one phase systems"
          extends ProsNet.Electrical.Interfaces.Terminal(redeclare replaceable
              package PhaseSystem = ProsNet.Electrical.PhaseSystems.OnePhase);
          annotation (defaultComponentName = "term_p",
          Documentation(info="<html>
<p>Electric connector for AC one phase systems.</p>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={           Text(
                  extent={{-60,60},{60,-60}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{0,100},{-100,0},{0,-100},{100,0},{0,100}},
                  lineColor={0,120,120},
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Text(
                  extent={{-120,120},{100,60}},
                  textColor={0,120,120},
                  textString="%name"),
                Text(
                  extent={{14,16},{114,-84}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{50,50},{0,0},{50,-50},{100,0},{50,50}},
                  lineColor={0,120,120},
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid)}));
        end Terminal_p;
        annotation (Documentation(info="<html>
<p>
This package contains connectors that are used by the models in the
<a href=\"modelica://Buildings.Electrical.AC.OnePhase\">Buildings.Electrical.AC.OnePhase</a> package.
The connectors extend the basic connectors
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">Buildings.Electrical.Interfaces.Terminal</a>
and define a new graphical icon in order to be distinguished by connectors of other electrical systems (e.g. DC systems).
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Interfaces;
    annotation (Documentation(info="<html>
<p>
Package with models for alternate current (AC) single phase systems.<br/>
The models contained in this package use the phase system
<a href=\"modelica://Buildings.Electrical.PhaseSystems.OnePhase\">
Buildings.Electrical.PhaseSystems.OnePhase</a> and they assume 120 V as nominal RMS voltage.
</p>
</html>",     revisions="<html>
<ul>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
    end OnePhase;

    package ThreePhasesBalanced "Three phases balanced AC systems"
      extends Modelica.Icons.VariantsPackage;

      package Conversion "Package with transformers and converter models for three-phase balanced AC systems"
        extends Modelica.Icons.Package;

        model ACACConverter "AC AC converter three phase balanced systems"
          extends ProsNet.Electrical.AC.OnePhase.Conversion.ACACConverter(
              redeclare Interfaces.Terminal_n terminal_n, redeclare
              Interfaces.Terminal_p terminal_p);
          annotation (
          defaultComponentName="conACAC",
          Documentation(info="<html>
<p>
This model represents a simplified conversion between two AC
three-phase balanced systems. The conversion losses are represented by a
constant efficiency <i>&eta;</i>.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACConverter\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACConverter</a> for more
information.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 29, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACConverter;

        model ACACTransformer "AC AC transformer three phase balanced systems"
          extends ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer(
              redeclare Interfaces.Terminal_n terminal_n, redeclare
              Interfaces.Terminal_p terminal_p);
          annotation (
          defaultComponentName="traACAC",
          Documentation(info="<html>
<p>
Simple transformer model for three-phase
balanced AC systems. The model does not include core and
magnetic losses.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a> for more
information.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 29, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformer;

        model ACACTransformerFull
          "AC AC transformer full model for three phase balanced systems"
          extends ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull(
              redeclare Interfaces.Terminal_n terminal_n, redeclare
              Interfaces.Terminal_p terminal_p);
          annotation (
        defaultComponentName="traACAC",
        Documentation(info="<html>
<p>
Model of a transformer for three-phase
balanced AC systems. The model includes core and magnetic losses.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformerFull\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformerFull</a> for more
information.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 29, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformerFull;

        model ACDCConverter "AC DC converter"
          extends ProsNet.Electrical.AC.OnePhase.Conversion.ACDCConverter(
              redeclare Interfaces.Terminal_n terminal_n);

          annotation (
        defaultComponentName="conACDC",
        Documentation(info="<html>
<p>
This model represents a simplified conversion between a three-phase
balanced AC system and a DC systems.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACDCConverter\">
Buildings.Electrical.AC.OnePhase.Conversion.ACDCConverter</a> for more
information.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACDCConverter;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model ACACConverter
            "This example illustrates how to use the AC/AC converter model"
            extends Modelica.Icons.Example;

            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACConverter conACAC(eta=0.9,
                conversionFactor=120/480) "ACAC transformer"
              annotation (Placement(transformation(extent={{-10,0},{10,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=480) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-60,10})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive load(mode=
                  ProsNet.Electrical.Types.Load.VariableZ_P_input, V_nominal=
                  120) "Load model"
              annotation (Placement(transformation(extent={{24,0},{44,20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              duration=0.5,
              startTime=0.3,
              height=2000,
              offset=-1000) "Power consumed by the model"
              annotation (Placement(transformation(extent={{80,0},{60,20}})));
          equation
            connect(sou.terminal, conACAC.terminal_n) annotation (Line(
                points={{-50,10},{-10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(conACAC.terminal_p, load.terminal)     annotation (Line(
                points={{10,10},{24,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow) annotation (Line(
                points={{59,10},{44,10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of a model that converts AC voltage to AC voltage.
The transformer model assumes a linear loss when transmitting the power.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
Removed assignment of <code>load.P_nominal</code> as it is
not required and leads to dublicate assignments.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Conversion/Examples/ACACConverter.mos"
                  "Simulate and plot"));
          end ACACConverter;

          model ACACTransformer
            "This example illustrates how to use the AC/AC simplified transformer model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACTransformer
              tra_load(
              Zperc=0.03,
              VABase=4000,
              XoverR=8,
              VHigh=480,
              VLow=120) "Transformer with load"
              annotation (Placement(transformation(extent={{-18,40},{2,60}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=480) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,50})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive load(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              pf=0.8,
              V_nominal=120) "Load model"
              annotation (Placement(transformation(extent={{10,40},{30,60}})));
            Modelica.Blocks.Sources.Ramp ramp(
              duration=0.5,
              startTime=0.3,
              offset=0,
              height=-4000*0.8) "Load power consumption profile"
              annotation (Placement(transformation(extent={{70,40},{50,60}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACTransformer
              tra_cc(
              XoverR=8,
              Zperc=0.03,
              VABase=4000,
              VHigh=480,
              VLow=120) "Transformer with short circuit"
              annotation (Placement(transformation(extent={{-16,0},{4,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Impedance shortCircuit(R=1e-8)
              "Short circuit"
              annotation (Placement(transformation(extent={{10,0},{30,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACTransformer
              tra_void(
              XoverR=8,
              Zperc=0.03,
              VABase=4000,
              VHigh=480,
              VLow=120) "Transformer with secondary not connected" annotation (
                Placement(transformation(extent={{-16,-30},{4,-10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou1(
              definiteReference=true,
              f=60,
              V=480) "Voltage source for open and short circuit tests"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    origin={-70,10})));
          equation
            connect(sou.terminal, tra_load.terminal_n)
                                                      annotation (Line(
                points={{-60,50},{-18,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(tra_load.terminal_p, load.terminal)    annotation (Line(
                points={{2,50},{10,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow) annotation (Line(
                points={{49,50},{30,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(tra_cc.terminal_p, shortCircuit.terminal) annotation (Line(
                points={{4,10},{10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_cc.terminal_n) annotation (Line(
                points={{-60,10},{-16,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_void.terminal_n) annotation (Line(
                points={{-60,10},{-38,10},{-38,-20},{-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of the AC/AC transformer model.
The example shows three different configurations:
</p>
<ul>
<li>With a load connected,</li>
<li>without a load connected, and</li>
<li>with a short circuit connection.</li>
</ul>
</html>",              revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
Removed assignment of <code>load.P_nominal</code> as it is
not required and leads to dublicate assignments.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Conversion/Examples/ACACTransformer.mos"
                  "Simulate and plot"));
          end ACACTransformer;

          model ACACTransformerFull
            "This example illustrates how to use the AC/AC transformer model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACTransformerFull
              tra_load(
              R1=0.0001,
              L1=0.0001,
              R2=0.0001,
              L2=0.0001,
              VABase=4000,
              magEffects=true,
              Rm=10,
              Lm=10,
              VHigh=480,
              VLow=120,
              f=60) "Transformer with load"
              annotation (Placement(transformation(extent={{-18,40},{2,60}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=480) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-70,50})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive load(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              pf=0.8,
              V_nominal=120) "Load"
              annotation (Placement(transformation(extent={{10,40},{30,60}})));
            Modelica.Blocks.Sources.Ramp ramp(
              duration=0.5,
              startTime=0.3,
              offset=0,
              height=-4000*0.8) "Load power consumption profile"
              annotation (Placement(transformation(extent={{70,40},{50,60}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACTransformerFull
              tra_cc(
              VABase=4000,
              R1=0.01,
              L1=0.01,
              R2=0.01,
              L2=0.01,
              magEffects=false,
              Rm=100,
              Lm=100,
              VHigh=480,
              VLow=120,
              f=60) "Transformer with short circuit connection"
              annotation (Placement(transformation(extent={{-16,0},{4,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Impedance shortCircuit(R=1e-8)
              "Short circuit"
              annotation (Placement(transformation(extent={{10,0},{30,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACACTransformerFull
              tra_void(
              VABase=4000,
              R1=0.01,
              L1=0.01,
              R2=0.01,
              L2=0.01,
              magEffects=false,
              Rm=100,
              Lm=100,
              VHigh=480,
              VLow=120,
              f=60) "Transformer with open connection" annotation (Placement(
                  transformation(extent={{-16,-30},{4,-10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou1(
              definiteReference=true,
              f=60,
              V=480) "Voltage source for short circuit and open tests"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                    origin={-70,10})));
          equation
            connect(sou.terminal, tra_load.terminal_n)
              annotation (Line(
                points={{-60,50},{-18,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(tra_load.terminal_p, load.terminal)    annotation (Line(
                points={{2,50},{10,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow) annotation (Line(
                points={{49,50},{30,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(tra_cc.terminal_p, shortCircuit.terminal) annotation (Line(
                points={{4,10},{10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_cc.terminal_n) annotation (Line(
                points={{-60,10},{-16,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou1.terminal, tra_void.terminal_n) annotation (Line(
                points={{-60,10},{-38,10},{-38,-20},{-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of the AC/AC transformer model
that includes losses at the primary and secondary side and magnetization
effects.
The example shows three different configurations:
</p>
<ul>
<li>With a load connected,</li>
<li>without a load connected, and</li>
<li>with a short circuit connection.</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
Removed assignment of <code>load.P_nominal</code> as it is
not required and leads to dublicate assignments.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Conversion/Examples/ACACTransformerFull.mos"
                  "Simulate and plot"));
          end ACACTransformerFull;

          model ACDCConverter
            "This example illustrates how to use the AC/DC converter model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.DC.Loads.Resistor res(
              R=1,
              V_nominal=120,
              i(each start=0)) "Resistive load" annotation (Placement(
                  transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={50,10})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Conversion.ACDCConverter conversion(
              eta=0.9,
              ground_AC=false,
              ground_DC=true,
              conversionFactor=120/480) "AC/DC transformer"
              annotation (Placement(transformation(extent={{-10,0},{10,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou(
              definiteReference=true,
              f=60,
              V=480) "Voltage source" annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}}, origin={-62,10})));
            ProsNet.Electrical.DC.Loads.Conductor load(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
                V_nominal=120) "Variable resistive load" annotation (Placement(
                  transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={50,-10})));
            Modelica.Blocks.Sources.Ramp pow(
              duration=0.5,
              startTime=0.2,
              offset=-200,
              height=5200) "Variable load profile"
              annotation (Placement(transformation(extent={{90,-20},{70,0}})));
          equation
            connect(sou.terminal, conversion.terminal_n) annotation (Line(
                points={{-52,10},{-10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(conversion.terminal_p, res.terminal) annotation (Line(
                points={{10,10},{40,10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(conversion.terminal_p, load.terminal) annotation (Line(
                points={{10,10},{30,10},{30,-10},{40,-10}},
                color={0,0,255},
                smooth=Smooth.None));
            connect(pow.y, load.Pow) annotation (Line(
                points={{69,-10},{60,-10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation ( experiment(StopTime=1.0, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This example illustrates the use of a model that converts AC voltage to DC voltage.
The transformer model assumes a linear loss when transmitting the power.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
Removed assignment of <code>load.P_nominal</code> as it is
not required and leads to dublicate assignments.
</li>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Conversion/Examples/ACDCConverter.mos"
                  "Simulate and plot"));
          end ACDCConverter;
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>",         info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Conversion\">
Buildings.Electrical.AC.ThreePhasesBalanced.Conversion</a>.
</p>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for three-phase balanced AC/AC
transformers and AC/DC converters.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Conversion;

      package Lines "Package with line models for three-phase balanced AC systems"
        extends Modelica.Icons.Package;

        model Line "Model of an electrical line"
          extends ProsNet.Electrical.AC.OnePhase.Lines.Line(
            redeclare Interfaces.Terminal_n terminal_n,
            redeclare Interfaces.Terminal_p terminal_p,
            V_nominal(start=480),
            redeclare TwoPortRLC line(
              R=R,
              L=L,
              C=C,
              V_nominal=V_nominal));

          annotation (
            defaultComponentName="line",
         Icon(graphics={
                Ellipse(
                  extent={{-70,10},{-50,-10}},
                  lineColor={0,0,0},
                  fillColor={11,193,87},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,10},{60,-10}},
                  fillColor={11,193,87},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{50,10},{70,-10}},
                  lineColor={0,0,0},
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-70,0},{-90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,10},{60,10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,-10},{60,-10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{96,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a cable for three-phase balanced AC systems. The model is based on
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortRLC\">
Buildings.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortRLC</a>
and provides functionalities to parametrize the values of <i>R</i>, <i>L</i> and <i>C</i> either
using commercial cables or using default values.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines.Line\">
Buildings.Electrical.AC.OnePhase.Lines.Line</a> for more
information.
</p>
</html>"));
        end Line;

        model Network "Three phases balanced AC network"
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialNetwork(
            V_nominal(start=480),
            redeclare Interfaces.Terminal_p terminal,
            redeclare replaceable Transmission.Grids.TestGrid2Nodes grid,
            redeclare Lines.Line lines(redeclare replaceable
                ProsNet.Electrical.Transmission.LowVoltageCables.Generic
                commercialCable=grid.cables));
          Modelica.Units.SI.Voltage VAbs[grid.nNodes] "RMS voltage of the grid nodes";
        equation
          for i in 1:grid.nLinks loop
            connect(lines[i].terminal_p, terminal[grid.fromTo[i,1]]);
            connect(lines[i].terminal_n, terminal[grid.fromTo[i,2]]);
          end for;

          for i in 1:grid.nNodes loop
            VAbs[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].v);
          end for;

          annotation (
            defaultComponentName="net",
            Icon(graphics={             Line(
                  points={{-98,-60},{-78,-20},{-58,-60},{-38,-100},{-18,-60}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),          Line(
                  points={{-88,-60},{-68,-20},{-48,-60},{-28,-100},{-8,-60}},
                  color={120,120,120},
                  smooth=Smooth.Bezier),          Line(
                  points={{-78,-60},{-58,-20},{-38,-60},{-18,-100},{2,-60}},
                  color={215,215,215},
                  smooth=Smooth.Bezier)}), Documentation(revisions="<html>
<ul>
<li>
March 30, 2015, by Michael Wetter:<br/>
Made <code>grid</code> replaceable. This error was caught by
the regression tests of OpenModelica.
</li>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Maintained replaceable the parameter <code>commercialCable</code> when redeclaring
the type of line.
</li>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a generalized electrical AC three-phase balanced network.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialNetwork\">
Buildings.Electrical.Transmission.BaseClasses.PartialNetwork</a>
for information about the network model.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.Grids.PartialGrid\">
Buildings.Electrical.Transmission.Grids.PartialGrid</a>
for more information about the topology of the network, such as
the number of nodes, how they are connected, and the length of each connection.
</p>
</html>"));
        end Network;

        model TwoPortInductance "Model of an inductance with two electrical ports"
          extends ProsNet.Electrical.AC.OnePhase.Lines.TwoPortInductance(
              redeclare Interfaces.Terminal_n terminal_n, redeclare
              Interfaces.Terminal_p terminal_p);
          annotation (
            defaultComponentName="lineL",
            Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Inductance that connects two AC three-phase
balanced interfaces. This model can be used to represent a
cable in a three-phase balanced AC system.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines.TwoPortInductance\">
Buildings.Electrical.AC.OnePhase.Lines.TwoPortInductance</a> for more
information.
</p>
</html>"));
        end TwoPortInductance;

        model TwoPortRL
          "Model of a resistive-inductive element with two electrical ports"
          extends ProsNet.Electrical.AC.OnePhase.Lines.TwoPortRL(redeclare
              Interfaces.Terminal_n terminal_n, redeclare Interfaces.Terminal_p
              terminal_p);
          annotation (
            defaultComponentName="lineRL",
            Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Resistive-inductive impedance that connects two AC three-phase
balanced interfaces. This model can be used to represent a
cable in a three-phase balanced AC system.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines.TwoPortRL\">
Buildings.Electrical.AC.OnePhase.Lines.TwoPortRL</a> for more
information.
</p>
</html>"));
        end TwoPortRL;

        model TwoPortRLC "Model of a RLC element with two electrical ports"
          extends ProsNet.Electrical.AC.OnePhase.Lines.TwoPortRLC(redeclare
              Interfaces.Terminal_n terminal_n, redeclare Interfaces.Terminal_p
              terminal_p);
          annotation (
            defaultComponentName="lineRLC",
            Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
RLC impedance that connects two AC three-phase
balanced interfaces. This model can be used to represent a
cable in a three-phase balanced AC system.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines.TwoPortRLC\">
Buildings.Electrical.AC.OnePhase.Lines.TwoPortRLC</a> for more
information.
</p>
</html>"));
        end TwoPortRLC;

        model TwoPortResistance "Model of a resistance with two electrical ports"
          extends ProsNet.Electrical.AC.OnePhase.Lines.TwoPortResistance(
              redeclare Interfaces.Terminal_n terminal_n, redeclare
              Interfaces.Terminal_p terminal_p);
          annotation (
            defaultComponentName="lineR",
            Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Resistance that connects two AC three-phase
balanced interfaces. This model can be used to represent a
cable in a three-phase balanced AC system.
</p>
<p>
See model
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Lines.TwoPortResistance\">
Buildings.Electrical.AC.OnePhase.Lines.TwoPortResistance</a> for more
information.
</p>
</html>"));
        end TwoPortResistance;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model ACLine "Test model for single phase lines that use commercial cables"
            extends Modelica.Icons.Example;
            ThreePhasesBalanced.Sources.FixedVoltage E(definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            ThreePhasesBalanced.Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            ThreePhasesBalanced.Lines.Line line_1(
              P_nominal=5000,
              l=2000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              V_nominal=480) "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            ThreePhasesBalanced.Lines.Line line_2a(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=1000,
              V_nominal=480) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            ThreePhasesBalanced.Loads.Impedance R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            ThreePhasesBalanced.Lines.Line line_2b(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=1000,
              V_nominal=480) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-32,-30},{-12,-10}})));
            ThreePhasesBalanced.Lines.Line line_3a(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=4000,
              V_nominal=480) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            ThreePhasesBalanced.Lines.Line line_3b(
              P_nominal=5000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              l=4000,
              V_nominal=480) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-70},{-40,-50}})));
            ThreePhasesBalanced.Loads.Impedance R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
            ThreePhasesBalanced.Lines.Line line_sc(
              P_nominal=5000,
              l=2000,
              mode=Types.CableMode.commercial,
              commercialCable=Transmission.LowVoltageCables.Cu50(),
              V_nominal=480) "Line that connects the source and the short circuit"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            ThreePhasesBalanced.Loads.Impedance load_sc(R=0) "Short circuit"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
          equation
            connect(line_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,0},{-24,0},{-24,6.66134e-16},{-4.44089e-16,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_1.terminal_n) annotation (Line(
                points={{-80,4.44089e-16},{-60,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_2a.terminal_n) annotation (Line(
                points={{-80,4.44089e-16},{-70,4.44089e-16},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2a.terminal_p, line_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-32,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-12,-20},{0,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-40},{-20,-40},{-20,-50},{0,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-60},{-20,-60},{-20,-50},{-5.55112e-16,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-40},{-60,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-60},{-60,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_sc.terminal_p, load_sc.terminal) annotation (Line(
                points={{-40,30},{-4.44089e-16,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACLine.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a line model to connect
a source to a load that uses commercial cables.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the impedance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations.
However, the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>
</html>"));
          end ACLine;

          model ACLineMedium
            "Test model for a single phase line that uses medium voltage commercial cable information "
            extends Modelica.Icons.Example;
            ThreePhasesBalanced.Sources.FixedVoltage E(definiteReference=true, V=15000,
              f=60) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            ThreePhasesBalanced.Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            ThreePhasesBalanced.Lines.Line line_1(
              P_nominal=5000,
              l=2000,
              redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                    commercialCable = ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10(),
              V_nominal=15000) "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-58,-10},{-38,10}})));
            ThreePhasesBalanced.Lines.Line line_2a(
              P_nominal=5000,
              l=1000,
              redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                    commercialCable = ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10(),
              V_nominal=15000) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            ThreePhasesBalanced.Loads.Impedance R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            ThreePhasesBalanced.Lines.Line line_2b(
              P_nominal=5000,
              l=1000,
              redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                    commercialCable = ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10(),
              V_nominal=15000) "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-32,-30},{-12,-10}})));
            ThreePhasesBalanced.Lines.Line line_3a(
              P_nominal=5000,
              l=4000,
              redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                    commercialCable = ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10(),
              V_nominal=15000) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            ThreePhasesBalanced.Lines.Line line_3b(
              P_nominal=5000,
              l=4000,
              redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                    commercialCable = ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10(),
              V_nominal=15000) "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-70},{-40,-50}})));
            ThreePhasesBalanced.Loads.Impedance R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
            ThreePhasesBalanced.Lines.Line line_sc(
              P_nominal=5000,
              l=2000,
              redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                    commercialCable = ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10(),
              V_nominal=15000) "Line that connects the source and the short circuit"
              annotation (Placement(transformation(extent={{-58,20},{-38,40}})));
            ThreePhasesBalanced.Loads.Impedance load_sc(R=0) "Short circuit"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
          equation
            connect(line_1.terminal_p, R1.terminal) annotation (Line(
                points={{-38,0},{-24,0},{-24,6.66134e-16},{-4.44089e-16,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_1.terminal_n) annotation (Line(
                points={{-80,4.44089e-16},{-58,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_2a.terminal_n) annotation (Line(
                points={{-80,4.44089e-16},{-70,4.44089e-16},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2a.terminal_p, line_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-32,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-12,-20},{0,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-40},{-20,-40},{-20,-50},{0,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-60},{-20,-60},{-20,-50},{-5.55112e-16,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-40},{-60,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-60},{-60,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_sc.terminal_p, load_sc.terminal) annotation (Line(
                points={{-38,30},{-4.44089e-16,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-58,30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACLineMedium.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Documentation and example added.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a line model to connect
a source to a load that uses medium voltage commercial cable information.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the impedance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations,
however the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>

<h4>Note:</h4>

<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">ThreePhasesBalanced.Lines.Line</span>
<span style=\" font-family:'Courier New,courier';\"> line_1(</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">    V_nominal=220,</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">    P_nominal=5000,</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">    l=2000,</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">redeclare </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.Electrical.Transmission.MediumVoltageCables.Generic</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">          commercialCable =</span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\"> Buildings.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10</span>
<span style=\" font-family:'Courier New,courier';\">()) </span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#006400;\">    &quot;Resistive line that connects to load 1&quot;</span>
</p>

<p>
The code snippet shows how a line model <code>line_1</code> redeclared its
record type in order to be <code>Buildings.Electrical.Transmission.MediumVoltageCables.Generic</code>.
</p>

</html>"));
          end ACLineMedium;

          model ACLine_L "Test model for single phase inductive lines"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Inductance Lbase=10/2/Modelica.Constants.pi/60
              "Base value for the line inductances";
            ThreePhasesBalanced.Sources.FixedVoltage E(definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            ThreePhasesBalanced.Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            ThreePhasesBalanced.Loads.Impedance R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            ThreePhasesBalanced.Loads.Impedance R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-62},{20,-42}})));
            ThreePhasesBalanced.Loads.Impedance load_sc(R=0) "Short circuit"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            ThreePhasesBalanced.Lines.TwoPortInductance Lline_sc(L=Lbase)
              "Inductive line connected to the short circuit"
              annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
            ThreePhasesBalanced.Lines.TwoPortInductance Lline_1(L=Lbase)
              "Inductive line connected to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            ThreePhasesBalanced.Lines.TwoPortInductance Lline_2a(L=0.5*Lbase)
              "Inductive line connected to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            ThreePhasesBalanced.Lines.TwoPortInductance Lline_2b(L=0.5*Lbase)
              "Inductive line connected to load 2"
              annotation (Placement(transformation(extent={{-36,-30},{-16,-10}})));
            ThreePhasesBalanced.Lines.TwoPortInductance Lline_3(L=2*Lbase)
              "Inductive line connected to load 3"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            ThreePhasesBalanced.Lines.TwoPortInductance Lline_3b(L=2*Lbase)
              "Inductive line connected to load 3"
              annotation (Placement(transformation(extent={{-60,-70},{-40,-50}})));
          equation
            connect(E.terminal, Lline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_sc.terminal_p, load_sc.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_2a.terminal_p, Lline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-36,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-16,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_3.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-40},{-60,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Lline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-60},{-60,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_3.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-40},{-20,-40},{-20,-52},{0,-52}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-60},{-20,-60},{-20,-52},{0,-52}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-06),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACLine_L.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a purely inductive line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the inductance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations.
However, the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>"));
          end ACLine_L;

          model ACLine_R "Test model for single phase resistive lines"
            extends Modelica.Icons.Example;
            ThreePhasesBalanced.Sources.FixedVoltage E(definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            ThreePhasesBalanced.Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            ThreePhasesBalanced.Loads.Impedance R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            ThreePhasesBalanced.Loads.Impedance R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            ThreePhasesBalanced.Loads.Impedance sc_load(R=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            ThreePhasesBalanced.Lines.TwoPortResistance Rline_sc(R=10, useHeatPort=false)
              "Resistive line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            ThreePhasesBalanced.Lines.TwoPortResistance Rline_1(R=10)
              "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            ThreePhasesBalanced.Lines.TwoPortResistance Rline_2a(R=5)
              "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            ThreePhasesBalanced.Lines.TwoPortResistance Rline_2b(R=5)
              "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-36,-30},{-16,-10}})));
            ThreePhasesBalanced.Lines.TwoPortResistance Rline_3a(R=20)
              "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            ThreePhasesBalanced.Lines.TwoPortResistance Rline_3b(R=20)
              "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(E.terminal, Rline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-36,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-16,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACLine_R.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a resistive line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the resistance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations.
However, the equivalent resistance between each load and the source is the same.
Since the equivalent resistances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>"));
          end ACLine_R;

          model ACLine_RL "Test model for single phase inductive-resistive lines"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Resistance Rbase=10
              "Base value for the line resistance";
            parameter Modelica.Units.SI.Inductance Lbase=Rbase/2/Modelica.Constants.pi/60
              "Base value for the line inductance";
            ThreePhasesBalanced.Sources.FixedVoltage E(definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            ThreePhasesBalanced.Loads.Impedance load_sc_1(R=0) "Short circuit 1"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            ThreePhasesBalanced.Loads.Impedance load_sc_2(R=0) "Short circuit 2"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            ThreePhasesBalanced.Lines.TwoPortRL RL_2(R=Rbase, L=Lbase)
              "Resistive-Inductive line connected to short circuit 2"
              annotation (Placement(transformation(extent={{-48,-10},{-28,10}})));
            ThreePhasesBalanced.Lines.TwoPortResistance R_1(R=Rbase)
              "Resistance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            ThreePhasesBalanced.Lines.TwoPortInductance L_1(L=Lbase)
              "Inductance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-30,20},{-10,40}})));
            ThreePhasesBalanced.Lines.TwoPortRL RL_3(
              R=Rbase,
              L=Lbase,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic)
              "Dynamic resistive-inductive line connected to short circuit 3"
              annotation (Placement(transformation(extent={{-48,-40},{-28,-20}})));
            ThreePhasesBalanced.Loads.Impedance load_sc_3(R=0) "Short circuit 3"
              annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          equation
            connect(E.terminal, R_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(R_1.terminal_p, L_1.terminal_n) annotation (Line(
                points={{-40,30},{-30,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(L_1.terminal_p, load_sc_1.terminal) annotation (Line(
                points={{-10,30},{0,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_2.terminal_n) annotation (Line(
                points={{-80,0},{-48,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RL_2.terminal_p, load_sc_2.terminal) annotation (Line(
                points={{-28,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_3.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-30},{-48,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RL_3.terminal_p, load_sc_3.terminal) annotation (Line(
                points={{-28,-30},{0,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (  experiment(StopTime=1.0,Tolerance=1e-6),
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACLine_RL.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a resistive-inductive line model to connect
a source to a load.
</p>
<p>
The model has three loads <code>load_sc_1</code>, <code>load_sc_2</code>,
and <code>load_sc_3</code> representing short circuits <i>R=0</i>.
The current that flows through the load depends on the impedance of the line.
</p>
<p>
Each load is connected to the source with different configurations.
However, the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>
<p>
<b>Note:</b>
The line model <code>RL_3</code> is the same as <code>RL_2</code> but it uses
dynamic phasors.
</p>
</html>"));
          end ACLine_RL;

          model ACSimpleGrid "Test model for a network model"
            extends Modelica.Icons.Example;
            ThreePhasesBalanced.Lines.Network network(
              redeclare ProsNet.Electrical.Transmission.Grids.TestGrid2Nodes   grid,
                V_nominal=480)
              "Network model that represents the connection between the source and the load"
              annotation (Placement(transformation(extent={{20,-10},{0,10}})));
            ThreePhasesBalanced.Loads.Inductive load(
              P_nominal=2500,
              mode=Types.Load.VariableZ_P_input,
              V_nominal=480) "Load connected to the network"
              annotation (Placement(transformation(extent={{-28,10},{-48,30}})));
            ThreePhasesBalanced.Sources.FixedVoltage E(f=60, V=480) "Voltage source"
             annotation (Placement(
                  transformation(
                  extent={{10,10},{-10,-10}},
                  rotation=180,
                  origin={-70,0})));
            Modelica.Blocks.Sources.Ramp load_inputs(
              height=5000,
              duration=2,
              offset=-2000,
              startTime=0.5) "Input signal for the power consumption of the loads"
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          equation
            connect(load.terminal, network.terminal[2]) annotation (Line(
                points={{-28,20},{-20,20},{-20,4.44089e-16},{-4.44089e-16,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, network.terminal[1]) annotation (Line(
                points={{-60,-1.33227e-15},{-56,-1.33227e-15},{-56,4.44089e-16},{
                    -4.44089e-16,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow) annotation (Line(
                points={{-59,30},{-54,30},{-54,20},{-48,20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
          __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACSimpleGrid.mos"
                  "Simulate and plot"),
          Documentation(revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a network model to connect
a source to a load. In this simple case the network has two nodes
that are connected by a commercial line cable.
</p>
<p>
At the beginning of the simulation the load consumes power while at the
and it produces power. The voltage at the load at the beginning is lower
than the nominal RMS voltage (480 V) while at the end of the simulation it is higher.
The voltage drop and increase are due to the presence of the cable between
the source and the load.
</p>
<p>
The network uses cables of the type <code>LowVoltageCable.Cu35</code> with
a length of <i>200</i> m.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
</html>"));
          end ACSimpleGrid;

          model ACSimpleGridMedium "Test model for a network model with medium voltage"
            extends Modelica.Icons.Example;
            ThreePhasesBalanced.Lines.Network network(
                redeclare ProsNet.Electrical.Transmission.Grids.TestGrid2NodesMedium   grid,
                lines(redeclare
                  ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
                  commercialCable = network.grid.cables,
                  each V_nominal = network.V_nominal),
              V_nominal=15000)
              "Network model that represents the connection between the source and the load"
              annotation (Placement(transformation(extent={{20,-10},{0,10}})));
            ThreePhasesBalanced.Loads.Inductive load(mode=Types.Load.VariableZ_P_input,
              P_nominal=250000,
              V_nominal=15000) "Load connected to the network"
              annotation (Placement(transformation(extent={{-28,10},{-48,30}})));
            ThreePhasesBalanced.Sources.FixedVoltage E(V=15000, f=60) "Voltage source"
                                                                        annotation (Placement(
                  transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={-70,0})));
            Modelica.Blocks.Sources.Ramp load_inputs(
              height=5000,
              duration=2,
              offset=-2000,
              startTime=0.5) "Input signal for the power consumption of the loads"
              annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          equation
            connect(load.terminal, network.terminal[2]) annotation (Line(
                points={{-28,20},{-20,20},{-20,4.44089e-16},{-4.44089e-16,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, network.terminal[1]) annotation (Line(
                points={{-60,-8.88178e-16},{-56,-8.88178e-16},{-56,4.44089e-16},{-4.44089e-16,
                    4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow) annotation (Line(
                points={{-59,30},{-54,30},{-54,20},{-48,20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
          __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Lines/Examples/ACSimpleGridMedium.mos"
                  "Simulate and plot"),
          Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Documentation and example added.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a network model to connect
a source to a load (using a medium voltage cable). In this simple case the network has two nodes
that are connected by a commercial line cable.
</p>
<p>
At the beginning of the simulation the load consumes power while at the
end it produces power. The voltage at the load at the beginning is lower
than the nominal RMS voltage (15 kV) while at the end of the simulation it is higher.
The voltage drop and increase are due to the presence of the cable between
the source and the load.
</p>
<p>
The network uses cables of the type <code>MediumVoltageCables.Annealed_Al_30</code> with
a length of <i>200</i> m.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
<h4>Note:</h4>
<p>
The cables are usually defined using the <code>LowVoltageCable.Generic</code> type. In order to use a
medium voltage cable it is necessary to redeclare the type of the record <code>commercialCable</code>.
</p>

<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">ThreePhasesBalanced.Lines.Network</span>
<span style=\" font-family:'Courier New,courier';\"> network(</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">redeclare </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.Electrical.Transmission.Grids.TestGrid2NodesMedium</span>
<span style=\" font-family:'Courier New,courier';\"> grid,</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">      lines(</span>
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">redeclare </span>
<span style=\" font-family:'Courier New,courier'; color:#ff0000;\">Buildings.Electrical.Transmission.MediumVoltageCables.Generic</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">        commercialCable = network.grid.cables,</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier'; color:#0000ff;\">each </span>
<span style=\" font-family:'Courier New,courier';\">V_nominal = network.V_nominal),</span>
</p>
<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; -qt-user-state:8;\">
<span style=\" font-family:'Courier New,courier';\">    V_nominal=15000) </span>
</p>

<p>
The code snippet shows how each line that is part of the vector <code>lines</code> is
redeclared in order to have as type the record
<code>Buildings.Electrical.Transmission.MediumVoltageCables.Generic</code>. The lines are initialized
using the cables of the grid <code>network.grid.cables</code>. All the lines have the same
nominal voltage <code>each V_nominal = network.V_nominal</code>.
</p>
</html>"));
          end ACSimpleGridMedium;
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>",         info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Lines\">
Buildings.Electrical.AC.ThreePhasesBalanced.Lines</a>.
</p>
</html>"));
        end Examples;
        annotation (Icon(graphics={
            Ellipse(
              extent={{44,6},{20,-30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{32,6},{-50,6},{-60,6},{-68,-12},{-60,-30},{-48,-30},{32,-30}},
              color={0,0,0},
              smooth=Smooth.Bezier),
            Line(
              points={{-66,-12},{-84,-12}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{58,-12},{32,-12}},
              color={0,0,0},
              smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package contains models for transmission lines and electrical networks.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Lines;

      package Loads "Package with load models for three-phase balanced AC systems"
        extends Modelica.Icons.VariantsPackage;

        model Capacitive "Model of a capacitive and resistive load"
          extends ProsNet.Electrical.AC.OnePhase.Loads.Capacitive(redeclare
              Interfaces.Terminal_n terminal, V_nominal(start=480));
          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),      graphics={
                Rectangle(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(points={{-2,-2.44921e-16},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,1},
                  rotation=90),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{44,5.38825e-15}},
                                                 color={0,0,0},
                  origin={60,50},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,51},
                  rotation=90),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,-51},
                  rotation=90),
                Line(
                  points={{60,50},{76,0},{60,-52}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,-52},
                  rotation=180),
                Line(
                  points={{10,68},{10,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{16,68},{16,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{60,7.34764e-15}},
                                                 color={0,0,0},
                  origin={76,0},
                  rotation=180),
                Line(
                  points={{16,18},{16,-18}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{10,18},{10,-18}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{44,5.38825e-15}},
                                                 color={0,0,0},
                  origin={60,-52},
                  rotation=180),
                Line(
                  points={{16,-34},{16,-70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{10,-34},{10,-70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,-52},
                  rotation=180)}),       Documentation(info="<html>
<p>
Model of a capacitive load. See
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Capacitive\">
Buildings.Electrical.AC.OnePhase.Loads.Capacitive</a> for more information.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Capacitive;

        model Impedance "Model of a resistive load"
          extends ProsNet.Electrical.Interfaces.Impedance(redeclare package
              PhaseSystem = PhaseSystems.OnePhase, redeclare
              Interfaces.Terminal_n terminal);

          parameter Boolean star = true
            "Type of load connection: true = star, false = triangle" annotation(Evaluate=true, choices(
              choice=true "Star",
              choice=false "Triangle",
              __Dymola_radioButtons=true));

        protected
          Modelica.Units.SI.Angle theRef "Absolute angle of rotating reference system";
          Modelica.Units.SI.AngularVelocity omega
            "Frequency of the quasi-stationary sine waves";
          Modelica.Units.SI.Reactance X(start=1) "Complex component of the impedance";

        equation
          theRef = PhaseSystem.thetaRef(terminal.theta);
          omega = der(theRef);

          // Inductance of each line
          if inductive then
            X = omega*L_internal;
          else
            X = -1/(omega*C_internal);
          end if;

          // Ohm's law
          if star then
            terminal.v = {{R_internal,-X}*terminal.i, {X,R_internal}*terminal.i};
          else
            terminal.v = {{R_internal/3,-X/3}*terminal.i, {X/3,R_internal/3}*terminal.i};
          end if;
          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={7.10543e-15,7.10543e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,-80},{120,-120}},
                  textColor={0,0,0},
                  textString="%name"),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={2,49},
                  rotation=90),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={2,1},
                  rotation=90),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={2,-49},
                  rotation=90),
                Line(
                  visible=star == true,
                  points={{52,50},{68,0},{52,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(visible = star == true,
                  points={{68,0},{52,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-68,50},{-28,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-68,0},{-28,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-68,-50},{-28,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{32,50},{52,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{32,0},{52,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{32,-50},{52,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(visible = star == false,
                  points={{52,50},{52,36},{-50,14},{-50,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(visible = star == false,
                  points={{52,0},{52,-14},{-50,-36},{-50,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(visible = star == false,
                  points={{52,-50},{72,-50},{72,68},{-50,68},{-50,50}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
                  Documentation(info="<html>
<p>
Model of a three-phase balanced impedance.
</p>
<p>
If <code>inductive=true</code>, then the
inductance is a parameter, otherwise
the capacitance is a parameter.
</p>
<p>
The boolean parameter <code>star</code> is used to
select whether the star (Y) or triangle (D)
configuration is used to connect the impedance.
By default, the impedance is assumed to be connected
with a star configuration.
</p>
<p>
When the connection type changes from
<code>star</code> to <code>triangle</code>, the value of the impedance
is recomputed in such a way that the nominal power consumed by the impedance
does not change.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2016, by Michael Wetter:<br/>
Moved function call to <code>PhaseSystem.thetaRef</code> out of
derivative operator as this is not yet supported by JModelica.
</li>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Impedance;

        model Inductive "Model of an inductive and resistive load"
          extends ProsNet.Electrical.AC.OnePhase.Loads.Inductive(redeclare
              Interfaces.Terminal_n terminal, V_nominal(start=480));
          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}),
                                 graphics={
                Rectangle(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                           Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                Ellipse(extent={{-10,-10},{10,10}},
                  rotation=360),
                Ellipse(extent={{30,-10},{50,10}}),
                Ellipse(extent={{10,-10},{30,10}}),
                Rectangle(
                  extent={{-10,0},{50,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{26,3.18398e-15}},
                                                 color={0,0,0},
                  origin={76,0},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,1},
                  rotation=90),
                  Line(points={{-2,-2.44921e-16},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={0,50},
                  rotation=360),
                Ellipse(extent={{30,40},{50,60}}),
                Ellipse(extent={{10,40},{30,60}}),
                Rectangle(
                  extent={{-10,50},{50,38}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={60,50},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,51},
                  rotation=90),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={0,-52},
                  rotation=360),
                Ellipse(extent={{30,-62},{50,-42}}),
                Ellipse(extent={{10,-62},{30,-42}}),
                Rectangle(
                  extent={{-10,-52},{50,-64}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,-52},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={60,-52},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,-51},
                  rotation=90),
                Line(
                  points={{60,50},{76,0},{60,-52}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,-52},
                  rotation=180)}),    Documentation(info="<html>
<p>
Model of an inductive load. See
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Inductive\">
Buildings.Electrical.AC.OnePhase.Loads.Inductive</a> for more information.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Inductive;

        model Resistive "Model of a resistive load"
          extends ProsNet.Electrical.AC.OnePhase.Loads.Resistive(redeclare
              Interfaces.Terminal_n terminal, V_nominal(start=480));
          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={7.10543e-15,7.10543e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{-66,50},{-26,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,49},
                  rotation=90),
                Line(
                  points={{34,50},{54,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{54,50},{70,0},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{34,0},{70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,1},
                  rotation=90),
                Line(
                  points={{-66,0},{-26,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,-50},{-26,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,-49},
                  rotation=90),
                Line(
                  points={{34,-50},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
                  Documentation(info="<html>
<p>
Model of a resistive load. See
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Resistive\">
Buildings.Electrical.AC.OnePhase.Loads.Resistive</a> for more information.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Resistive;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model Impedances "Example that illustrates the use of the impedance models"
             extends Modelica.Icons.Example;
            Sources.FixedVoltage sou(f=60, V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
            Impedance Z1(R=0,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              star=true) "Impedance purely inductive"
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Impedance Z2(R=1, star=true) "Impedance purely resistive"
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            Impedance Z3(R=0,
              inductive=false,
              C=1/(2*Modelica.Constants.pi*60),
              star=true) "Impedance purely capacitive"
              annotation (Placement(transformation(extent={{-20,-20},{0,0}})));
            Impedance Z4(
              inductive=false,
              R=1,
              C=1/(2*Modelica.Constants.pi*60),
              star=true) "Impedance capacitive"
              annotation (Placement(transformation(extent={{-20,-50},{0,-30}})));
            Impedance Z5(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              star=true) "Impedance inductive"
              annotation (Placement(transformation(extent={{-20,-78},{0,-58}})));
          equation
            connect(sou.terminal, Z1.terminal) annotation (Line(
                points={{-60,-10},{-40,-10},{-40,50},{-20,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, Z2.terminal) annotation (Line(
                points={{-60,-10},{-40,-10},{-40,20},{-20,20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, Z3.terminal) annotation (Line(
                points={{-60,-10},{-20,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, Z4.terminal) annotation (Line(
                points={{-60,-10},{-40,-10},{-40,-40},{-20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, Z5.terminal) annotation (Line(
                points={{-60,-10},{-40,-10},{-40,-68},{-20,-68}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (Documentation(revisions="<html>
<ul>
<li>
September 22, 2014 by Marco Bonvini:<br/>
Added documentation and revised the example.
</li>
</ul>
</html>",           info="<html>
<p>
This model illustrates the use of the impedance models.
The impedances have unitary values such that the RMS value of the voltage and of the current are the same.
</p>
</html>"),    experiment(Tolerance=1e-6, StopTime=1.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Loads/Examples/Impedances.mos"
                  "Simulate and plot"));
          end Impedances;

          model ParallelLoads "Example that illustrates the use of the load models"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(f=60, V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
            Resistive R(P_nominal=-2000, V_nominal=480) "Resistive load"
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Inductive RL_pf(
              pf=0.8,
              P_nominal=-2000,
              use_pf_in=true,
              V_nominal=480) "Inductive load with variable power factor"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
            Modelica.Blocks.Sources.Ramp load(              startTime=0.2, duration=0.3)
              "Power signal profile"
              annotation (Placement(transformation(extent={{60,-50},{40,-30}})));
            Inductive varRL_y(                                   P_nominal=-2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_y_input)
              "Inductive load with y as input"
              annotation (Placement(transformation(extent={{-20,-36},{0,-16}})));
            Capacitive varRC_y(                                   P_nominal=-2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_y_input)
              "Capacitive load with y as input"
              annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
            Inductive varRL_P(pf=0.8,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input)
              "Inductive load with P as input"
              annotation (Placement(transformation(extent={{-20,14},{0,34}})));
            Modelica.Blocks.Sources.Ramp pow(
              startTime=0.2,
              duration=0.3,
              height=4000,
              offset=-2000) "Power consumption profile"
              annotation (Placement(transformation(extent={{60,14},{40,34}})));
            Modelica.Blocks.Sources.Ramp pf(
              height=0.2,
              duration=0.2,
              offset=0.8,
              startTime=0.7) "Power factor profile"
              annotation (Placement(transformation(extent={{60,-20},{40,0}})));
          equation
            connect(E.terminal, R.terminal) annotation (Line(
                points={{-60,4.44089e-16},{-40,4.44089e-16},{-40,50},{-20,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_pf.terminal) annotation (Line(
                points={{-60,4.44089e-16},{-40,4.44089e-16},{-40,0},{-20,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, varRL_y.terminal) annotation (Line(
                points={{-60,4.44089e-16},{-40,4.44089e-16},{-40,-26},{-20,-26}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, varRC_y.terminal) annotation (Line(
                points={{-60,4.44089e-16},{-40,4.44089e-16},{-40,-50},{-20,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, varRL_y.y) annotation (Line(
                points={{39,-40},{20,-40},{20,-26},{4.44089e-16,-26}},
                color={0,0,127},
                smooth=Smooth.None));

            connect(load.y, varRC_y.y) annotation (Line(
                points={{39,-40},{20,-40},{20,-50},{4.44089e-16,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(E.terminal, varRL_P.terminal) annotation (Line(
                points={{-60,4.44089e-16},{-40,4.44089e-16},{-40,24},{-20,24}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(pow.y, varRL_P.Pow) annotation (Line(
                points={{39,24},{4.44089e-16,24}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pf.y, RL_pf.pf_in) annotation (Line(
                points={{39,-10},{30,-10},{30,6},{4.44089e-16,6}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
September 22, 2014 by Marco Bonvini:<br/>
Added documentation and revised the example.
</li>
</ul>
</html>",           info="<html>
<p>
This model illustrates the use of the three-phase unbalanced load models.
</p>
</html>"),    experiment(Tolerance=1e-6, StopTime=1.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Loads/Examples/ParallelLoads.mos"
                  "Simulate and plot"));
          end ParallelLoads;

          model ThreePhases
            "Example that provides a comparison between AC one phase and three-phase balanced"
            extends Modelica.Icons.Example;
            Modelica.Units.SI.Power errorY=sqrt((sen_Y.S[1] - (sen_a.S[1] + sen_b.S[1] +
                sen_c.S[1]))^2 + (sen_Y.S[2] - (sen_a.S[2] + sen_b.S[2] + sen_c.S[2]))^2)
              "Difference of the power consumption in the star (Y) connection";
            Modelica.Units.SI.Power errorD=sqrt((sen_D.S[1] - (sen_ab.S[1] + sen_bc.S[1]
                 + sen_ca.S[1]))^2 + (sen_D.S[2] - (sen_ab.S[2] + sen_bc.S[2] + sen_ca.S[
                2]))^2)
              "Difference of the power consumption in the triangle (D) connection";
            Sources.FixedVoltage sou(definiteReference=true,
              f=60,
              V=480) "Three phases balanced voltage source"
              annotation (Placement(transformation(extent={{-60,50},{-40,70}})));
            Impedance RL_star(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance with Y connection"
              annotation (Placement(transformation(extent={{40,50},{60,70}})));
            OnePhase.Sources.FixedVoltage sou_a(V=480/sqrt(3), definiteReference=true,
              f=60) "Voltage source phase a"
              annotation (Placement(transformation(extent={{-90,-30},{-70,-10}})));
            OnePhase.Sources.FixedVoltage sou_b(
              V=480/sqrt(3),
              definiteReference=true,
              phiSou=2.0943951023932,
              f=60) "Voltage source phase b"
              annotation (Placement(transformation(extent={{-90,-60},{-70,-40}})));
            OnePhase.Sources.FixedVoltage sou_c(
              V=480/sqrt(3),
              definiteReference=true,
              phiSou=-2.0943951023932,
              f=60) "Voltage source phase c"
              annotation (Placement(transformation(extent={{-90,-90},{-70,-70}})));
            OnePhase.Loads.Impedance RL_a(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance on phase A"
              annotation (Placement(transformation(extent={{-40,-30},{-20,-10}})));
            OnePhase.Loads.Impedance RL_b(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance on phase B"
              annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
            OnePhase.Loads.Impedance RL_c(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance on phase C"
              annotation (Placement(transformation(extent={{-40,-90},{-20,-70}})));
            Impedance RL_tri(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60),
              star=false) "Impedance with D connection"
              annotation (Placement(transformation(extent={{40,20},{60,40}})));
            OnePhase.Sources.FixedVoltage sou_ab(
              V=480,
              phiSou=-0.5235987755983,
              definiteReference=true,
              f=60) "Voltage source line ab"
              annotation (Placement(transformation(extent={{10,-30},{30,-10}})));
            OnePhase.Sources.FixedVoltage sou_bc(
              phiSou=1.5707963267949,
              V=480,
              definiteReference=true,
              f=60) "Voltage source line bc"
              annotation (Placement(transformation(extent={{10,-60},{30,-40}})));
            OnePhase.Sources.FixedVoltage sou_ca(
              phiSou=-3.6651914291881,
              V=480,
              definiteReference=true,
              f=60) "Voltage source line ca"
              annotation (Placement(transformation(extent={{10,-90},{30,-70}})));
            OnePhase.Loads.Impedance RL_ab(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance on line AB"
              annotation (Placement(transformation(extent={{60,-30},{80,-10}})));
            OnePhase.Loads.Impedance RL_bc(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance on line BC"
              annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
            OnePhase.Loads.Impedance RL_c1(
              R=1,
              inductive=true,
              L=1/(2*Modelica.Constants.pi*60)) "Impedance on linease CA"
              annotation (Placement(transformation(extent={{60,-90},{80,-70}})));
            OnePhase.Sensors.GeneralizedSensor sen_a
              "Sensor located on phase A (Y connection)"
              annotation (Placement(transformation(extent={{-66,-30},{-46,-10}})));
            OnePhase.Sensors.GeneralizedSensor sen_ab
              "Sensor located on line AB (D connection)"
              annotation (Placement(transformation(extent={{34,-30},{54,-10}})));
            Sensors.GeneralizedSensor sen_Y "Sensor for Y connection (balanced case)"
              annotation (Placement(transformation(extent={{12,50},{32,70}})));
            Sensors.GeneralizedSensor sen_D "Sensor for D connection (balanced case)"
              annotation (Placement(transformation(extent={{12,20},{32,40}})));
            OnePhase.Sensors.GeneralizedSensor sen_b
              "Sensor located on phase B (Y connection)"
              annotation (Placement(transformation(extent={{-66,-60},{-46,-40}})));
            OnePhase.Sensors.GeneralizedSensor sen_c
              "Sensor located on phase C (Y connection)"
              annotation (Placement(transformation(extent={{-66,-90},{-46,-70}})));
            OnePhase.Sensors.GeneralizedSensor sen_bc
              "Sensor located on line BC (D connection)"
              annotation (Placement(transformation(extent={{34,-60},{54,-40}})));
            OnePhase.Sensors.GeneralizedSensor sen_ca
              "Sensor located on line CA (D connection)"
              annotation (Placement(transformation(extent={{34,-90},{54,-70}})));
          equation
            connect(sou_a.terminal, sen_a.terminal_n) annotation (Line(
                points={{-70,-20},{-66,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_a.terminal_p, RL_a.terminal) annotation (Line(
                points={{-46,-20},{-40,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou_ab.terminal, sen_ab.terminal_n) annotation (Line(
                points={{30,-20},{34,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_ab.terminal_p, RL_ab.terminal) annotation (Line(
                points={{54,-20},{60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, sen_Y.terminal_n) annotation (Line(
                points={{-40,60},{12,60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_Y.terminal_p, RL_star.terminal) annotation (Line(
                points={{32,60},{40,60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, sen_D.terminal_n) annotation (Line(
                points={{-40,60},{0,60},{0,30},{12,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_D.terminal_p, RL_tri.terminal) annotation (Line(
                points={{32,30},{40,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou_b.terminal, sen_b.terminal_n) annotation (Line(
                points={{-70,-50},{-66,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_b.terminal_p, RL_b.terminal) annotation (Line(
                points={{-46,-50},{-40,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou_c.terminal, sen_c.terminal_n) annotation (Line(
                points={{-70,-80},{-66,-80}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_c.terminal_p, RL_c.terminal) annotation (Line(
                points={{-46,-80},{-40,-80}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou_bc.terminal, sen_bc.terminal_n) annotation (Line(
                points={{30,-50},{34,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_bc.terminal_p, RL_bc.terminal) annotation (Line(
                points={{54,-50},{60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou_ca.terminal, sen_ca.terminal_n) annotation (Line(
                points={{30,-80},{34,-80}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen_ca.terminal_p, RL_c1.terminal) annotation (Line(
                points={{54,-80},{60,-80}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),        graphics={
                  Text(
                    extent={{-60,100},{60,80}},
                    textColor={0,0,0},
                    textString="Three phases, balanced (Y and D connection) "),
                  Text(
                    extent={{-100,10},{-4,-10}},
                    textColor={0,0,0},
                    textString="Three phases, balanced (Y connection) "),
                  Text(
                    extent={{4,10},{100,-10}},
                    textColor={0,0,0},
                    textString="Three phases, balanced (D connection) ")}), Documentation(
                  revisions="<html>
<ul>
<li>
September 22, 2014 by Marco Bonvini:<br/>
Added documentation and revised the example.
</li>
</ul>
</html>",           info="<html>
<p>
This model illustrates the use of the impedance models and how the three-phase balanced model
can reproduce the same results obtained using three separate one phase circuits.
</p>
</html>"),    experiment(Tolerance=1e-6, StopTime=1.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Loads/Examples/ThreePhases.mos"
                  "Simulate and plot"));
          end ThreePhases;
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>",         info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Loads\">
Buildings.Electrical.AC.ThreePhasesBalanced.Loads</a>.
</p>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models that represent different types of three
phases balanced AC loads.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Loads;

      package Sensors "Package with sensors models for three-phase balanced AC systems"
      extends Modelica.Icons.SensorsPackage;

        model GeneralizedSensor "Sensor for power, voltage and current"
          extends ProsNet.Electrical.Icons.GeneralizedSensor;
          extends ProsNet.Electrical.Interfaces.PartialTwoPort(
            redeclare package PhaseSystem_p = PhaseSystems.OnePhase,
            redeclare package PhaseSystem_n = PhaseSystems.OnePhase,
            redeclare Interfaces.Terminal_n terminal_n(redeclare package
                PhaseSystem = PhaseSystem_n),
            redeclare Interfaces.Terminal_p terminal_p(redeclare package
                PhaseSystem = PhaseSystem_p));
          Modelica.Blocks.Interfaces.RealOutput V(
            final quantity="ElectricPotential",
            final unit="V")=
              ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(  terminal_n.v)
            "Voltage"
              annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-50}),   iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-90})));
          Modelica.Blocks.Interfaces.RealOutput I(
            final quantity="ElectricCurrent",
            final unit="A")=
              ProsNet.Electrical.PhaseSystems.OnePhase.systemCurrent(  terminal_n.i)
            "Current"
              annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={60,-50}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={60,-90})));
          Modelica.Blocks.Interfaces.RealOutput S[PhaseSystems.OnePhase.n](
            each final quantity="Power",
            each final unit="W")=
              ProsNet.Electrical.PhaseSystems.OnePhase.phasePowers_vi(  v=terminal_n.v, i=terminal_n.i)
            "Phase powers"
              annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-50}),iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-90})));
        equation
          connect(terminal_n, terminal_p) annotation (Line(
              points={{-100,0},{2,0},{2,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (defaultComponentName="sen",
          Documentation(info="<html>
<p>
Ideal sensor that measures power, voltage and current.
The two components of the power <i>S</i> are the active and reactive power.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 24, 2014, by Michael Wetter:<br/>
Moved assignments outside of equation section to avoid mixing
textual and graphical modeling.
</li>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Fixed bug. The model was referencing the wrong PhaseSystem.
</li>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-120,-42},{0,-82}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="S")}));
        end GeneralizedSensor;

        model Probe "Model of a probe that measures RMS voltage and angle"
          extends OnePhase.Sensors.Probe(
          redeclare
              ProsNet.Electrical.AC.ThreePhasesBalanced.Interfaces.Terminal_n term,
          V_nominal(start=480));
          annotation (
          defaultComponentName="sen",
          Documentation(info="<html>
<p>
This model represents a probe that measures the RMS voltage and the angle
of the voltage phasor at a given point.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
        end Probe;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model GeneralizedSensor "Example model for generalized sensor"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sensors.GeneralizedSensor
              sen "Sensor model"
              annotation (Placement(transformation(extent={{-20,2},{0,22}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Capacitive loa(V_nominal
                =480, P_nominal=-100) "Constant load"
              annotation (Placement(transformation(extent={{40,2},{60,22}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou(f=60, V=
                  480) "Voltage source"
              annotation (Placement(transformation(extent={{-60,2},{-40,22}})));
          equation
            connect(sen.terminal_p, loa.terminal)
              annotation (Line(points={{5.55112e-16,12},{40,12}}, smooth=Smooth.None));
            connect(sen.terminal_n, sou.terminal)
              annotation (Line(points={{-20,12},{-40,12}}, smooth=Smooth.None));
            annotation (Documentation(
            info="<html>
<p>
This example illustrates the use of the generalized sensor.
</p>
</html>", revisions="<html>
<ul>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Sensors/Examples/GeneralizedSensor.mos"
                  "Simulate and plot"));
          end GeneralizedSensor;

          model Probe "This example illustrates how to use the probe model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Capacitive loaRC(
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              P_nominal=-10000,
              V_nominal=480) "Constant load"
              annotation (Placement(transformation(extent={{10,0},{30,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage sou(f=60, V=
                  480) "Voltage source" annotation (Placement(transformation(
                    extent={{-60,-30},{-40,-10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortResistance res1(R=0.1)
              "First line resistance"
              annotation (Placement(transformation(extent={{-26,0},{-6,20}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sensors.Probe probe_source(V_nominal
                =480) "Probe that measures at the voltage source" annotation (
                Placement(transformation(extent={{-50,30},{-30,50}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sensors.Probe probe_loadRC(V_nominal
                =480) "Probe that measures at the RC load"
              annotation (Placement(transformation(extent={{-10,30},{10,50}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortResistance res2(R=0.1)
              "Second line resistance" annotation (Placement(transformation(
                    extent={{-26,-70},{-6,-50}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive loaRL(
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              P_nominal=-10000,
              V_nominal=480) "Constant load" annotation (Placement(
                  transformation(extent={{10,-70},{30,-50}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sensors.Probe probe_loadRL(V_nominal
                =480) "Probe that measures at the RL load" annotation (
                Placement(transformation(extent={{-10,-28},{10,-8}})));
          equation
            connect(sou.terminal, res1.terminal_n) annotation (Line(
                points={{-40,-20},{-40,10},{-26,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(res1.terminal_p, loaRC.terminal) annotation (Line(
                points={{-6,10},{10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, probe_source.term) annotation (Line(
                points={{-40,-20},{-40,31}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(loaRC.terminal, probe_loadRC.term) annotation (Line(
                points={{10,10},{6.66134e-16,10},{6.66134e-16,31}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, res2.terminal_n) annotation (Line(
                points={{-40,-20},{-40,-60},{-26,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(res2.terminal_p, loaRL.terminal) annotation (Line(
                points={{-6,-60},{10,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(loaRL.terminal, probe_loadRL.term) annotation (Line(
                points={{10,-60},{6.66134e-16,-60},{6.66134e-16,-27}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            Documentation(
            info="<html>
<p>
This example illustrates the use of the probe model.
</p>
</html>", revisions="<html>
<ul>
<li>
August 5, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"),__Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Sensors/Examples/Probe.mos"
                  "Simulate and plot"));
          end Probe;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Sensors\">
Buildings.Electrical.AC.ThreePhasesBalanced.Sensors</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for voltage, current and power sensors.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Sensors;

      package Sources "Package with source models for three-phase balanced AC systems"
        extends Modelica.Icons.SourcesPackage;

        model FixedVoltage "Fixed three-phase balanced AC voltage source"
          extends ProsNet.Electrical.AC.OnePhase.Sources.FixedVoltage(
            redeclare Interfaces.Terminal_p terminal,
            f(start=60),
            V(start=480));
          annotation (
            defaultComponentName="fixVol",
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}),
                           graphics={             Line(
                  points={{-34,0},{-14,40},{6,0},{26,-40},{46,0}},
                  color={120,120,120},
                  smooth=Smooth.Bezier),          Line(
                  points={{-24,0},{-4,40},{16,0},{36,-40},{56,0}},
                  color={215,215,215},
                  smooth=Smooth.Bezier)}),
              Documentation(info="<html>
<p>
This is a constant voltage source, specifying the complex voltage
by the RMS voltage and the phase shift.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end FixedVoltage;

        model Generator "Model of a generator"
          extends ProsNet.Electrical.AC.OnePhase.Sources.Generator(redeclare
              Interfaces.Terminal_p terminal, f(start=60));
          annotation (
            defaultComponentName="gen",
            Documentation(info="<html>
<p>
Model of an inductive generator.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.Generator\">
Buildings.Electrical.AC.OnePhase.Sources.Generator</a> for
more information.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 4, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Generator;

        model Grid "Electrical grid"
          extends ProsNet.Electrical.AC.OnePhase.Sources.Grid(
            redeclare Interfaces.Terminal_p terminal,
            f(start=60),
            V(start=480),
            redeclare
              ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.FixedVoltage
              sou);

          annotation (
          defaultComponentName="gri",
            Documentation(info="<html>
<p>
Model that can be used to represent the electrical grid supply.
See <a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.Grid\">
Buildings.Electrical.AC.OnePhase.Sources.Grid</a> for
more information.
</p>
</html>",revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 2, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Grid;

        model PVSimple "Model of a simple PV panel"
          extends ProsNet.Electrical.AC.OnePhase.Sources.PVSimple(
            redeclare Interfaces.Terminal_p terminal,
            redeclare
              ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Capacitive load,
            V_nominal(start=480));

          annotation (
            defaultComponentName="pv",
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Model of a simple photovoltaic array.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimple\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimple</a> for
more information.
</p>
</html>"));
        end PVSimple;

        model PVSimpleOriented "Model of a simple PV panel with orientation"
          extends ProsNet.Electrical.AC.OnePhase.Sources.PVSimpleOriented(
            redeclare Interfaces.Terminal_p terminal,
            redeclare
              ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.PVSimple panel(
                V_nominal=V_nominal),
            V_nominal(start=480));

          annotation (
            defaultComponentName="pv",
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Model of a simple photovoltaic array.
</p>
<p>
This model takes as an input the direct and diffuse solar radiation from
the weather bus.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented</a> for
more information.
</p>
</html>"));
        end PVSimpleOriented;

        model WindTurbine "Model of a simple wind turbine generator"
          extends ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine(
            redeclare Interfaces.Terminal_p terminal,
            redeclare
              ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Capacitive load,
            V_nominal(start=480));
          annotation (
            defaultComponentName="winTur",
            Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Model of a wind turbine whose power is computed as a function of wind-speed as defined in a table.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.WindTurbine\">
Buildings.Electrical.AC.OnePhase.Sources.WindTurbine</a> for
more information.
</p>
</html>"));
        end WindTurbine;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model FixedVoltageSource
            "This example illustrates how using a fixed voltage source"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive RL(
              P_nominal=-300,
              mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              V_nominal=480) "Load model"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            ThreePhasesBalanced.Sources.FixedVoltage grid(
              f=60,
              V=480,
              phiSou=0.34906585039887) "AC one phase electrical grid"
              annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
            ThreePhasesBalanced.Sensors.Probe sen(V_nominal=480)
              "Probe that measures the voltage at the load"
              annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          equation
            connect(grid.terminal, RL.terminal)
                                               annotation (Line(
                points={{-20,4.44089e-16},{-20,0},{20,0},{20,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, sen.term) annotation (Line(
                points={{-20,6.66134e-16},{0,6.66134e-16},{0,21},{4.44089e-16,21}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Sources/Examples/FixedVoltageSource.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a fixed voltage generator model.
</p>
</html>"));
          end FixedVoltageSource;

          model PVPanels "This example illustrates how to use PV panel models"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive RL(
              mode=Types.Load.VariableZ_y_input,
              P_nominal=-2000,
              V_nominal=480) "Load taht consumes the power generted by the PVs"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.Grid grid(f=60, V=
                  480) "Electrical grid model" annotation (Placement(
                  transformation(extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Sources.Constant  load(k=0.5) "Load consumption"
              annotation (Placement(transformation(extent={{78,-50},{58,-30}})));
            Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Diffuse irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,72},{-32,92}})));
            Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Direct irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,32},{-32,52}})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false, filNam=
                  Modelica.Utilities.Files.loadResource(
                  "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              annotation (Placement(transformation(extent={{-100,72},{-80,92}})));
            Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
              annotation (Placement(transformation(extent={{-12,52},{8,72}})));
            ThreePhasesBalanced.Sources.PVSimple pvSimple(A=10, V_nominal=480)
              "PV array simplified"
              annotation (Placement(transformation(extent={{40,0},{60,20}})));
            ThreePhasesBalanced.Sources.PVSimpleOriented pvOriented(
              A=10,
              V_nominal=480,
              til=0.34906585039887,
              azi=-0.78539816339745) "PV array oriented"
              annotation (Placement(transformation(extent={{-10,0},{10,20}})));
          equation
            connect(grid.terminal, RL.terminal)
                                               annotation (Line(
                points={{-50,-20},{-50,-40},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, RL.y)
                                 annotation (Line(
                points={{57,-40},{40,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(weaDat.weaBus,HDifTil. weaBus) annotation (Line(
                points={{-80,82},{-52,82}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaDat.weaBus,HDirTil. weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,42},{-52,42}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(HDifTil.H,G. u1) annotation (Line(
                points={{-31,82},{-24,82},{-24,68},{-14,68}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(HDirTil.H,G. u2) annotation (Line(
                points={{-31,42},{-24,42},{-24,56},{-14,56}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(G.y,pvSimple. G) annotation (Line(
                points={{9,62},{50,62},{50,22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pvSimple.terminal, RL.terminal) annotation (Line(
                points={{40,10},{20,10},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(weaDat.weaBus, pvOriented.weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,26},{4.44089e-16,26},{4.44089e-16,19}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(pvOriented.terminal, RL.terminal) annotation (Line(
                points={{-10,10},{-28,10},{-28,-40},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=172800, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Sources/Examples/PVPanels.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a simple PV model without orientation
as well as a PV model with orientation. The power produced by the PV is
partially consumed by the load, and the remaining part is fed into
the grid.
</p>
</html>"));
          end PVPanels;

          model VariablePowerSource
            "This example illustrates how using a variable power source"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.Generator generator(f=60,
                phiGen=0.26179938779915) "AC generator model" annotation (
                Placement(transformation(extent={{-50,-10},{-30,10}})));
            Modelica.Blocks.Sources.Sine generation(
              offset=200,
              startTime=1,
              amplitude=100,
              f=0.05) "Generated power"
              annotation (Placement(transformation(extent={{-92,-10},{-72,10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Inductive RL(
              mode=Types.Load.VariableZ_y_input,
              P_nominal=-300,
              V_nominal=480) "Load model"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.Grid grid(f=60, V=
                  480) "AC one phase electrical grid"
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            Modelica.Blocks.Sources.Trapezoid load(
              rising=2,
              width=3,
              falling=3,
              period=10,
              startTime=1,
              amplitude=0.8,
              offset=0.2) "Power consumption profile"
              annotation (Placement(transformation(extent={{80,-10},{60,10}})));
          equation
            connect(generation.y, generator.P) annotation (Line(
                points={{-71,0},{-50,0}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(generator.terminal, RL.terminal)
                                                    annotation (Line(
                points={{-30,0},{20,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, RL.terminal)
                                               annotation (Line(
                points={{-10,40},{-10,0},{20,0},{20,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.y, RL.y)
                                 annotation (Line(
                points={{59,0},{40,0}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=1.0, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Sources/Examples/VariablePowerSource.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a variable generator model. The generator model has to be used
together with a voltage source generator, which is in this example the
grid model.
</p>
</html>"));
          end VariablePowerSource;

          model WindTurbine "Example for the WindTurbine AC model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.WindTurbine tur(
              table=[3.5,0; 5.5,100; 12,900; 14,1000; 25,1000],
              h=10,
              scale=10,
              V_nominal=480) "Wind turbine" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}}, origin={60,0})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false,
                filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              "Weather data"
              annotation (Placement(transformation(extent={{-52,36},{-32,56}})));
            Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
              annotation (Placement(transformation(extent={{16,36},{36,56}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Resistive res(P_nominal
                =-500, V_nominal=480) "Resistive line" annotation (Placement(
                  transformation(extent={{-22,-30},{-2,-10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sources.Grid sou(f=60, V=
                  480) "Voltage source" annotation (Placement(transformation(
                    extent={{-80,10},{-60,30}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Lines.TwoPortResistance lin(R=0.1)
              "Transmission line" annotation (Placement(transformation(extent={
                      {-22,-10},{-2,10}})));
            ProsNet.Electrical.AC.ThreePhasesBalanced.Sensors.GeneralizedSensor
              sen "Generalized sensor"
              annotation (Placement(transformation(extent={{8,-10},{28,10}})));
          equation
            connect(weaDat.weaBus,weaBus)  annotation (Line(
                points={{-32,46},{26,46}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaBus.winSpe,tur. vWin) annotation (Line(
                points={{26,46},{60,46},{60,12}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(sou.terminal, lin.terminal_n) annotation (Line(
                points={{-70,10},{-70,0},{-22,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, res.terminal) annotation (Line(
                points={{-70,10},{-70,-20},{-22,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(lin.terminal_p, sen.terminal_n) annotation (Line(
                points={{-2,0},{8,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_p, tur.terminal) annotation (Line(
                points={{28,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=172800, Tolerance=1e-6),
          Documentation(info="<html>
<p>
This model illustrates the use of the wind turbine model,
which is connected to a AC voltage source and a resistive load.
This voltage source can represent the grid to which the
circuit is connected.
Wind data for San Francisco, CA, are used.
The turbine cut-in wind speed is <i>3.5</i> m/s,
and hence it is off in the first day when the wind speed is low.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Created model and documentation
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Sources/Examples/WindTurbine.mos"
                  "Simulate and plot"));
          end WindTurbine;
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Sources\">
Buildings.Electrical.AC.ThreePhasesBalanced.Sources</a>.
</p>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for three-phase balanced AC sources.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Sources;

      package Storage "Package with models for electrical storage with a AC three-phase balanced connector"
        extends Modelica.Icons.Package;

        model Battery "Simple model of a battery"
          extends ProsNet.Electrical.AC.OnePhase.Storage.Battery(
            redeclare Interfaces.Terminal_p terminal,
            V_nominal(start=480),
            redeclare ProsNet.Electrical.AC.ThreePhasesBalanced.Loads.Resistive
              bat);

          annotation (
        defaultComponentName="bat",
        Documentation(info="<html>
<p>
Simple model of a battery.
</p>
<p>
This model takes as an input the power to be extracted from the AC line and
stored in the battery (if <i>P &gt; 0</i>)
or to be fed into the AC line after being extracted from the battery.
The actual power stored or extracted in the battery differs from <i>P</i> due
to AC/DC conversion losses and battery charge and discharge efficiencies.
</p>
<p>
The output connector <code>SOC</code> is the state of charge of the battery.
This model does not enforce that the state of charge is between zero and one.
However, each time the state of charge crosses zero or one, a warning will
be written to the simulation log file.
The model also does not limit the current through the battery. The user should
provide a control so that only a reasonable amount of power is exchanged,
and that the state of charge remains between zero and one.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 2, 2020 by Michael Wetter:<br/>
Corrected model and improved the documentation. The previous model extracted from
the AC connector the input power <code>P</code> plus the AC/DC conversion losses, but <code>P</code>
should be the power exchanged at the AC connector. Conversion losses are now only
accounted for in the energy exchange at the battery.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1865\">issue 1865</a>.
</li>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Added model and documentation
</li>
</ul>
</html>"));
        end Battery;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model AcBattery "This example shows how to use the AC battery model"
            extends Modelica.Icons.Example;
            ThreePhasesBalanced.Storage.Battery bat_ideal(
              eta_DCAC=1,
              etaCha=1,
              etaDis=1,
              SOC_start=0.5,
              EMax=749999.88,
              V_nominal=480) "Ideal battery without losses"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            ThreePhasesBalanced.Sources.FixedVoltage fixVol(f=60, V=480)
              annotation (Placement(transformation(extent={{-42,-10},{-22,10}})));
            Modelica.Blocks.Sources.Pulse pow(
              offset=-500,
              amplitude=1000,
              width=50,
              period=1200)
              "Signal that indicates how much power should be stored in the battery"
              annotation (Placement(transformation(extent={{-20,60},{0,80}})));
            ThreePhasesBalanced.Storage.Battery bat_loss_acdc(
              etaCha=1,
              etaDis=1,
              SOC_start=0.5,
              eta_DCAC=0.95,
              EMax=749999.88,
              V_nominal=480) "Battery with losses for AC/DC conversion"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));
            ThreePhasesBalanced.Storage.Battery bat(
              SOC_start=0.5,
              eta_DCAC=0.95,
              EMax=749999.88,
              V_nominal=480)
              "Battery with losses for AC/DC conversion and charge/discharge"
              annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
          equation
            connect(fixVol.terminal, bat_ideal.terminal) annotation (Line(
                points={{-22,0},{0,0},{0,30},{20,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(pow.y, bat_ideal.P) annotation (Line(
                points={{1,70},{30,70},{30,40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(fixVol.terminal, bat_loss_acdc.terminal) annotation (Line(
                points={{-22,0},{20,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(fixVol.terminal, bat.terminal) annotation (Line(
                points={{-22,0},{0,0},{0,-30},{20,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(pow.y, bat_loss_acdc.P) annotation (Line(
                points={{1,70},{50,70},{50,20},{30,20},{30,10}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pow.y, bat.P) annotation (Line(
                points={{1,70},{66,70},{66,-10},{30,-10},{30,-20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (              experiment(
                StopTime=3600,
                Tolerance=1e-6),
                      __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesBalanced/Storage/Examples/AcBattery.mos"
                  "Simulate and plot"),
                    Documentation(revisions="<html>
<ul>
<li>
February 27, 2016 by Michael Wetter:<br/>
Stored example in a single file rather than a file with multiple examples.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/488\">#488</a>.
</li>
<li>
September 22, 2014, by Marco Bonvini:<br/>
Added model and documentation
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use an AC battery model.
</p>
<p>
The example compares three different batteries. The battery named
<code>bat_ideal</code> is ideal and it does not account for any losses.
The battery named <code>bat_loss_acdc</code> accounts for conversion losses when converting
between AC to DC.
The battery named <code>bat</code> accounts for both conversion losses and inefficiencies
during the charge and discharge phases.
</p>
<p>
All the batteries start from the same initial condition that is <i>50%</i> of their total capacity.
The batteries are charged and discharged in the same way. The input signal <code>pow.y</code>
is the power that each battery should store or release. The signal has a duty cycle equal to <i>50%</i>.
Hence, if there are no losses, the same amount of power stored into the battery will be
released and after one cycle the State Of Charge (SOC) has to be equal.
</p>
<p>
The image below show the SOC of the three batteries.
</p>
<p align=\"center\">
<img alt=\"alt-image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/OnePhase/Storage/Examples/SOCs.png\"/>
</p>
<p>
As expected the red line (ideal battery) maintain the SOC over the time. The other two batteries loose some
of the initial energy due to the losses.
</p>
</html>"));
          end AcBattery;
          annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Storage\">
Buildings.Electrical.AC.ThreePhasesBalanced.Storage</a>.
</p>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains models for storage elements with an AC three-phase
balanced connector.
</p>
</html>"));
      end Storage;

      package Interfaces "Package interfaces for three-phase balanced AC systems"
        extends Modelica.Icons.InterfacesPackage;

        connector Terminal_n "AC three-phase balanced terminal ('negative')"
          extends ProsNet.Electrical.Interfaces.Terminal(redeclare replaceable
              package PhaseSystem = PhaseSystems.OnePhase);
          annotation (defaultComponentName = "term_p",
          Documentation(info="<html>
<p>Electric connector with a vector of negative pins.</p>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={           Text(
                  extent={{-60,60},{60,-60}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{-100,100},{-100,-100},{100,-100},{100,100},{-100,100}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Text(
                  extent={{-120,120},{100,60}},
                  textColor={0,120,120},
                  textString="%name"),
                Text(
                  extent={{14,16},{114,-84}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{-100,50},{-100,-50},{0,-50},{0,50},{-100,50}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end Terminal_n;

        connector Terminal_p "AC three-phase balanced terminal ('positive')"
          extends ProsNet.Electrical.Interfaces.Terminal(redeclare replaceable
              package PhaseSystem = PhaseSystems.OnePhase);
          annotation (defaultComponentName = "term_p",
          Documentation(info="<html>
<p>Electric connector with a vector of positive pins.</p>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={           Text(
                  extent={{-60,60},{60,-60}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                      points={{-100,100},{-100,-100},{100,-100},{100,100},{-100,100}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Text(
                  extent={{-120,120},{100,60}},
                  textColor={0,120,120},
                  textString="%name"),
                Text(
                  extent={{14,16},{114,-84}},
                  textColor={255,255,255},
                  pattern=LinePattern.None,
                  textString=""),                    Polygon(
                  points={{0,50},{0,-50},{100,-50},{100,50},{0,50}},
                  lineColor={0,120,120},
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid)}));
        end Terminal_p;
      annotation (Documentation(info="<html>
<p>
This package contains connectors that are used by the models in the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced\">Buildings.Electrical.AC.ThreePhasesBalanced</a> package.
The connectors extends the basic connectors
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">Buildings.Electrical.Interfaces.Terminal</a>
and define a new graphical icon in order to be distinguishable from connectors of other electrical systems (e.g. DC systems).
</p>
</html>",       revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Revised User's guide.
</li>
</ul>
</html>"));
      end Interfaces;
    annotation (Documentation(info="<html>
<p>
Package with models for alternate current (AC) three phase balanced systems.<br/>
Because the phases are balanced, the models in this
package extend the models of the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase\">
Buildings.Electrical.AC.OnePhase</a>.
</p>
<p>
The models that are part of this package assume by default 480 V as nominal RMS phase
to phase voltage. This default value can be changed.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
    end ThreePhasesBalanced;

    package ThreePhasesUnbalanced "Three phases unbalanced AC systems"
      extends Modelica.Icons.VariantsPackage;

      package Conversion "Package with converter and transformer models for three-phase
  unbalanced AC systems"
        extends Modelica.Icons.Package;

        model ACACConverter "AC AC converter single phase systems (YY)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACConverter
              conv1(
              conversionFactor=conversionFactor,
              eta=eta,
              ground_1=ground_1,
              ground_2=ground_2),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACConverter
              conv2(
              conversionFactor=conversionFactor,
              eta=eta,
              ground_1=ground_1,
              ground_2=ground_2),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACConverter
              conv3(
              conversionFactor=conversionFactor,
              eta=eta,
              ground_1=ground_1,
              ground_2=ground_2));
          parameter Real conversionFactor
            "Ratio of QS rms voltage on side 2 / QS rms voltage on side 1";
          parameter Modelica.Units.SI.Efficiency eta(max=1)
            "Converter efficiency, pLoss = (1-eta) * Ptr";
          parameter Boolean ground_1 = false "Connect side 1 of converter to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of converter to ground" annotation(Dialog(tab = "Ground", group="side 2"));

          annotation (
          defaultComponentName="conv",
         Icon(graphics={
                Line(
                  points={{2,60},{2,60},{82,60},{2,60},{82,-60},{2,-60},{2,60},{2,-60}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Line(
                  points={{-2,60},{-2,60},{-82,60},{-2,60},{-82,-60},{-2,-60},{-2,60},{
                      -2,-60}},
                  color={11,193,87},
                  smooth=Smooth.None),
                Text(
                  extent={{-100,92},{100,60}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%conversionFactor"),
                Text(
                  extent={{-132,78},{-72,38}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-88,52},{-28,12}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{32,52},{92,12}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,78},{130,38}},
                  textColor={0,120,120},
                  textString="2")}),
            Documentation(info="<html>
<p>
This is an AC AC converter, based on a power balance between both circuit sides.
The parameter <i>conversionFactor</i> defines the ratio between the RMS voltages
</p>

<p align=\"center\" style=\"font-style:italic;\">
V<sub>2</sub> = conversionFactor * V<sub>1</sub>
</p>

<p>
where <i>V<sub>1</sub></i> and <i>V<sub>2</sub></i> are the RMS voltages
at the primary and secondary sides of the transformer (connector N and P
respectively).
</p>

<p>
The loss of the converter is proportional to the power transmitted.
The parameter <code>eta</code> is the efficiency of the transfer.
The loss is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
P<sub>loss</sub> = (1-&eta;) P<sub>tr</sub>
</p>
<p>
where <i>P<sub>tr</sub></i> is the power transmitted. The model is bi-directional
and the power can flow from both the primary to the secondary and vice-versa.
Furthermore, reactive power on both side are set to 0.
</p>

<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YY.png\"/>
</p>

<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACConverter\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACConverter</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY</a> for
details on the connections.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACConverter;

        model ACACTransformer "AC AC transformer simplified equivalent circuit (YY)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv1(
              VHigh=VHigh/sqrt(3),
              VLow=VLow/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              phi_1=0),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv2(
              VHigh=VHigh/sqrt(3),
              VLow=VLow/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              phi_1=-2.0943951023932),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv3(
              VHigh=VHigh/sqrt(3),
              VLow=VLow/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              phi_1=2.0943951023932));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false "Connect side 1 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 2"));
        equation

          annotation (
          defaultComponentName="tra",
         Icon(graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L")}),
            Documentation(info="<html>
<p>
This is a simplified equivalent transformer model.
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent both the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the resistance and inductance.
</p>
<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YY.png\"/>
</p>
<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY</a> for
details on the connections.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformer;

        model ACACTransformerDD "AC AC transformer simplified equivalent circuit (DD)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterDD(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv1(
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VHigh=VHigh,
              VLow=VLow,
              phi_1=0.5235987755983),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv2(
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VHigh=VHigh,
              VLow=VLow,
              phi_1=-1.5707963267949),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv3(
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VHigh=VHigh,
              VLow=VLow,
              phi_1=2.6179938779915));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false "Connect side 1 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 2"));
        equation

          annotation (
          defaultComponentName="tra",
         Icon(graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{-50,-8},{-30,22},{-10,-8},{-50,-8}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{40,-8},{60,22},{80,-8},{40,-8}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5)}),
            Documentation(info="<html>
<p>
This is a simplified equivalent transformer model with Delta-Delta connection.
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the resistance and inductance.
</p>
<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/DD.png\"/>
</p>
<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterDD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterDD</a> for
details on the connections.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformerDD;

        model ACACTransformerFull "AC AC transformer detailed equivalent circuit (YY)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY(
            redeclare
              ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull
              conv1(
              VHigh=VHigh/sqrt(3),
              VLow=VLow/sqrt(3),
              f=f,
              VABase=VABase,
              R1=R1,
              L1=L1,
              R2=R2,
              L2=L2,
              magEffects=magEffects,
              Rm=Rm,
              Lm=Lm,
              ground_1=ground_1,
              ground_2=ground_2),
            redeclare
              ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull
              conv2(
              VHigh=VHigh/sqrt(3),
              VLow=VLow/sqrt(3),
              f=f,
              VABase=VABase,
              R1=R1,
              L1=L1,
              R2=R2,
              L2=L2,
              magEffects=magEffects,
              Rm=Rm,
              Lm=Lm,
              ground_1=ground_1,
              ground_2=ground_2),
            redeclare
              ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformerFull
              conv3(
              VHigh=VHigh/sqrt(3),
              VLow=VLow/sqrt(3),
              f=f,
              VABase=VABase,
              R1=R1,
              L1=L1,
              R2=R2,
              L2=L2,
              magEffects=magEffects,
              Rm=Rm,
              Lm=Lm,
              ground_1=ground_1,
              ground_2=ground_2));

          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Modelica.Units.SI.Frequency f(start=60) "Nominal frequency";
          parameter ProsNet.Electrical.Types.PerUnit R1(min=0)
            "Resistance on side 1 of the transformer (pu)";
          parameter ProsNet.Electrical.Types.PerUnit L1(min=0)
            "Inductance on side 1 of the transformer (pu)";
          parameter ProsNet.Electrical.Types.PerUnit R2(min=0)
            "Resistance on side 2 of the transformer (pu)";
          parameter ProsNet.Electrical.Types.PerUnit L2(min=0)
            "Inductance on side 2 of the transformer (pu)";
          parameter Boolean magEffects = false
            "If =true introduce magnetization effects"
            annotation(Dialog(group="Magnetization"));
          parameter ProsNet.Electrical.Types.PerUnit Rm(min=0, start=0)
            "Magnetization resistance (pu)"
            annotation (Dialog(group="Magnetization", enable=magEffects));
          parameter ProsNet.Electrical.Types.PerUnit Lm(min=0, start=0)
            "Magnetization inductance (pu)"
            annotation (Dialog(group="Magnetization", enable=magEffects));
          parameter Boolean ground_1 = false "Connect side 1 of converter to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of converter to ground" annotation(Dialog(tab = "Ground", group="side 2"));

          annotation (
          defaultComponentName="tra",
         Icon(graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L")}),
            Documentation(info="<html>
<p>
This is a detailed transformer model that takes into accounts the winding Joule losses,
and the leakage reactances on the primary and secondary side. The model also takes into account
the core or iron losses and the losses due to magnetization effects.
</p>
<p>
The losses are represented by a series of resistances <i>R<sub>1</sub></i>, <i>R<sub>2</sub></i>,
<i>R<sub>m</sub></i> and inductances <i>L<sub>1</sub></i>, <i>L<sub>2</sub></i>, and
<i>L<sub>m</sub></i>.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>f</code> - frequency,</li>
<li><code>R_1, L_1</code> - resistance and inductance at primary side (per unit),</li>
<li><code>R_2, L_2</code> - resistance and inductance at secondary side (per unit), and</li>
<li><code>R_m, L_m</code> - resistance and inductance for magnetization effects (per unit).</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the nominal impedances
at the primary and secondary side. Given these values, the per unit values are transformed into
the actual values of the resistances and inductancs.
</p>
<p>
The magnetization losses can be enabled or disabled using the boolean flag <code>magEffects</code>.
</p>
<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YY.png\"/>
</p>
<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformerFull\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformerFull</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterYY</a> for
details on the connections.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ACACTransformerFull;

        model ACACTransformerStepDownDY
          "AC AC transformer simplified equivalent circuit (DY step down)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepDownDY(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv1(
              VHigh=VHigh,
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=-VLow/sqrt(3),
              phi_1=2.6179938779915),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv2(
              VHigh=VHigh,
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=-VLow/sqrt(3),
              phi_1=0.5235987755983),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv3(
              VHigh=VHigh,
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=-VLow/sqrt(3),
              phi_1=-1.5707963267949));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false "Connect side 1 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 2"));
        equation

          annotation (
          defaultComponentName="tra",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{60,26},{60,6},{46,-8}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{60,6},{74,-8}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-52,-6},{-32,24},{-12,-6},{-52,-6}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,100},{32,68}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Polygon(
                  points={{0,-6},{6,6},{-6,0},{0,-6}},
                  lineColor={0,120,120},
                  smooth=Smooth.None,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid,
                  origin={34,66},
                  rotation=-90)}),
            Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This is a simplified equivalent transformer model with Y-Delta connection
(voltage step down).
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the resistance and inductance.
</p>

<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/DY_a.png\"/>
</p>

<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepDownDY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepDownDY</a> for
details on the connections.
</p>
</html>"));
        end ACACTransformerStepDownDY;

        model ACACTransformerStepDownYD
          "AC AC transformer simplified equivalent circuit (YD step down)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepDownYD(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv1(
              VHigh=VHigh/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=VLow,
              phi_1=0),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv2(
              VHigh=VHigh/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=VLow,
              phi_1=-2.0943951023932),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv3(
              VHigh=VHigh/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=VLow,
              phi_1=2.0943951023932));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false "Connect side 1 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 2"));
        equation

          annotation (
          defaultComponentName="tra",
         Icon(graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{-40,20},{-40,0},{-54,-14}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-40,0},{-26,-14}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{40,-10},{60,20},{80,-10},{40,-10}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,100},{32,68}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Polygon(
                  points={{0,-6},{6,6},{-6,0},{0,-6}},
                  lineColor={0,120,120},
                  smooth=Smooth.None,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid,
                  origin={34,66},
                  rotation=-90)}),
            Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This is a simplified equivalent transformer model with Y-Delta connection
(voltage step down).
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the resistance and inductance.
</p>

<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YD_a.png\"/>
</p>

<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepDownYD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepDownYD</a> for
details on the connections.
</p>
</html>"));
        end ACACTransformerStepDownYD;

        model ACACTransformerStepUpDY
          "AC AC transformer simplified equivalent circuit (DY step up)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepUpDY(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv1(
              VHigh=VHigh,
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=VLow/sqrt(3),
              phi_1=0.5235987755983),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv2(
              VHigh=VHigh,
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=VLow/sqrt(3),
              phi_1=-1.5707963267949),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv3(
              VHigh=VHigh,
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=VLow/sqrt(3),
              phi_1=2.6179938779915));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false "Connect side 1 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 2"));
        equation

          annotation (
          defaultComponentName="tra",
         Icon(graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{60,26},{60,6},{46,-8}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{60,6},{74,-8}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-52,-6},{-32,24},{-12,-6},{-52,-6}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,60},{32,92}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Polygon(
                  points={{34,88},{40,100},{28,94},{34,88}},
                  lineColor={0,120,120},
                  smooth=Smooth.None,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This is a simplified equivalent transformer model with Delta-Y connection
(voltage step up).
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the resistance and inductance.
</p>

<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/DY_b.png\"/>
</p>

<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepUpDY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepUpDY</a> for
details on the connections.
</p>
</html>"));
        end ACACTransformerStepUpDY;

        model ACACTransformerStepUpYD
          "AC AC transformer simplified equivalent circuit (YD step up)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepUpYD(
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv1(
              VHigh=VHigh/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=-VLow,
              phi_1=0),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv2(
              VHigh=VHigh/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=-VLow,
              phi_1=-2.0943951023932),
            redeclare ProsNet.Electrical.AC.OnePhase.Conversion.ACACTransformer
              conv3(
              VHigh=VHigh/sqrt(3),
              XoverR=XoverR,
              Zperc=Zperc,
              ground_1=ground_1,
              ground_2=ground_2,
              VABase=VABase/3,
              VLow=-VLow,
              phi_1=2.0943951023932));
          parameter Modelica.Units.SI.Voltage VHigh
            "Rms voltage on side 1 of the transformer (primary side)";
          parameter Modelica.Units.SI.Voltage VLow
            "Rms voltage on side 2 of the transformer (secondary side)";
          parameter Modelica.Units.SI.ApparentPower VABase
            "Nominal power of the transformer";
          parameter Real XoverR
            "Ratio between the complex and real components of the impedance (XL/R)";
          parameter Real Zperc "Short circuit impedance";
          parameter Boolean ground_1 = false "Connect side 1 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 1"));
          parameter Boolean ground_2 = true "Connect side 2 of transformer to ground" annotation(Dialog(tab = "Ground", group="side 2"));
        equation

          annotation (
          defaultComponentName="tra",
         Icon(graphics={
                Text(
                  extent={{-100,-60},{100,-92}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-130,60},{-70,20}},
                  textColor={11,193,87},
                  textString="1"),
                Text(
                  extent={{-130,100},{-70,60}},
                  textColor={11,193,87},
                  textString="AC"),
                Text(
                  extent={{70,100},{130,60}},
                  textColor={0,120,120},
                  textString="AC"),
                Text(
                  extent={{70,60},{130,20}},
                  textColor={0,120,120},
                  textString="2"),
                Line(
                  points={{-72,40},{-66,40},{-64,44},{-60,36},{-56,44},{-52,36},{-48,44},
                      {-44,36},{-42,40},{-38,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-60,-7.34764e-15}},
                  color={0,127,127},
                  origin={-40,40},
                  rotation=180),
                Ellipse(
                  extent={{-30,46},{-18,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-18,46},{-6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,46},{6,34}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-30,40},{6,28}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,40},{20,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{14,20},{26,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,8},{26,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,-4},{26,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{10,20},{20,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{20,-16},{20,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{20,-40},{-70,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{34,40},{34,20}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{40,20},{28,8}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,8},{28,-4}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{40,-4},{28,-16}},
                  lineColor={0,127,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{44,20},{34,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{34,-16},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,-40},{34,-40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Line(
                  points={{70,40},{34,40}},
                  color={0,127,127},
                  smooth=Smooth.None),
                Text(
                  extent={{-64,60},{-48,48}},
                  textColor={0,120,120},
                  textString="R"),
                Text(
                  extent={{-20,60},{-4,48}},
                  textColor={0,120,120},
                  textString="L"),
                Line(
                  points={{-40,20},{-40,0},{-54,-14}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{-40,0},{-26,-14}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{40,-10},{60,20},{80,-10},{40,-10}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,60},{32,92}},
                  color={0,120,120},
                  smooth=Smooth.None),
                Polygon(
                  points={{34,88},{40,100},{28,94},{34,88}},
                  lineColor={0,120,120},
                  smooth=Smooth.None,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This is a simplified equivalent transformer model with Y-Delta connection
(voltage step up).
The model accounts for winding Joule losses and leakage reactances
that are represented by a series of a resistance <i>R</i> and an
inductance <i>L</i>. The resistance and the inductance represent the
effects of the secondary and primary side of the transformer.
</p>
<p>
The model is parameterized using the following parameters
</p>
<ul>
<li><code>Vhigh</code> - RMS voltage at primary side,</li>
<li><code>Vlow</code> - RMS voltage at secondary side,</li>
<li><code>VAbase</code> - apparent nominal power of the transformer,</li>
<li><code>XoverR</code> - ratio between reactance and resistance, and</li>
<li><code>Zperc</code> - the short circuit impedance.</li>
</ul>
<p>
Given the nominal conditions, the model computes the values of the resistance and inductance.
</p>

<h4>Configuration:</h4>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YD_b.png\"/>
</p>

<h4>Note:</h4>
<p>
This model reuses models from
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer\">
Buildings.Electrical.AC.OnePhase.Conversion.ACACTransformer</a>.
</p>
<p>
See
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepUpYD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverterStepUpYD</a> for
details on the connections.
</p>
</html>"));
        end ACACTransformerStepUpYD;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model Converter "Test for the AC/AC converter model"
            extends BaseClasses.TransformerExample(
            V_primary = 480,
            V_secondary = 240,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACConverter
                tra(conversionFactor=0.5, eta=0.9));

          equation
            connect(probe_2.term, tra.terminal_p) annotation (Line(
                points={{30,31},{30,4.44089e-16},{10,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACConverter\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACConverter</a> model.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/Converter.mos"
                  "Simulate and plot"));
          end Converter;

          model Transformer "Test for the AC/AC transformer model"
            extends BaseClasses.TransformerExample(
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                XoverR=6,
                Zperc=sqrt(0.01^2 + 0.06^2),
                VABase=6000000));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer</a> model.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/Transformer.mos"
                  "Simulate and plot"));
          end Transformer;

          model TransformerDD
            "Test for the AC/AC transformer model with Delta-Delta configuration"
            extends BaseClasses.TransformerExample(
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                XoverR=6,
                Zperc=sqrt(0.01^2 + 0.06^2),
                VABase=6000000));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0},{50,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD</a> model.
</p>
<h4>Note:</h4>
<p>
When the secondary side of the transformer is in the Delta (D) configuration,
measuring the voltage with a Wye (Y) is not possible because the voltage vectors
in the connector do not have a neutral reference.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/TransformerDD.mos"
                  "Simulate and plot"));
          end TransformerDD;

          model TransformerFull "Test for the AC/AC transformer full model"
            extends BaseClasses.TransformerExample(
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerFull
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                VABase=6000000,
                f=60,
                R1=0.005,
                L1=0.005*6,
                R2=0.005,
                L2=0.005*6,
                magEffects=true,
                Rm=10,
                Lm=10),
                load(initMode=ProsNet.Electrical.Types.InitMode.linearized));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerFull\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerFull</a> model.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/TransformerFull.mos"
                  "Simulate and plot"));
          end TransformerFull;

          model TransformerStepDownDY
            "Test for the AC/AC transformer model with Delta-Wye configuration (step-down voltage)"
            extends BaseClasses.TransformerExample(
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownDY
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                XoverR=6,
                Zperc=sqrt(0.01^2 + 0.06^2),
                VABase=6000000));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownDY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownDY</a> model.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/TransformerStepDownDY.mos"
                  "Simulate and plot"));
          end TransformerStepDownDY;

          model TransformerStepDownYD
            "Test for the AC/AC transformer model with Wye-Delta configuration (step-down voltage)"
            extends BaseClasses.TransformerExample(
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownYD
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                XoverR=6,
                Zperc=sqrt(0.01^2 + 0.06^2),
                VABase=6000000));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0},{50,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownYD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownYD</a> model.
</p>
<h4>Note:</h4>
<p>
When the secondary side of the transformer is in the Delta (D) configuration,
measuring the voltage with a Wye (Y) is not possible because the voltage vectors
in the connector do not have a neutral reference.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/TransformerStepDownYD.mos"
                  "Simulate and plot"));
          end TransformerStepDownYD;

          model TransformerStepUpDY
            "Test for the AC/AC transformer model with Delta-Wye configuration (step-up voltage)"
            extends BaseClasses.TransformerExample(
            V_primary = 4160,
            V_secondary = 12470,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpDY
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                XoverR=6,
                Zperc=sqrt(0.01^2 + 0.06^2),
                VABase=6000000));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpDY\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpDY</a> model.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/TransformerStepUpDY.mos"
                  "Simulate and plot"));
          end TransformerStepUpDY;

          model TransformerStepUpYD
            "Test for the AC/AC transformer model with Wye-Delta configuration (step-up voltage)"
            extends BaseClasses.TransformerExample(
            V_primary = 4160,
            V_secondary = 12470,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta probe_2,
            redeclare
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpYD
                tra(
                VHigh=V_primary,
                VLow=V_secondary,
                XoverR=6,
                Zperc=sqrt(0.01^2 + 0.06^2),
                VABase=6000000));

          equation
            connect(probe_2.term, load.terminal) annotation (Line(
                points={{30,31},{30,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example model tests the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpYD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpYD</a> model.
</p>
<h4>Note:</h4>
<p>
When the secondary side of the transformer is in the Delta (D) configuration,
measuring the voltage with a Wye (Y) is not possible because the voltage vectors
in the connector do not have a neutral reference.
</p>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Conversion/Examples/TransformerStepUpYD.mos"
                  "Simulate and plot"));
          end TransformerStepUpYD;

          package BaseClasses "This package contains base classes inherited by the examples"
          extends Modelica.Icons.BasesPackage;

            model TransformerExample
              "This example represents the basic test for a transformer model"
              extends Modelica.Icons.Example;
              parameter Modelica.Units.SI.Voltage V_primary=12470
                "RMS Voltage on the primary side of the transformer";
              parameter Modelica.Units.SI.Voltage V_secondary=4160
                "RMS Voltage on the secondary side of the transformer";
              Sources.FixedVoltage sou(
                f=60,
                V=V_primary) "Voltage source"
                annotation (Placement(transformation(extent={{-70,-10},{-50,10}})));
              replaceable
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter
                tra "Transformer model" annotation (Placement(transformation(
                      extent={{-10,-10},{10,10}})));
              Loads.Resistive load(
                loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg,
                P_nominal=-1800e3,
                V_nominal=V_secondary,
                linearized=true)       "Load model"
                annotation (Placement(transformation(extent={{50,-10},{70,10}})));
              Sensors.ProbeWye probe_Y_1(perUnit=false, V_nominal = V_primary)
                "Probe that measures the voltage in Y configuration, primary side"
                annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
              Sensors.ProbeDelta probe_D_1(perUnit=false, V_nominal = V_primary)
                "Probe that measures the voltage in D configuration, primary side"
                annotation (Placement(transformation(extent={{-40,-30},{-20,-50}})));
              replaceable Sensors.BaseClasses.GeneralizedProbe probe_2 constrainedby
                Sensors.BaseClasses.GeneralizedProbe(perUnit=false,
                V_nominal=V_secondary)
                "Probe that measures the voltage at the secondary side"
                annotation (Placement(transformation(extent={{20,30},{40,50}})));

            equation
              connect(sou.terminal, tra.terminal_n) annotation (Line(
                  points={{-50,0},{-10,0}},
                  color={0,120,120},
                  smooth=Smooth.None));
              connect(probe_Y_1.term, tra.terminal_n) annotation (Line(
                  points={{-30,31},{-30,0},{-10,0}},
                  color={0,120,120},
                  smooth=Smooth.None));
              connect(probe_D_1.term, tra.terminal_n) annotation (Line(
                  points={{-30,-31},{-30,0},{-10,0}},
                  color={0,120,120},
                  smooth=Smooth.None));
              connect(tra.terminal_p, load.terminal) annotation (Line(
                  points={{10,0},{50,0}},
                  color={0,120,120},
                  smooth=Smooth.None));
              annotation (Documentation(revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Linearized load to avoid large nonlinear system of equations.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/568\">issue 568</a>.
</li>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",             info="<html>
<p>
This model is the base classes used by the examples that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.Examples\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.Examples</a>.
</p>
<p>
The model has a voltage source, a transformer and a load. The transformer
model is replaceable so that different types of transformers can easily be tested.
</p>
</html>"));
            end TransformerExample;
          annotation (Documentation(info="<html>
<p>
This package contains base classes used by the examples that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.Examples\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion.Examples</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end BaseClasses;
          annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Examples;

        package BaseClasses "Package with base class models"
        extends Modelica.Icons.BasesPackage;

          partial model PartialConverter "Partial model of a transformer"
            extends ProsNet.Electrical.Icons.RefAngleConversion;
            replaceable ProsNet.Electrical.Interfaces.PartialConversion conv1
              constrainedby ProsNet.Electrical.Interfaces.PartialConversion(
              redeclare package PhaseSystem_p =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare package PhaseSystem_n =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare Electrical.AC.OnePhase.Interfaces.Terminal_n terminal_n,
              redeclare Electrical.AC.OnePhase.Interfaces.Terminal_p terminal_p)
              "Transformer phase 1"
              annotation (Placement(transformation(extent={{-10,42},{10,62}})));

            replaceable ProsNet.Electrical.Interfaces.PartialConversion conv2
              constrainedby ProsNet.Electrical.Interfaces.PartialConversion(
              redeclare package PhaseSystem_p =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare package PhaseSystem_n =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare Electrical.AC.OnePhase.Interfaces.Terminal_n terminal_n,
              redeclare Electrical.AC.OnePhase.Interfaces.Terminal_p terminal_p)
              "Transformer phase 2" annotation (Placement(transformation(extent
                    ={{-10,-10},{10,10}})));

            replaceable ProsNet.Electrical.Interfaces.PartialConversion conv3
              constrainedby ProsNet.Electrical.Interfaces.PartialConversion(
              redeclare package PhaseSystem_p =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare package PhaseSystem_n =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare Electrical.AC.OnePhase.Interfaces.Terminal_n terminal_n,
              redeclare Electrical.AC.OnePhase.Interfaces.Terminal_p terminal_p)
              "Transformer phase 3" annotation (Placement(transformation(extent
                    ={{-10,-70},{10,-50}})));

            Interfaces.Terminal_n terminal_n "Electrical connector side N"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Interfaces.Terminal_p terminal_p "Electrical connector side P"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer without neutral cable connection.
</p>
</html>"));
          end PartialConverter;

          partial model PartialConverterDD "Model of a transformer with D connection primary side and D
  connection secondary side"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta wye_to_delta
              "Delta to wye connection"
              annotation (Placement(transformation(extent={{78,-10},{58,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta delta_to_wye
              "Delta to wye connection" annotation (Placement(transformation(
                    extent={{-76,-10},{-56,10}})));
          protected
            Interfaces.Adapter3to3 ada_n "Adapter"
              annotation (Placement(transformation(extent={{-30,-10},{-50,10}})));
            Interfaces.Adapter3to3 ada_p "Adapter"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
          equation

            connect(delta_to_wye.wye, terminal_n) annotation (Line(
                points={{-76,4.44089e-16},{-80,4.44089e-16},{-80,0},{-100,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(wye_to_delta.wye, terminal_p) annotation (Line(
                points={{78,6.66134e-16},{82,6.66134e-16},{82,0},{92,0},{92,4.44089e-16},{100,
                    4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));

            connect(delta_to_wye.delta, ada_n.terminal)
              annotation (Line(points={{-56,0},{-50,0}}, color={0,120,120}));
            connect(wye_to_delta.delta, ada_p.terminal)
              annotation (Line(points={{58,0},{50,0}}, color={0,120,120}));
            connect(conv1.terminal_n, ada_n.terminals[1]) annotation (Line(points={{-10,
                    52},{-20,52},{-20,0.533333},{-30.2,0.533333}}, color={0,0,0}));
            connect(conv2.terminal_n, ada_n.terminals[2]) annotation (Line(points={{-10,0},
                    {-20,0},{-20,0},{-30.2,0}}, color={0,0,0}));
            connect(conv3.terminal_n, ada_n.terminals[3]) annotation (Line(points={{-10,
                    -60},{-20,-60},{-20,-14},{-20,-0.533333},{-30.2,-0.533333}}, color={0,
                    0,0}));
            connect(conv1.terminal_p, ada_p.terminals[1]) annotation (Line(points={{10,52},
                    {20,52},{20,0.533333},{30.2,0.533333}}, color={0,0,0}));
            connect(conv2.terminal_p, ada_p.terminals[2])
              annotation (Line(points={{10,0},{20,0},{20,0},{30.2,0}}, color={0,0,0}));
            connect(conv3.terminal_p, ada_p.terminals[3]) annotation (Line(points={{10,
                    -60},{20,-60},{20,-26},{20,-0.533333},{30.2,-0.533333}}, color={0,0,0}));
            annotation(Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer with delta connection on both primary and secondary side.
</p>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/DD.png\"/>
</p>
</html>"));
          end PartialConverterDD;

          partial model PartialConverterStepDownDY "Model of a transformer with D connection primary side and
  Y connection secondary side (Voltage step down)"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToWyeGround
              wye_to_wyeg "Wye to wye grounded connection"
              annotation (Placement(transformation(extent={{78,-10},{58,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta delta_to_wye
              "Delta to wye connection" annotation (Placement(transformation(
                    extent={{-76,-10},{-56,10}})));
          protected
            Interfaces.Adapter3to3 ada3to3_n "Adapter for connections"
              annotation (Placement(transformation(extent={{-30,-10},{-50,10}})));
            Interfaces.Adapter3to3 ada3to3_p "Adapter for connections"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
          equation

            connect(delta_to_wye.wye, terminal_n) annotation (Line(
                points={{-76,4.44089e-16},{-80,4.44089e-16},{-80,0},{-100,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(wye_to_wyeg.wye, terminal_p) annotation (Line(
                points={{78,6.66134e-16},{82,6.66134e-16},{82,0},{92,0},{92,4.44089e-16},{100,
                    4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));

            connect(conv1.terminal_n, ada3to3_n.terminals[3]) annotation (Line(points={{-10,52},
                    {-20,52},{-20,0.533333},{-30,0.533333}},     color={0,0,0}));
            connect(conv2.terminal_n, ada3to3_n.terminals[1])
              annotation (Line(points={{-10,0},{-30,0},{-30,-0.533333}}, color={0,0,0}));
            connect(conv3.terminal_n, ada3to3_n.terminals[2]) annotation (Line(points={{-10,
                    -60},{-20,-60},{-20,0},{-30,0}}, color={0,0,0}));
            connect(delta_to_wye.delta, ada3to3_n.terminal)
              annotation (Line(points={{-56,0},{-53,0},{-50,0}}, color={0,120,120}));
            connect(conv1.terminal_p, ada3to3_p.terminals[1]) annotation (Line(points={{10,52},
                    {20,52},{20,-0.533333},{30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_p, ada3to3_p.terminals[2])
              annotation (Line(points={{10,0},{20,0},{30,0}}, color={0,0,0}));
            connect(conv3.terminal_p, ada3to3_p.terminals[3]) annotation (Line(points={{10,-60},
                    {20,-60},{20,0.533333},{30,0.533333}},      color={0,0,0}));
            connect(ada3to3_p.terminal, wye_to_wyeg.wyeg)
              annotation (Line(points={{50,0},{54,0},{58,0}}, color={0,120,120}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer with delta connection on the primary and Y connection on
the secondary side. The configuration is for voltage step down.
</p>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/DY_a.png\"/>
</p>
</html>"));
          end PartialConverterStepDownDY;

          partial model PartialConverterStepDownYD "Model of a transformer with Y connection primary side and D
connection secondary side (Voltage step down)"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToWyeGround
              wye_to_wyeg "Wye to wye grounded connection" annotation (
                Placement(transformation(extent={{-82,-10},{-62,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta delta_to_wye
              "Delta to wye connection "
              annotation (Placement(transformation(extent={{80,-10},{60,10}})));
          protected
            Interfaces.Adapter3to3 ada3to3_n "Adapter for connections"
              annotation (Placement(transformation(extent={{-30,-10},{-50,10}})));
            Interfaces.Adapter3to3 ada3to3_p "Adapter for connections"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
          equation

            connect(delta_to_wye.wye, terminal_p) annotation (Line(
                points={{80,0},{100,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(wye_to_wyeg.wye, terminal_n) annotation (Line(
                points={{-82,6.66134e-16},{-84,6.66134e-16},{-84,0},{-86,0},{-86,4.44089e-16},
                    {-100,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));

            connect(conv1.terminal_n, ada3to3_n.terminals[1]) annotation (Line(points={{-10,52},
                    {-20,52},{-20,-0.533333},{-30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_n, ada3to3_n.terminals[2])
              annotation (Line(points={{-10,0},{-30,0},{-30,0}}, color={0,0,0}));
            connect(conv3.terminal_n, ada3to3_n.terminals[3]) annotation (Line(points={{-10,-60},
                    {-20,-60},{-20,0.533333},{-30,0.533333}},      color={0,0,0}));
            connect(conv1.terminal_p, ada3to3_p.terminals[1]) annotation (Line(points={{10,52},
                    {20,52},{20,-0.533333},{30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_p, ada3to3_p.terminals[2])
              annotation (Line(points={{10,0},{20,0},{30,0}}, color={0,0,0}));
            connect(conv3.terminal_p, ada3to3_p.terminals[3]) annotation (Line(points={{10,-60},
                    {20,-60},{20,0.533333},{30,0.533333}},      color={0,0,0}));
            connect(ada3to3_p.terminal, delta_to_wye.delta)
              annotation (Line(points={{50,0},{55,0},{60,0}}, color={0,120,120}));
            connect(wye_to_wyeg.wyeg, ada3to3_n.terminal)
              annotation (Line(points={{-62,0},{-56,0},{-50,0}}, color={0,120,120}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer with Y connection on primary and delta connection on
the secondary one. The configuration is for voltage step down.
</p>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YD_a.png\"/>
</p>
</html>"));
          end PartialConverterStepDownYD;

          partial model PartialConverterStepUpDY "Model of a transformer with D connection primary side and Y connection
  secondary side (Voltage step up)"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToWyeGround
              wye_to_wyeg "Wye to wye grounded connection"
              annotation (Placement(transformation(extent={{78,-10},{58,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta delta_to_wye
              "Delta to wye connection" annotation (Placement(transformation(
                    extent={{-76,-10},{-56,10}})));
          protected
            Interfaces.Adapter3to3 ada3to3_n "Adapter for connections"
              annotation (Placement(transformation(extent={{-30,-10},{-50,10}})));
            Interfaces.Adapter3to3 ada3to3_p "Adapter for connections"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
          equation

            connect(delta_to_wye.wye, terminal_n) annotation (Line(
                points={{-76,4.44089e-16},{-80,4.44089e-16},{-80,0},{-100,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(wye_to_wyeg.wye, terminal_p) annotation (Line(
                points={{78,6.66134e-16},{82,6.66134e-16},{82,0},{92,0},{92,4.44089e-16},{100,
                    4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));

            connect(conv1.terminal_n,ada3to3_n. terminals[1]) annotation (Line(points={{-10,52},
                    {-20,52},{-20,-0.533333},{-30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_n,ada3to3_n. terminals[2])
              annotation (Line(points={{-10,0},{-30,0}},         color={0,0,0}));
            connect(conv3.terminal_n,ada3to3_n. terminals[3]) annotation (Line(points={{-10,-60},
                    {-20,-60},{-20,0.533333},{-30,0.533333}},      color={0,0,0}));
            connect(conv1.terminal_p,ada3to3_p. terminals[1]) annotation (Line(points={{10,52},
                    {20,52},{20,-0.533333},{30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_p,ada3to3_p. terminals[2])
              annotation (Line(points={{10,0},{10,0},{30,0}}, color={0,0,0}));
            connect(conv3.terminal_p,ada3to3_p. terminals[3]) annotation (Line(points={{10,-60},
                    {20,-60},{20,0.533333},{30,0.533333}},      color={0,0,0}));
            connect(ada3to3_p.terminal, wye_to_wyeg.wyeg)
              annotation (Line(points={{50,0},{54,0},{58,0}}, color={0,120,120}));
            connect(delta_to_wye.delta, ada3to3_n.terminal)
              annotation (Line(points={{-56,0},{-50,0}}, color={0,120,120}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer with delta connection on the primary and Y connection on
the secondary side. The configuration is for voltage step up.
</p>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/DY_b.png\"/>
</p>
</html>"));
          end PartialConverterStepUpDY;

          partial model PartialConverterStepUpYD "Model of a transformer with Y connection primary side and D connection
  secondary side (Voltage step up)"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToWyeGround
              wye_to_wyeg "Wye to wye grounded connection" annotation (
                Placement(transformation(extent={{-82,-10},{-62,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta delta_to_wye
              "Delta to wye connection"
              annotation (Placement(transformation(extent={{80,-10},{60,10}})));
          protected
            Interfaces.Adapter3to3 ada3to3_n "Adapter for connections"
              annotation (Placement(transformation(extent={{-30,-10},{-50,10}})));
            Interfaces.Adapter3to3 ada3to3_p "Adapter for connections"
              annotation (Placement(transformation(extent={{26,-10},{46,10}})));
          equation

            connect(delta_to_wye.wye, terminal_p) annotation (Line(
                points={{80,0},{100,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(wye_to_wyeg.wye, terminal_n) annotation (Line(
                points={{-82,6.66134e-16},{-84,6.66134e-16},{-84,0},{-86,0},{-86,4.44089e-16},
                    {-100,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));

            connect(conv1.terminal_n,ada3to3_n. terminals[1]) annotation (Line(points={{-10,52},
                    {-20,52},{-20,-0.533333},{-30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_n,ada3to3_n. terminals[2])
              annotation (Line(points={{-10,0},{-26,0},{-30,0}}, color={0,0,0}));
            connect(conv3.terminal_n,ada3to3_n. terminals[3]) annotation (Line(points={{-10,-60},
                    {-20,-60},{-20,0.533333},{-30,0.533333}},      color={0,0,0}));
            connect(wye_to_wyeg.wyeg, ada3to3_n.terminal)
              annotation (Line(points={{-62,0},{-56,0},{-50,0}}, color={0,120,120}));
            connect(conv1.terminal_p, ada3to3_p.terminals[3]) annotation (Line(points={{10,52},
                    {20,52},{20,0.533333},{26,0.533333}},     color={0,0,0}));
            connect(conv2.terminal_p, ada3to3_p.terminals[1]) annotation (Line(points={{10,0},{
                    28,0},{28,-0.533333},{26,-0.533333}},     color={0,0,0}));
            connect(conv3.terminal_p, ada3to3_p.terminals[2]) annotation (Line(points={{10,
                    -60},{10,-60},{16,-60},{16,-60},{20,-60},{20,0},{26,0},{26,0}}, color=
                   {0,0,0}));
            connect(ada3to3_p.terminal, delta_to_wye.delta)
              annotation (Line(points={{46,0},{53,0},{60,0}}, color={0,120,120}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer with Y connection on the primary and delta connection on
the secondary side. The configuration is for voltage step up.
</p>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YD_b.png\"/>
</p>
</html>"));
          end PartialConverterStepUpYD;

          partial model PartialConverterYY "Model of a transformer with Y connection primary side and Y
  connection secondary side"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.BaseClasses.PartialConverter;
            Interfaces.Connection3to3Ground_n connection3to4_n
              "Conversion between 3 to 4 connectors"
              annotation (Placement(transformation(extent={{-60,-10},{-80,10}})));
            Interfaces.Connection3to3Ground_p connection3to4_p
              "Conversion between 3 to 4 connectors"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            OnePhase.Basics.Ground ground_n "Ground reference"
              annotation (Placement(transformation(extent={{-70,-90},{-50,-70}})));
            OnePhase.Basics.Ground ground_p "Ground reference"
              annotation (Placement(transformation(extent={{50,-90},{70,-70}})));
          protected
            Interfaces.Adapter3to3 ada3to3_n "Adapter for connections"
              annotation (Placement(transformation(extent={{-30,-10},{-50,10}})));
            Interfaces.Adapter3to3 ada3to3_p "Adapter for connections"
              annotation (Placement(transformation(extent={{30,-10},{50,10}})));
          equation

            connect(terminal_p, connection3to4_p.terminal3) annotation (Line(
                points={{100,0},{80,0},{80,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(terminal_n, connection3to4_n.terminal3) annotation (Line(
                points={{-100,4.44089e-16},{-80,4.44089e-16},{-80,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(connection3to4_p.ground4, ground_p.terminal)
              annotation (Line(points={{59.6,-6},{60,-6},{60,-70}}, color={0,120,120}));
            connect(ground_n.terminal, connection3to4_n.ground4) annotation (Line(points={
                    {-60,-70},{-60,-6},{-60.1,-6}}, color={0,120,120}));
            connect(connection3to4_n.terminal4, ada3to3_n.terminal)
              annotation (Line(points={{-60,0},{-55,0},{-50,0}}, color={0,120,120}));
            connect(ada3to3_n.terminals[1], conv1.terminal_n) annotation (Line(points={{-30,
                    -0.533333},{-26,-0.533333},{-20,-0.533333},{-20,52},{-10,52}}, color={
                    0,0,0}));
            connect(ada3to3_n.terminals[2], conv2.terminal_n)
              annotation (Line(points={{-30,0},{-20,0},{-10,0}}, color={0,0,0}));
            connect(ada3to3_n.terminals[3], conv3.terminal_n) annotation (Line(points={{-30,
                    0.533333},{-20,0.533333},{-20,-60},{-10,-60}}, color={0,0,0}));
            connect(conv1.terminal_p, ada3to3_p.terminals[1]) annotation (Line(points={{10,52},
                    {20,52},{20,-0.533333},{30,-0.533333}},     color={0,0,0}));
            connect(conv2.terminal_p, ada3to3_p.terminals[2])
              annotation (Line(points={{10,0},{20,0},{30,0}}, color={0,0,0}));
            connect(conv3.terminal_p, ada3to3_p.terminals[3]) annotation (Line(points={{10,-60},
                    {20,-60},{20,0.533333},{30,0.533333}},      color={0,0,0}));
            connect(ada3to3_p.terminal, connection3to4_p.terminal4)
              annotation (Line(points={{50,0},{55,0},{60,0}}, color={0,120,120}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapters for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",           info="<html>
<p>
Partial model that represents a three-phase unbalanced
transformer with Y connection on both primary and secondary side.
</p>
<p>
The image below describes the connection of the windings.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Conversion/BaseClasses/YY.png\"/>
</p>
</html>"));
          end PartialConverterYY;
        annotation (Documentation(info="<html>
<p>
This package contains base classes used by the models that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Conversion</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end BaseClasses;
      annotation (Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",       info="<html>
<p>
This package contains models that represent different types of three
phases unbalanced AC/AC transformers and AC/DC converters.
</p>
</html>"));
      end Conversion;

      package Lines "Package with transmission line models for three-phase unbalanced AC systems"
        extends Modelica.Icons.Package;

        model Line "Model of an electrical line without neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialBaseLine(
              V_nominal(start=480), commercialCable=
                ProsNet.Electrical.Transmission.Functions.selectCable_low(
                P_nominal, V_nominal));
          OnePhase.Lines.TwoPortRL phase1(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=modelMode) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortRL phase2(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=modelMode) "Impedance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortRL phase3(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=modelMode) "Impedance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
        equation

          connect(cableTemp.port, phase1.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,10},{6.66134e-16,10},{6.66134e-16,20}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(cableTemp.port, phase2.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,-20},{0,-20},{0,-10},{4.44089e-16,-10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(cableTemp.port, phase3.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,-50},{0,-50},{0,-40}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,4.44089e-16},{100,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,4.44089e-16},{100,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(graphics={
                Ellipse(
                  extent={{-70,10},{-50,-10}},
                  lineColor={0,0,0},
                  fillColor={11,193,87},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,10},{60,-10}},
                  fillColor={11,193,87},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{50,10},{70,-10}},
                  lineColor={0,0,0},
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-70,0},{-90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,10},{60,10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,-10},{60,-10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{96,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents an AC three-phase unbalanced cable without
neutral connection. The model is based on
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC</a>
and provides functionalities to parametrize the values of <i>R</i>, <i>L</i> and <i>C</i>
using either commercial cables or default values.
</p>
</html>"));
        end Line;

        model Line_N "Model of an electrical line with neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));
          extends ProsNet.Electrical.Transmission.BaseClasses.PartialBaseLine(
              V_nominal(start=480), commercialCable=
                ProsNet.Electrical.Transmission.Functions.selectCable_low(
                P_nominal, V_nominal));
          OnePhase.Lines.TwoPortRL phase1(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final mode=modelMode,
            final R=R/3,
            final L=L/3) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortRL phase2(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final mode=modelMode,
            final R=R/3,
            final L=L/3) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortRL phase3(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final mode=modelMode,
            final R=R/3,
            final L=L/3) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          OnePhase.Lines.TwoPortRL neutral(
            final useHeatPort=true,
            final T_ref=T_ref,
            final M=M,
            final mode=modelMode,
            final R=R/3,
            final L=L/3) "Impedance of the neutral cable"
            annotation (Placement(transformation(extent={{-10,-70},{10,-50}})));
        equation

          connect(cableTemp.port, phase1.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,10},{6.66134e-16,10},{6.66134e-16,20}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(cableTemp.port, phase2.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,-20},{0,-20},{0,-10},{4.44089e-16,-10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(cableTemp.port, phase3.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,-50},{0,-50},{0,-40}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,4.44089e-16},{100,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,4.44089e-16},{100,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(cableTemp.port, neutral.heatPort) annotation (Line(
              points={{-40,22},{-26,22},{-26,-74},{6.66134e-16,-74},{6.66134e-16,-70}},
              color={191,0,0},
              smooth=Smooth.None));

          // Neutral cable connection
          connect(terminal_n.phase[4], neutral.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-60},{-10,-60}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_p.phase[4], neutral.terminal_p) annotation (Line(
              points={{100,4.44089e-16},{20,4.44089e-16},{20,-60},{10,-60}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(graphics={
                Ellipse(
                  extent={{-70,10},{-50,-10}},
                  lineColor={0,0,0},
                  fillColor={11,193,87},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-60,10},{60,-10}},
                  fillColor={11,193,87},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None,
                  lineColor={0,0,0}),
                Ellipse(
                  extent={{50,10},{70,-10}},
                  lineColor={0,0,0},
                  fillColor={255,128,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-70,0},{-90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,10},{60,10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-60,-10},{60,-10}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{96,0},{60,0}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents an AC three-phase unbalanced cable with
neutral connection. The model is based on
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC</a>
and provides functionalities to parametrize the values of <i>R</i>, <i>L</i> and <i>C</i>
using either commercial cables or default values.
</p>
</html>"));
        end Line_N;

        model Network "Three phases unbalanced AC network without neutral cable"
          extends Transmission.BaseClasses.PartialNetwork(
            redeclare
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal_p
              terminal,
            redeclare replaceable Transmission.Grids.TestGrid2Nodes grid,
            redeclare ProsNet.Electrical.AC.ThreePhasesUnbalanced.Lines.Line lines(
                commercialCable=grid.cables));
          Modelica.Units.SI.Voltage VAbs[3,grid.nNodes] "RMS voltage of the grid nodes";
        equation
          for i in 1:grid.nLinks loop
            connect(lines[i].terminal_p, terminal[grid.fromTo[i,1]]);
            connect(lines[i].terminal_n, terminal[grid.fromTo[i,2]]);
          end for;

          for i in 1:grid.nNodes loop
            VAbs[1, i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].phase[1].v);
            VAbs[2, i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].phase[2].v);
            VAbs[3, i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].phase[3].v);
          end for;
          annotation (
          defaultComponentName="net",
         Documentation(revisions="<html>
 <ul>
 <li>
March 30, 2015, by Michael Wetter:<br/>
Made <code>network</code> replaceable. This was detected
by the OpenModelica regression tests.
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a generalized electrical AC three-phase unbalanced network
without neutral cable.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialNetwork\">
Buildings.Electrical.Transmission.BaseClasses.PartialNetwork</a>
for information about the network model.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.Grids.PartialGrid\">
Buildings.Electrical.Transmission.Grids.PartialGrid</a>
for more information about the topology of the network, such as
the number of nodes, how they are connected, and the length of each connection.
</p>
</html>"));
        end Network;

        model Network_N "Three phases unbalanced AC network with neutral cable"
          extends Transmission.BaseClasses.PartialNetwork(
            redeclare
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal4_p
              terminal,
            redeclare replaceable Transmission.Grids.TestGrid2Nodes grid,
            redeclare ProsNet.Electrical.AC.ThreePhasesUnbalanced.Lines.Line_N lines(
                commercialCable=grid.cables));
          Modelica.Units.SI.Voltage VAbs[3,grid.nNodes] "RMS voltage of the grid nodes";
        equation
          for i in 1:grid.nLinks loop
            connect(lines[i].terminal_p, terminal[grid.fromTo[i,1]]);
            connect(lines[i].terminal_n, terminal[grid.fromTo[i,2]]);
          end for;

          for i in 1:grid.nNodes loop
            VAbs[1, i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].phase[1].v - terminal[i].phase[4].v);
            VAbs[2, i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].phase[2].v - terminal[i].phase[4].v);
            VAbs[3, i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal[i].phase[3].v - terminal[i].phase[4].v);
          end for;
          annotation (
          defaultComponentName="net",
         Documentation(revisions="<html>
<ul>
<li>
March 30, 2015, by Michael Wetter:<br/>
Made <code>term</code> replaceable. This was detected
by the OpenModelica regression tests.
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a generalized electrical AC three-phase unbalanced network
with neutral cable.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialNetwork\">
Buildings.Electrical.Transmission.BaseClasses.PartialNetwork</a>
for information about the network model.
</p>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.Grids.PartialGrid\">
Buildings.Electrical.Transmission.Grids.PartialGrid</a>
for more information about the topology of the network, such as
the number of nodes, how they are connected, and the length of each connection.
</p>
</html>"));
        end Network_N;

        model TwoPortInductance "Model of an inductance with two electrical ports"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort;
          parameter Modelica.Units.SI.Inductance L "Inductance";
          OnePhase.Lines.TwoPortInductance  phase1(
            final L=L/3) "Inductance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortInductance phase2(
            final L=L/3) "Inductance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortInductance phase3(
            final L=L/3) "Inductance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
        equation
          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,14},{42,-14}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-140,-28},{140,-60}},
                    textColor={0,0,0},
                  textString="L=%L"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name"),
                  Line(
                  points={{0,0},{12,1.46953e-15}},
                  color={0,0,0},
                  origin={-42,0},
                  rotation=180),
                Ellipse(
                  extent={{-42,14},{-14,-14}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-14,14},{14,-14}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-42,0},{48,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                  color={0,0,0},
                  origin={52,0},
                  rotation=180)}),
            Documentation(info="<html>
<p>
Inductive model that connects two AC three-phase
unbalanced interfaces. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortL.png\"/>
</p>

<p>
The model represents the lumped inductances as shown in the figure above.
Assuming that the inductance <i>L</i> is the overall inductance of the cable,
each line has an inductance equal to <i>L/3</i>.
</p>

</html>",         revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>"));
        end TwoPortInductance;

        model TwoPortInductance_N
          "Model of an inductance with two electrical ports and neutral line cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N;
          parameter Modelica.Units.SI.Inductance L "Inductance";
          parameter Modelica.Units.SI.Inductance Ln "Inductance of neutral cable";
          OnePhase.Lines.TwoPortInductance  phase1(
            final L=L/3) "Inductance line 1"
            annotation (Placement(transformation(extent={{-10,32},{10,52}})));
          OnePhase.Lines.TwoPortInductance phase2(
            final L=L/3) "Inductance line 2"
            annotation (Placement(transformation(extent={{-10,2},{10,22}})));
          OnePhase.Lines.TwoPortInductance phase3(
            final L=L/3) "Inductance line 3"
            annotation (Placement(transformation(extent={{-10,-28},{10,-8}})));
          OnePhase.Lines.TwoPortInductance phase4(
            final L=L/3) "Inductance line 3"
            annotation (Placement(transformation(extent={{-10,-58},{10,-38}})));
        equation
          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,42},{-10,42}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,12},{-10,12}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-18},{-10,-18}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,42},{20,42},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,12},{20,12},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-18},{20,-18},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase4.terminal_p, terminal_p.phase[4]) annotation (Line(
              points={{10,-48},{20,-48},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase4.terminal_n, terminal_n.phase[4]) annotation (Line(
              points={{-10,-48},{-20,-48},{-20,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{14,14},{42,-14}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-140,-28},{140,-60}},
                    textColor={0,0,0},
                  textString="L=%L"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name"),
                  Line(
                  points={{0,0},{12,1.46953e-15}},
                  color={0,0,0},
                  origin={-42,0},
                  rotation=180),
                Ellipse(
                  extent={{-42,14},{-14,-14}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-14,14},{14,-14}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-42,0},{48,-16}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                  color={0,0,0},
                  origin={52,0},
                  rotation=180)}),
            Documentation(info="<html>
<p>
Inductive model that connects two AC three-phase
unbalanced interfaces with neutral line. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortL_N.png\"/>
</p>

<p>
The model represents the lumped inductances as shown in the figure above.
Assuming that the inductance <i>L</i> is the overall inductance of the cable,
each line has an inductance equal to <i>L/3</i>.
</p>
<p>
The inductance of the neutral cable is defined separately using the parameter
<code>Ln</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added model and user guide
</li>
</ul>
</html>"));
        end TwoPortInductance_N;

        model TwoPortMatrixRL
          "Model of an RL line parameterized with impedance matrices"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));
          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
            "Nominal voltage (V_nominal >= 0)"
            annotation (Evaluate=true, Dialog(group="Nominal conditions"));
          parameter Modelica.Units.SI.Impedance Z11[2]
            "Element [1,1] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z12[2]
            "Element [1,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z13[2]
            "Element [1,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z22[2]
            "Element [2,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z23[2]
            "Element [2,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z33[2]
            "Element [3,3] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z21=Z12
            "Element [2,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z31=Z13
            "Element [3,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z32=Z23
            "Element [3,1] of impedance matrix";

          Modelica.Units.SI.Current i1[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[1].i "Current in line 1";
          Modelica.Units.SI.Current i2[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[2].i "Current in line 2";
          Modelica.Units.SI.Current i3[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[3].i "Current in line 3";
          Modelica.Units.SI.Voltage v1_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_n.phase[1].v
            "Voltage in line 1 at connector N";
          Modelica.Units.SI.Voltage v2_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[2].v
            "Voltage in line 2 at connector N";
          Modelica.Units.SI.Voltage v3_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[3].v
            "Voltage in line 3 at connector N";
          Modelica.Units.SI.Voltage v1_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_p.phase[1].v
            "Voltage in line 1 at connector P";
          Modelica.Units.SI.Voltage v2_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[2].v
            "Voltage in line 2 at connector P";
          Modelica.Units.SI.Voltage v3_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[3].v
            "Voltage in line 3 at connector P";

        protected
          function productAC1p =
              ProsNet.Electrical.PhaseSystems.OnePhase.product
            "Product between complex quantities";
        equation

          // Link the connectors to propagate the overdetermined variable
          for i in 1:3 loop
              Connections.branch(terminal_p.phase[i].theta, terminal_n.phase[i].theta);
              terminal_p.phase[i].theta = terminal_n.phase[i].theta;

              // No current losses, they are preserved in each line
              terminal_p.phase[i].i = - terminal_n.phase[i].i;
          end for;

          // Voltage drop caused by the impedance matrix
          v1_n - v1_p = productAC1p(Z11, i1) + productAC1p(Z12, i2) + productAC1p(Z13, i3);
          v2_n - v2_p = productAC1p(Z21, i1) + productAC1p(Z22, i2) + productAC1p(Z23, i3);
          v3_n - v3_p = productAC1p(Z31, i1) + productAC1p(Z32, i2) + productAC1p(Z33, i3);

          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,40},{70,-40}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-26,16},{10,4}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Text(
                    extent={{-140,100},{140,60}},
                    textColor={0,0,0},
                  textString="%name"),
                  Text(
                    extent={{-70,10},{70,-10}},
                    textColor={0,0,0},
                  textString="R+jX 3x3")}),
            Documentation(revisions="<html>
<ul>
<li>
April 5, 2022, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminals.
This is required for
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.UnbalancedStepUp.DD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.UnbalancedStepUp.DD</a>
to converge with Dymola 2023 beta3.
Inspecting the homotopy trajectory showed that this variable diverged to an unreasonable value.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Removed zero start value for currents <code>i1</code>, <code>i2</code> and
<code>i3</code>.
Setting a zero start value led Dymola 2017 on Linux to find a different solution
for
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BalancedStepDown.YD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BalancedStepDown.YD</a>.
Also, the current is typically non-zero and zero is anyway the default start value, hence there is no need to set it.<br/>
Made current and voltage public to allow setting start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
<li>
June 5, 2014, by Marco Bonvini:<br/>
Added model.
</li>
</ul>
</html>",         info="<html>
<p>
Resistive-inductive model that connects two AC three-phase
unbalanced interfaces. This model can be used to represent a
cable in a three-phase unbalanced AC system.
The voltage between the ports is
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRLMatrix.png\"/>
</p>

<p>
where <i>V<sub>i</sub><sup>{p,n}</sup></i> is the voltage phasor at the connector <code>p</code> or
<code>n</code> of the <i>i</i>-th phase, while <i>I<sub>i</sub><sup>p</sup></i>
the current phasor entering from the connector <code>p</code> of the <i>i</i>-th phase.
</p>

<p>
The model is parameterized with an impedance matrix <i>Z</i>.
The matrix is symmetric thus just the upper triangular
part of it has to be defined.
</p>

</html>"));
        end TwoPortMatrixRL;

        model TwoPortMatrixRLC
          "PI model of a line parameterized with impedance and admittance matrices"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));
          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
            "Nominal voltage (V_nominal >= 0)"
            annotation (Evaluate=true, Dialog(group="Nominal conditions"));
          parameter Modelica.Units.SI.Impedance Z11[2]
            "Element [1,1] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z12[2]
            "Element [1,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z13[2]
            "Element [1,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z22[2]
            "Element [2,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z23[2]
            "Element [2,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z33[2]
            "Element [3,3] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z21=Z12
            "Element [2,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z31=Z13
            "Element [3,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z32=Z23
            "Element [3,1] of impedance matrix";

          parameter Modelica.Units.SI.Admittance B11
            "Element [1,1] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B12
            "Element [1,2] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B13
            "Element [1,3] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B22
            "Element [2,2] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B23
            "Element [2,3] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B33
            "Element [3,3] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B21=B12
            "Element [2,1] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B31=B13
            "Element [3,1] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B32=B23
            "Element [3,2] of admittance matrix";

          Modelica.Units.SI.Voltage v1_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_n.phase[1].v
            "Voltage in line 1 at connector N";
          Modelica.Units.SI.Voltage v2_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[2].v
            "Voltage in line 2 at connector N";
          Modelica.Units.SI.Voltage v3_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[3].v
            "Voltage in line 3 at connector N";
          Modelica.Units.SI.Voltage v1_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_p.phase[1].v
            "Voltage in line 1 at connector P";
          Modelica.Units.SI.Voltage v2_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[2].v
            "Voltage in line 2 at connector P";
          Modelica.Units.SI.Voltage v3_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[3].v
            "Voltage in line 3 at connector P";

        protected
          function productAC1p =
              ProsNet.Electrical.PhaseSystems.OnePhase.product
            "Product between complex quantities";
          Modelica.Units.SI.Current Isr[3,2](start=zeros(3,ProsNet.Electrical.PhaseSystems.OnePhase.n),
              each stateSelect=StateSelect.prefer)
            "Currents that pass through the lines";
          Modelica.Units.SI.Current Ish_p[3,2](start=zeros(3,ProsNet.Electrical.PhaseSystems.OnePhase.n),
              each stateSelect=StateSelect.prefer) "Shunt current on side p";
          Modelica.Units.SI.Current Ish_n[3,2](start=zeros(3,ProsNet.Electrical.PhaseSystems.OnePhase.n),
              each stateSelect=StateSelect.prefer) "Shunt current on side n";

        equation

          // Link the connectors to propagate the overdetermined variable
          for i in 1:3 loop
              Connections.branch(terminal_p.phase[i].theta, terminal_n.phase[i].theta);
              terminal_p.phase[i].theta = terminal_n.phase[i].theta;
          end for;

          // Kirkoff current law for the terminal n (left side)
          Isr[1,:] = terminal_n.phase[1].i - Ish_n[1,:];
          Isr[2,:] = terminal_n.phase[2].i - Ish_n[2,:];
          Isr[3,:] = terminal_n.phase[3].i - Ish_n[3,:];

          // Kirkoff current law for the terminal p (right side)
          Isr[1,:] + terminal_p.phase[1].i = Ish_p[1,:];
          Isr[2,:] + terminal_p.phase[2].i = Ish_p[2,:];
          Isr[3,:] + terminal_p.phase[3].i = Ish_p[3,:];

          // Voltage drop caused by the impedance matrix
          terminal_n.phase[1].v - terminal_p.phase[1].v = productAC1p(Z11, terminal_n.phase[1].i)
                                                        + productAC1p(Z12, terminal_n.phase[2].i)
                                                        + productAC1p(Z13, terminal_n.phase[3].i);
          terminal_n.phase[2].v - terminal_p.phase[2].v = productAC1p(Z21, terminal_n.phase[1].i)
                                                        + productAC1p(Z22, terminal_n.phase[2].i)
                                                        + productAC1p(Z23, terminal_n.phase[3].i);
          terminal_n.phase[3].v - terminal_p.phase[3].v = productAC1p(Z31, terminal_n.phase[1].i)
                                                        + productAC1p(Z32, terminal_n.phase[2].i)
                                                        + productAC1p(Z33, terminal_n.phase[3].i);

          // Current loss at the terminal n
          Ish_n[1,:] = productAC1p({0, B11/2}, v1_n)
                     + productAC1p({0, B12/2}, v2_n)
                     + productAC1p({0, B13/2}, v3_n);
          Ish_n[2,:] = productAC1p({0, B21/2}, v1_n)
                     + productAC1p({0, B22/2}, v2_n)
                     + productAC1p({0, B23/2}, v3_n);
          Ish_n[3,:] = productAC1p({0, B31/2}, v1_n)
                     + productAC1p({0, B32/2}, v2_n)
                     + productAC1p({0, B33/2}, v3_n);

          // Current loss at the terminal n
          Ish_p[1,:] = productAC1p({0, B11/2}, v1_p)
                     + productAC1p({0, B12/2}, v2_p)
                     + productAC1p({0, B13/2}, v3_p);
          Ish_p[2,:] = productAC1p({0, B21/2}, v1_p)
                     + productAC1p({0, B22/2}, v2_p)
                     + productAC1p({0, B23/2}, v3_p);
          Ish_p[3,:] = productAC1p({0, B31/2}, v1_p)
                     + productAC1p({0, B32/2}, v2_p)
                     + productAC1p({0, B33/2}, v3_p);

          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,40},{70,-40}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-140,100},{140,60}},
                    textColor={0,0,0},
                  textString="%name"),
                  Text(
                    extent={{-72,30},{70,10}},
                    textColor={0,0,0},
                  textString="R+jX 3x3"),
                  Text(
                    extent={{-72,-10},{70,-30}},
                    textColor={0,0,0},
                  textString="C 3x3")}),
            Documentation(revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Made current and voltage public to allow setting start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
<li>
June 5, 2014, by Marco Bonvini:<br/>
Added model.
</li>
</ul>
</html>",         info="<html>
<p>
RLC line model (&pi;-model) that connects two AC three-phase
unbalanced interfaces. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRLCMatrix.png\"/>
</p>

<p>
The model is parameterized with an impedance matrix <i>Z</i> and
an admittance matrix <i>B</i>.
The impedance matrix is symmetric, and therefore only the upper triangular
part of the matrix needs to be defined.
</p>

<p>
This model is a more detailed version of the model <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortMatrixRL\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortMatrixRL</a> that includes
the capacitive effects of the lines.
</p>

</html>"));
        end TwoPortMatrixRLC;

        model TwoPortMatrixRLC_N
          "PI model of a line parameterized with impedance and admittance matrices and neutral line"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));

          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
            "Nominal voltage (V_nominal >= 0)"
            annotation (Evaluate=true, Dialog(group="Nominal conditions"));
          parameter Modelica.Units.SI.Impedance Z11[2]
            "Element [1,1] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z12[2]
            "Element [1,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z13[2]
            "Element [1,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z14[2]
            "Element [1,4] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z22[2]
            "Element [2,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z23[2]
            "Element [2,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z24[2]
            "Element [2,4] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z33[2]
            "Element [3,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z34[2]
            "Element [3,4] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z44[2]
            "Element [4,4] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z21=Z12
            "Element [2,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z31=Z13
            "Element [3,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z32=Z23
            "Element [3,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z41=Z14
            "Element [4,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z42=Z24
            "Element [4,2] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z43=Z34
            "Element [4,3] of impedance matrix";

          parameter Modelica.Units.SI.Admittance B11
            "Element [1,1] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B12
            "Element [1,2] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B13
            "Element [1,3] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B14
            "Element [1,4] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B22
            "Element [2,2] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B23
            "Element [2,3] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B24
            "Element [2,4] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B33
            "Element [3,3] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B34
            "Element [3,4] of admittance matrix";
          parameter Modelica.Units.SI.Admittance B44
            "Element [4,4] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B21=B12
            "Element [2,1] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B31=B13
            "Element [3,1] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B32=B23
            "Element [3,2] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B41=B14
            "Element [4,1] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B42=B24
            "Element [4,2] of admittance matrix";
          final parameter Modelica.Units.SI.Admittance B43=B34
            "Element [4,3] of admittance matrix";

          Modelica.Units.SI.Voltage v1_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_n.phase[1].v
            "Voltage in line 1 at connector N";
          Modelica.Units.SI.Voltage v2_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[2].v
            "Voltage in line 2 at connector N";
          Modelica.Units.SI.Voltage v3_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[3].v
            "Voltage in line 3 at connector N";
          Modelica.Units.SI.Voltage v4_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  0),
            each stateSelect=StateSelect.never) = terminal_n.phase[4].v
            "Voltage in line 4 (neutral) at connector N";
          Modelica.Units.SI.Voltage v1_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_p.phase[1].v
            "Voltage in line 1 at connector P";
          Modelica.Units.SI.Voltage v2_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[2].v
            "Voltage in line 2 at connector P";
          Modelica.Units.SI.Voltage v3_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[3].v
            "Voltage in line 3 at connector P";
          Modelica.Units.SI.Voltage v4_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  0),
            each stateSelect=StateSelect.never) = terminal_p.phase[4].v
            "Voltage in line 4 (neutral) at connector P";

        protected
          function productAC1p =
              ProsNet.Electrical.PhaseSystems.OnePhase.product
            "Product between complex quantities";
          Modelica.Units.SI.Current Isr[4,2](each stateSelect=StateSelect.prefer)
            "Currents that pass through the lines";
          Modelica.Units.SI.Current Ish_p[4,2](each stateSelect=StateSelect.prefer)
            "Shunt current on side p";
          Modelica.Units.SI.Current Ish_n[4,2](each stateSelect=StateSelect.prefer)
            "Shunt current on side n";

        equation

          // Link the connectors to propagate the overdetermined variable
          for i in 1:4 loop
              Connections.branch(terminal_p.phase[i].theta, terminal_n.phase[i].theta);
              terminal_p.phase[i].theta = terminal_n.phase[i].theta;
          end for;

          // Kirkoff current law for the terminal n (left side)
          Isr[1,:] = terminal_n.phase[1].i - Ish_n[1,:];
          Isr[2,:] = terminal_n.phase[2].i - Ish_n[2,:];
          Isr[3,:] = terminal_n.phase[3].i - Ish_n[3,:];
          Isr[4,:] = terminal_n.phase[4].i - Ish_n[4,:];

          // Kirkoff current law for the terminal p (right side)
          Isr[1,:] + terminal_p.phase[1].i = Ish_p[1,:];
          Isr[2,:] + terminal_p.phase[2].i = Ish_p[2,:];
          Isr[3,:] + terminal_p.phase[3].i = Ish_p[3,:];
          Isr[4,:] + terminal_p.phase[4].i = Ish_p[4,:];

          // Voltage drop caused by the impedance matrix
          terminal_n.phase[1].v - terminal_p.phase[1].v = productAC1p(Z11, terminal_n.phase[1].i)
                                                        + productAC1p(Z12, terminal_n.phase[2].i)
                                                        + productAC1p(Z13, terminal_n.phase[3].i)
                                                        + productAC1p(Z14, terminal_n.phase[4].i);
          terminal_n.phase[2].v - terminal_p.phase[2].v = productAC1p(Z21, terminal_n.phase[1].i)
                                                        + productAC1p(Z22, terminal_n.phase[2].i)
                                                        + productAC1p(Z23, terminal_n.phase[3].i)
                                                        + productAC1p(Z24, terminal_n.phase[4].i);
          terminal_n.phase[3].v - terminal_p.phase[3].v = productAC1p(Z31, terminal_n.phase[1].i)
                                                        + productAC1p(Z32, terminal_n.phase[2].i)
                                                        + productAC1p(Z33, terminal_n.phase[3].i)
                                                        + productAC1p(Z34, terminal_n.phase[4].i);
          terminal_n.phase[4].v - terminal_p.phase[4].v = productAC1p(Z41, terminal_n.phase[1].i)
                                                        + productAC1p(Z42, terminal_n.phase[2].i)
                                                        + productAC1p(Z43, terminal_n.phase[3].i)
                                                        + productAC1p(Z44, terminal_n.phase[4].i);

          // Current loss at the terminal n
          Ish_n[1,:] = productAC1p({0, B11/2}, v1_n)
                     + productAC1p({0, B12/2}, v2_n)
                     + productAC1p({0, B13/2}, v3_n)
                     + productAC1p({0, B14/2}, v4_n);
          Ish_n[2,:] = productAC1p({0, B21/2}, v1_n)
                     + productAC1p({0, B22/2}, v2_n)
                     + productAC1p({0, B23/2}, v3_n)
                     + productAC1p({0, B24/2}, v4_n);
          Ish_n[3,:] = productAC1p({0, B31/2}, v1_n)
                     + productAC1p({0, B32/2}, v2_n)
                     + productAC1p({0, B33/2}, v3_n)
                     + productAC1p({0, B34/2}, v4_n);
          Ish_n[4,:] = productAC1p({0, B41/2}, v1_n)
                     + productAC1p({0, B42/2}, v2_n)
                     + productAC1p({0, B43/2}, v3_n)
                     + productAC1p({0, B44/2}, v4_n);

          // Current loss at the terminal n
          Ish_p[1,:] = productAC1p({0, B11/2}, v1_p)
                     + productAC1p({0, B12/2}, v2_p)
                     + productAC1p({0, B13/2}, v3_p)
                     + productAC1p({0, B14/2}, v4_p);
          Ish_p[2,:] = productAC1p({0, B21/2}, v1_p)
                     + productAC1p({0, B22/2}, v2_p)
                     + productAC1p({0, B23/2}, v3_p)
                     + productAC1p({0, B24/2}, v4_p);
          Ish_p[3,:] = productAC1p({0, B31/2}, v1_p)
                     + productAC1p({0, B32/2}, v2_p)
                     + productAC1p({0, B33/2}, v3_p)
                     + productAC1p({0, B34/2}, v4_p);
          Ish_p[4,:] = productAC1p({0, B41/2}, v1_p)
                     + productAC1p({0, B42/2}, v2_p)
                     + productAC1p({0, B43/2}, v3_p)
                     + productAC1p({0, B44/2}, v4_p);

          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,40},{70,-40}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-140,100},{140,60}},
                    textColor={0,0,0},
                  textString="%name"),
                  Text(
                    extent={{-72,30},{70,10}},
                    textColor={0,0,0},
                  textString="R+jX 4x4"),
                  Text(
                    extent={{-72,-10},{70,-30}},
                    textColor={0,0,0},
                  textString="C 4x4")}),
            Documentation(revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Made current and voltage public to allow setting start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Removed zero start value for currents <code>i1</code>, <code>i2</code> and
<code>i3</code>.
Setting a zero start value led Dymola 2017 on Linux to find a different solution
for
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BalancedStepDown.YD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BalancedStepDown.YD</a>.
Also, the current is typically non-zero and zero is anyway the default start value, hence there is no need to set it.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",         info="<html>
<p>
RLC line model (&pi;-model) that connects two AC three-phase
unbalanced interfaces and neutral line. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRLCMatrix_N.png\"/>
</p>

<p>
The model is parameterized with an impedance matrix <i>Z</i> and
an admittance matrix <i>B</i>.
The impedance matrix is symmetric, and therefore only the upper triangular
part of the matrix needs to be defined.
</p>

<p>
This model is a more detailed version of the model <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortMatrixRL_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortMatrixRL_N</a> that includes
the capacitive effects of the lines.
</p>

<h4>Note</h4>
<p>
The fourth line is the neutral one.
</p>

</html>"));
        end TwoPortMatrixRLC_N;

        model TwoPortMatrixRL_N
          "Model of an RL line parameterized with impedance matrices and neutral line"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));

          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
            "Nominal voltage (V_nominal >= 0)"
            annotation (Evaluate=true, Dialog(group="Nominal conditions"));
          parameter Modelica.Units.SI.Impedance Z11[2]
            "Element [1,1] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z12[2]
            "Element [1,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z13[2]
            "Element [1,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z14[2]
            "Element [1,4] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z22[2]
            "Element [2,2] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z23[2]
            "Element [2,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z24[2]
            "Element [2,4] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z33[2]
            "Element [3,3] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z34[2]
            "Element [3,4] of impedance matrix";
          parameter Modelica.Units.SI.Impedance Z44[2]
            "Element [4,4] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z21=Z12
            "Element [2,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z31=Z13
            "Element [3,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z32=Z23
            "Element [3,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z41=Z14
            "Element [4,1] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z42=Z24
            "Element [4,2] of impedance matrix";
          final parameter Modelica.Units.SI.Impedance[2] Z43=Z34
            "Element [4,3] of impedance matrix";

          Modelica.Units.SI.Current i1[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[1].i "Current in line 1";
          Modelica.Units.SI.Current i2[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[2].i "Current in line 2";
          Modelica.Units.SI.Current i3[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[3].i "Current in line 3";
          Modelica.Units.SI.Current i4[2](each stateSelect=StateSelect.prefer)=
            terminal_n.phase[4].i "Current in line 4 (neutral)";
          Modelica.Units.SI.Voltage v1_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_n.phase[1].v
            "Voltage in line 1 at connector N";
          Modelica.Units.SI.Voltage v2_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[2].v
            "Voltage in line 2 at connector N";
          Modelica.Units.SI.Voltage v3_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_n.phase[3].v
            "Voltage in line 3 at connector N";
          Modelica.Units.SI.Voltage v4_n[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  0),
            each stateSelect=StateSelect.never) = terminal_n.phase[4].v
            "Voltage in line 4 (neutral) at connector N";
          Modelica.Units.SI.Voltage v1_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=0),
            each stateSelect=StateSelect.never) = terminal_p.phase[1].v
            "Voltage in line 1 at connector P";
          Modelica.Units.SI.Voltage v2_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=-2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[2].v
            "Voltage in line 2 at connector P";
          Modelica.Units.SI.Voltage v3_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  V_nominal/
                sqrt(3), phi=2*Modelica.Constants.pi/3),
            each stateSelect=StateSelect.never) = terminal_p.phase[3].v
            "Voltage in line 3 at connector P";
          Modelica.Units.SI.Voltage v4_p[2](
            start=ProsNet.Electrical.PhaseSystems.OnePhase.phaseVoltages(  0),
            each stateSelect=StateSelect.never) = terminal_p.phase[4].v
            "Voltage in line 4 (neutral) at connector P";

        protected
          function productAC1p =
              ProsNet.Electrical.PhaseSystems.OnePhase.product
            "Product between complex quantities";
        equation

          // Link the connectors to propagate the overdetermined variable
          for i in 1:4 loop
              Connections.branch(terminal_p.phase[i].theta, terminal_n.phase[i].theta);
              terminal_p.phase[i].theta = terminal_n.phase[i].theta;

              // No current losses, they are preserved in each line
              terminal_p.phase[i].i = - terminal_n.phase[i].i;
          end for;

          // Voltage drop caused by the impedance matrix
          v1_n - v1_p = productAC1p(Z11, i1) + productAC1p(Z12, i2) + productAC1p(Z13, i3)+ productAC1p(Z14, i4);
          v2_n - v2_p = productAC1p(Z21, i1) + productAC1p(Z22, i2) + productAC1p(Z23, i3)+ productAC1p(Z24, i4);
          v3_n - v3_p = productAC1p(Z31, i1) + productAC1p(Z32, i2) + productAC1p(Z33, i3)+ productAC1p(Z34, i4);
          v4_n - v4_p = productAC1p(Z41, i1) + productAC1p(Z42, i2) + productAC1p(Z43, i3)+ productAC1p(Z44, i4);

          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,40},{70,-40}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-26,16},{10,4}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Text(
                    extent={{-140,100},{140,60}},
                    textColor={0,0,0},
                  textString="%name"),
                  Text(
                    extent={{-70,10},{70,-10}},
                    textColor={0,0,0},
                  textString="R+jX 4x4")}),
            Documentation(revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Made current and voltage public to allow setting start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Removed zero start value for currents <code>i1</code>, <code>i2</code> and
<code>i3</code>.
Setting a zero start value led Dymola 2017 on Linux to find a different solution
for
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BalancedStepDown.YD\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BalancedStepDown.YD</a>.
Also, the current is typically non-zero and zero is anyway the default start value, hence there is no need to set it.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documantation.
</li>
</ul>
</html>",         info="<html>
<p>
Resistive-inductive model that connects two AC three-phase
unbalanced interfaces with neutral line. This model can be used to represent a
cable in a three-phase unbalanced AC system.
The voltage between the ports is
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRLMatrix_N.png\"/>
</p>

<p>
where <i>V<sub>i</sub><sup>{p,n}</sup></i> is the voltage phasor at the connector <code>p</code> or
<code>n</code> of the <i>i</i>-th phase, while <i>I<sub>i</sub><sup>p</sup></i>
the current phasor entering from the connector <code>p</code> of the <i>i</i>-th phase.
</p>

<p>
The model is parameterized with an impedance matrix <i>Z</i>.
The matrix is symmetric thus just the upper triangular
part of it has to be defined.
</p>

<h4>Note</h4>
<p>
The fourth line is the neutral one.
</p>

</html>"));
        end TwoPortMatrixRL_N;

        model TwoPortRL
          "Model of a resistive-inductive element with two electrical ports"
          extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort;
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort;
          parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature M=507.65
            "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Inductance L "Inductance";
          parameter Modelica.Units.SI.Current i1_start[2]={0,0}
            "Initial current phasor of phase 1 (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Current i2_start[2]={0,0}
            "Initial current phasor of phase 2 (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Current i3_start[2]={0,0}
            "Initial current phasor of phase 3 (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.FixedZ_dynamic)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
          OnePhase.Lines.TwoPortRL phase1(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=mode,
            final useHeatPort=useHeatPort,
            i_start=i1_start) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortRL phase2(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=mode,
            final useHeatPort=useHeatPort,
            i_start=i2_start) "Impedance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortRL phase3(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=mode,
            final useHeatPort=useHeatPort,
            i_start=i3_start) "Impedance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
        equation
          // Joule Losses
          LossPower = phase1.LossPower + phase2.LossPower + phase3.LossPower;

          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-99.95,0.05},{-20,0.05},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-99.95,0.05},{-54,0.05},{-54,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-99.95,0.05},{-20,0.05},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0.05},{100.05,0.05}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{56,0},{56,0.05},{100.05,0.05}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0.05},{100.05,0.05}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase1.heatPort, heatPort) annotation (Line(
              points={{0,20},{0,14},{-32,14},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase3.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-40},{0,-40},{0,-100},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase2.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-10},{4.44089e-16,-16},{-32,-16},{-32,-72},{
                  4.44089e-16,-72},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Text(
                    extent={{-150,-28},{136,-60}},
                    textColor={0,0,0},
                  textString="R=%R, L=%L"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{66,8.0824e-15}},
                  color={0,0,0},
                  origin={52,0},
                  rotation=180),
                Line(
                  points={{-48,0},{-42,0},{-40,4},{-36,-4},{-32,4},{-28,-4},{-24,4},{-20,
                      -4},{-18,0},{-14,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-6,6},{6,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{6,6},{18,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{18,6},{30,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-6,0},{30,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Resistive-inductive model that connects two AC three-phase
unbalanced interfaces. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRL.png\"/>
</p>

<p>
The model represents the lumped impedances as shown in the figure above.
Assuming that the overall cable has a resistance <i>R</i> and an inductance
<i>L</i>, each line has an inductance equal to <i>L/3</i> and a resistance
equal to <i>R/3</i>.
</p>

</html>",         revisions="<html>
<ul>
<li>
March 9, 2015, by Marco Bonvini:<br/>
Added parameter for start value of the current.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
</ul>
</html>"));
        end TwoPortRL;

        model TwoPortRLC "Model of an RLC element with two electrical ports"
          extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort;
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));

          parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref";
          parameter Modelica.Units.SI.Capacitance C "Capacity";
          parameter Modelica.Units.SI.Inductance L "Inductance";
          parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature M=507.65
            "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Voltage Vc1_start[2]=V_nominal/sqrt(3)*{1,0}
            "Initial voltage phasor of the capacitance located in the middle of phase 1"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Voltage Vc2_start[2]=V_nominal/sqrt(3)*{-1/2,-
              sqrt(3)/2}
            "Initial voltage phasor of the capacitance located in the middle of phase 1"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Voltage Vc3_start[2]=V_nominal/sqrt(3)*{-1/2,+
              sqrt(3)/2}
            "Initial voltage phasor of the capacitance located in the middle of phase 1"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.FixedZ_dynamic)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
            "Nominal voltage (V_nominal >= 0)"
            annotation (Evaluate=true, Dialog(group="Nominal conditions"));
          OnePhase.Lines.TwoPortRLC phase1(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final C=C/3,
            final mode=mode,
            final V_nominal = V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            Vc_start=Vc1_start) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortRLC phase2(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final C=C/3,
            final mode=mode,
            final V_nominal = V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            Vc_start=Vc2_start) "Impedance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortRLC phase3(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final C=C/3,
            final mode=mode,
            final V_nominal = V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            Vc_start=Vc3_start) "Impedance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
        equation
          // Joule Losses
          LossPower = phase1.LossPower + phase2.LossPower + phase3.LossPower;

          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase1.heatPort, heatPort) annotation (Line(
              points={{0,20},{0,14},{-32,14},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase3.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-40},{0,-40},{0,-100},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase2.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-10},{4.44089e-16,-16},{-32,-16},{-32,-72},{
                  4.44089e-16,-72},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Text(
                    extent={{-150,-28},{136,-60}},
                    textColor={0,0,0},
                  textString="R=%R, L=%L"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{96,1.22003e-14}},
                  color={0,0,0},
                  origin={62,16},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-4.17982e-15,16}},
                  color={0,0,0},
                  origin={20,16},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{16,1.95937e-15}},
                  color={0,0,0},
                  origin={28,0},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{16,1.95937e-15}},
                  color={0,0,0},
                  origin={28,-4},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-2.40346e-15,16}},
                  color={0,0,0},
                  origin={20,-4},
                  rotation=180),
                Line(
                  points={{-68,16},{-62,16},{-60,20},{-56,12},{-52,20},{-48,12},{-44,20},
                      {-40,12},{-38,16},{-34,16}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-26,22},{-14,10}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-14,22},{-2,10}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2,22},{10,10}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-26,16},{10,4}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Text(
                    extent={{-144,-56},{142,-88}},
                    textColor={0,0,0},
                  textString="C=%C"),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
RLC line model (T-model) that connects two AC three-phase
unbalanced interfaces. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRLC.png\"/>
</p>

<p>
The model represents the lumped impedances as shown in the figure above.
Assuming that the overall cable has a resistance <i>R</i>, an inductance
<i>L</i>, and a capacitance <i>C</i>, each line has an inductance equal
to <i>L/3</i>, a resistance equal to <i>R/3</i> and a capacity equal to
<i>C/3</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
September 17, 2016, by Michael Wetter:<br/>
Corrected wrong annotation to avoid an error in the pedantic model check
in Dymola 2017 FD01 beta2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
March 9, 2015, by Marco Bonvini:<br/>
Added parameter for start value of the voltage.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
October 6, 2014, by Marco Bonvini:<br/>
Revised documentation and model.
</li>
</ul>
</html>"));
        end TwoPortRLC;

        model TwoPortRLC_N
          "Model of an RLC element with two electrical ports and neutral line cable"
          extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort;
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N(
              terminal_p(phase(v(each nominal=V_nominal))), terminal_n(phase(v(
                    each nominal=V_nominal))));

          parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref";
          parameter Modelica.Units.SI.Resistance Rn
            "Resistance of neutral cable at temperature T_ref";
          parameter Modelica.Units.SI.Capacitance C "Capacity";
          parameter Modelica.Units.SI.Capacitance Cn "Capacityof neutral cable";
          parameter Modelica.Units.SI.Inductance L "Inductance";
          parameter Modelica.Units.SI.Inductance Ln "Inductance of neutral cable";
          parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature M=507.65
            "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Voltage Vc1_start[2]=V_nominal/sqrt(3)*{1,0}
            "Initial voltage phasor of the capacitance located in the middle of phase 1"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Voltage Vc2_start[2]=V_nominal/sqrt(3)*{-1/2,-
              sqrt(3)/2}
            "Initial voltage phasor of the capacitance located in the middle of phase 1"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Voltage Vc3_start[2]=V_nominal/sqrt(3)*{-1/2,+
              sqrt(3)/2}
            "Initial voltage phasor of the capacitance located in the middle of phase 1"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.FixedZ_dynamic)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
          parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
            "Nominal voltage (V_nominal >= 0)"
            annotation (Evaluate=true, Dialog(group="Nominal conditions"));
          OnePhase.Lines.TwoPortRLC phase1(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final C=C/3,
            final mode=mode,
            final V_nominal = V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            Vc_start=Vc1_start) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortRLC phase2(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final C=C/3,
            final mode=mode,
            final V_nominal = V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            Vc_start=Vc2_start) "Impedance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortRLC phase3(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final C=C/3,
            final mode=mode,
            final V_nominal = V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            Vc_start=Vc3_start) "Impedance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          OnePhase.Lines.TwoPortRLC neutral(
            final T_ref=T_ref,
            final M=M,
            final mode=mode,
            final V_nominal=V_nominal/sqrt(3),
            final useHeatPort=useHeatPort,
            final R=Rn,
            final C=Cn,
            final L=Ln,
            Vc_start=-Vc1_start - Vc2_start - Vc3_start) "Neutral line RLC model"
            annotation (Placement(transformation(extent={{-10,-64},{10,-44}})));
        equation
          // Joule Losses
          LossPower = phase1.LossPower + phase2.LossPower + phase3.LossPower + neutral.LossPower;

          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase1.heatPort, heatPort) annotation (Line(
              points={{0,20},{0,14},{-32,14},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase3.heatPort, heatPort) annotation (Line(
              points={{0,-40},{-32,-40},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase2.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-10},{4.44089e-16,-16},{-32,-16},{-32,-72},{
                  4.44089e-16,-72},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(neutral.terminal_p, terminal_p.phase[4]) annotation (Line(
              points={{10,-54},{20,-54},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(neutral.terminal_n, terminal_n.phase[4]) annotation (Line(
              points={{-10,-54},{-20,-54},{-20,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(neutral.heatPort, heatPort) annotation (Line(
              points={{0,-64},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Text(
                    extent={{-150,-28},{136,-60}},
                    textColor={0,0,0},
                  textString="R=%R, L=%L"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{96,1.22003e-14}},
                  color={0,0,0},
                  origin={62,16},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-4.17982e-15,16}},
                  color={0,0,0},
                  origin={20,16},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{16,1.95937e-15}},
                  color={0,0,0},
                  origin={28,0},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{16,1.95937e-15}},
                  color={0,0,0},
                  origin={28,-4},
                  rotation=180),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{-2.40346e-15,16}},
                  color={0,0,0},
                  origin={20,-4},
                  rotation=180),
                Line(
                  points={{-68,16},{-62,16},{-60,20},{-56,12},{-52,20},{-48,12},{-44,20},
                      {-40,12},{-38,16},{-34,16}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-26,22},{-14,10}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-14,22},{-2,10}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-2,22},{10,10}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-26,16},{10,4}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Text(
                    extent={{-144,-56},{142,-88}},
                    textColor={0,0,0},
                  textString="C=%C"),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
RLC line model (T-model) that connects two AC three-phase
unbalanced interfaces with neutral line. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRLC_N.png\"/>
</p>

<p>
The model represents the lumped impedances as shown in the figure above.
Assuming that the overall cable has a resistance <i>R</i>, an inductance
<i>L</i>, and a capacitance <i>C</i>, each line has an inductance equal
to <i>L/3</i>, a resistance equal to <i>R/3</i> and a capacity equal to
<i>C/3</i>.
</p>
<p>
The resistance, capacitance and inductance of the neutral cable are defined separately using the parameters
<code>Rn</code> <code>Cn</code>, and <code>Ln</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 5, 2023, by Michael Wetter:<br/>
Set nominal attribute for voltage at terminal.
</li>
<li>
September 17, 2016, by Michael Wetter:<br/>
Corrected wrong annotation to avoid an error in the pedantic model check
in Dymola 2017 FD01 beta2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
March 9, 2015, by Marco Bonvini:<br/>
Added parameter for start value of the voltage.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added model and user guide
</li>
</ul>
</html>"));
        end TwoPortRLC_N;

        model TwoPortRL_N
          "Model of a resistive-inductive element with two electrical ports and neutral line cable"
          extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort;
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N;
          parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref";
          parameter Modelica.Units.SI.Resistance Rn
            "Resistance of neutral cable at temperature T_ref";
          parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature M=507.65
            "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Inductance L "Inductance";
          parameter Modelica.Units.SI.Inductance Ln "Inductance of neutral cable";
          parameter Modelica.Units.SI.Current i1_start[2]={0,0}
            "Initial current phasor of phase 1 (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Current i2_start[2]={0,0}
            "Initial current phasor of phase 2 (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter Modelica.Units.SI.Current i3_start[2]={0,0}
            "Initial current phasor of phase 3 (positive if entering from terminal p)"
            annotation (Dialog(enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic)));
          parameter ProsNet.Electrical.Types.Load mode(
            min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            max=ProsNet.Electrical.Types.Load.FixedZ_dynamic)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
            "Type of model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
            annotation (Evaluate=true, Dialog(group="Modeling assumption"));
          OnePhase.Lines.TwoPortRL  phase1(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=mode,
            final useHeatPort=useHeatPort,
            i_start=i1_start) "Impedance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortRL phase2(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=mode,
            final useHeatPort=useHeatPort,
            i_start=i2_start) "Impedance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortRL phase3(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final L=L/3,
            final mode=mode,
            final useHeatPort=useHeatPort,
            i_start=i3_start) "Impedance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          OnePhase.Lines.TwoPortRL neutral(
            final T_ref=T_ref,
            final M=M,
            final mode=mode,
            final useHeatPort=useHeatPort,
            final R=Rn,
            final L=Ln,
            i_start=-i1_start - i2_start - i3_start) "neutral cable RL model"
            annotation (Placement(transformation(extent={{-10,-66},{10,-46}})));
        equation
          // Joule Losses
          LossPower = phase1.LossPower + phase2.LossPower + phase3.LossPower + neutral.LossPower;

          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase1.heatPort, heatPort) annotation (Line(
              points={{0,20},{0,14},{-32,14},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase3.heatPort, heatPort) annotation (Line(
              points={{0,-40},{0,-44},{-32,-44},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase2.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-10},{4.44089e-16,-16},{-32,-16},{-32,-72},{
                  4.44089e-16,-72},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(neutral.heatPort, heatPort) annotation (Line(
              points={{0,-66},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(neutral.terminal_p, terminal_p.phase[4]) annotation (Line(
              points={{10,-56},{20,-56},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(neutral.terminal_n, terminal_n.phase[4]) annotation (Line(
              points={{-10,-56},{-20,-56},{-20,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Text(
                    extent={{-150,-28},{136,-60}},
                    textColor={0,0,0},
                  textString="R=%R, L=%L"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(
                  points={{-6.85214e-44,-8.39117e-60},{66,8.0824e-15}},
                  color={0,0,0},
                  origin={52,0},
                  rotation=180),
                Line(
                  points={{-48,0},{-42,0},{-40,4},{-36,-4},{-32,4},{-28,-4},{-24,4},{-20,
                      -4},{-18,0},{-14,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Ellipse(
                  extent={{-6,6},{6,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{6,6},{18,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{18,6},{30,-6}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-6,0},{30,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Resistive-inductive model that connects two AC three-phase
unbalanced interfaces with neutral line. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortRL_N.png\"/>
</p>

<p>
The model represents the lumped impedances as shown in the figure above.
Assuming that the overall cable has a resistance <i>R</i> and an inductance
<i>L</i>, each line has an inductance equal to <i>L/3</i> and a resistance
equal to <i>R/3</i>.
</p>
<p>
The resistance and the inductance of the neutral cable are defined separately using the parameters
<code>Rn</code> and <code>Ln</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 9, 2015, by Marco Bonvini:<br/>
Added parameter for start value of the current.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added model and user guide
</li>
</ul>
</html>"));
        end TwoPortRL_N;

        model TwoPortResistance "Model of a resistance with two electrical ports"
          extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort;
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort;
          parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature M=507.65
            "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref";
          OnePhase.Lines.TwoPortResistance  phase1(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final useHeatPort=useHeatPort) "Resistance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortResistance phase2(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final useHeatPort=useHeatPort) "Resistance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortResistance phase3(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final useHeatPort=useHeatPort) "Resistance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
        equation
          // Joule Losses
          LossPower = phase1.LossPower + phase2.LossPower + phase3.LossPower;
          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase1.heatPort, heatPort) annotation (Line(
              points={{0,20},{0,14},{-32,14},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase3.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-40},{0,-40},{0,-100},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase2.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-10},{4.44089e-16,-16},{-32,-16},{-32,-72},{
                  4.44089e-16,-72},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Text(
                    extent={{-140,-28},{138,-60}},
                    textColor={0,0,0},
                  textString="R=%R"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Resistive model that connects two AC three-phase
unbalanced interfaces. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortR.png\"/>
</p>

<p>
The model represents the lumped resistance as shown in the figure above.
Assuming that the resistance <i>R</i> is the overall resistance of the cable,
each line has a resistance equal to <i>R/3</i>.
</p>

</html>",         revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>"));
        end TwoPortResistance;

        model TwoPortResistance_N
          "Model of a resistance with two electrical ports and neutral cable"
          extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort;
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.TwoPort_N;
          parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Temperature M=507.65
            "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))"
            annotation (Evaluate=true);
          parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref";
          parameter Modelica.Units.SI.Resistance Rn
            "Resistance of neutral cable at temperature T_ref";
          OnePhase.Lines.TwoPortResistance  phase1(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final useHeatPort=useHeatPort) "Resistance line 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          OnePhase.Lines.TwoPortResistance phase2(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final useHeatPort=useHeatPort) "Resistance line 2"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          OnePhase.Lines.TwoPortResistance phase3(
            final T_ref=T_ref,
            final M=M,
            final R=R/3,
            final useHeatPort=useHeatPort) "Resistance line 3"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          OnePhase.Lines.TwoPortResistance neutral(
            final T_ref=T_ref,
            final M=M,
            final useHeatPort=useHeatPort,
            final R=Rn) "Resistance neutral cable"
            annotation (Placement(transformation(extent={{-10,-64},{10,-44}})));
        equation
          // Joule Losses
          LossPower = phase1.LossPower + phase2.LossPower + phase3.LossPower + neutral.LossPower;
          connect(terminal_n.phase[1], phase1.terminal_n) annotation (Line(
              points={{-100,0},{-20,0},{-20,30},{-10,30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[2], phase2.terminal_n) annotation (Line(
              points={{-100,0},{-10,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(terminal_n.phase[3], phase3.terminal_n) annotation (Line(
              points={{-100,4.44089e-16},{-20,4.44089e-16},{-20,-30},{-10,-30}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase1.terminal_p, terminal_p.phase[1]) annotation (Line(
              points={{10,30},{20,30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase2.terminal_p, terminal_p.phase[2]) annotation (Line(
              points={{10,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(phase3.terminal_p, terminal_p.phase[3]) annotation (Line(
              points={{10,-30},{20,-30},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));

          connect(phase1.heatPort, heatPort) annotation (Line(
              points={{0,20},{0,14},{-32,14},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase3.heatPort, heatPort) annotation (Line(
              points={{0,-40},{-32,-40},{-32,-72},{0,-72},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(phase2.heatPort, heatPort) annotation (Line(
              points={{4.44089e-16,-10},{4.44089e-16,-16},{-32,-16},{-32,-72},{
                  4.44089e-16,-72},{4.44089e-16,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(neutral.heatPort, heatPort) annotation (Line(
              points={{0,-64},{0,-100}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(neutral.terminal_p, terminal_p.phase[4]) annotation (Line(
              points={{10,-54},{20,-54},{20,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(neutral.terminal_n, terminal_n.phase[4]) annotation (Line(
              points={{-10,-54},{-20,-54},{-20,0},{-100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="line",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                       graphics={
                  Text(
                    extent={{-140,-28},{138,-60}},
                    textColor={0,0,0},
                  textString="R=%R"),
                  Line(points={{-92,0},{-72,0}}, color={0,0,0}),
                  Line(points={{68,0},{88,0}}, color={0,0,0}),
                Rectangle(
                  extent={{-72,32},{68,-28}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-142,80},{138,40}},
                    textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Resistive model that connects two AC three-phase
unbalanced interfaces with neutral line. This model can be used to represent a
cable in a three-phase unbalanced AC system.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Lines/twoPortR_N.png\"/>
</p>

<p>
The model represents the lumped resistance as shown in the figure above.
Assuming that the resistance <i>R</i> is the overall resistance of the cable,
each line has a resistance equal to <i>R/3</i>.
</p>
<p>
The resistance of the neutral cable is defined separately using the parameter
<code>Rn</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added model and user guide
</li>
</ul>
</html>"));
        end TwoPortResistance_N;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model ACLine
            "Test model for a three-phase unbalanced commercial cable without neutral"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
            Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{22,20},{42,40}})));
            Loads.Impedance R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{22,-10},{42,10}})));
            Loads.Impedance R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{22,-50},{42,-30}})));
            Line line_1(
              l=1000,
              P_nominal=2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 1"
              annotation (Placement(transformation(extent={{-38,20},{-18,40}})));
            Line line_2a(
              l=500,
              P_nominal=2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 2"
              annotation (Placement(transformation(extent={{-38,-10},{-18,10}})));
            Line line_2b(
              l=500,
              P_nominal=2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 2"
              annotation (Placement(transformation(extent={{-14,-10},{6,10}})));
            Line line_3a(
              l=2000,
              P_nominal=1000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 3"
              annotation (Placement(transformation(extent={{-38,-40},{-18,-20}})));
            Line line_3b(
              l=2000,
              P_nominal=1000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 3"
              annotation (Placement(transformation(extent={{-38,-60},{-18,-40}})));
          equation
            connect(E.terminal, line_1.terminal_n) annotation (Line(
                points={{-60,0},{-50,0},{-50,30},{-38,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_1.terminal_p, R1.terminal) annotation (Line(
                points={{-18,30},{22,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_2a.terminal_n) annotation (Line(
                points={{-60,0},{-50,0},{-50,6.66134e-16},{-38,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2a.terminal_p, line_2b.terminal_n) annotation (Line(
                points={{-18,0},{-14,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_2b.terminal_p, R2.terminal) annotation (Line(
                points={{6,0},{22,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3a.terminal_n) annotation (Line(
                points={{-60,0},{-50,0},{-50,-30},{-38,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, line_3b.terminal_n) annotation (Line(
                points={{-60,0},{-50,0},{-50,-50},{-38,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-18,-30},{2,-30},{2,-40},{22,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-18,-50},{2,-50},{2,-40},{22,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine.mos"
                  "Simulate and plot"),
           Documentation(info="<html>
<p>
This example demonstrates how to use a cable model without neutral line
to connect a source to a load.
</p>
<p>
The model has three resistive loads <code>R1</code>, <code>R2</code>, and <code>R3</code>.
Each load is connected to the source with different configurations,
but the equivalent resistance between each load and the source is the same.
Since the equivalent resistances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine;

          model ACLineMatrix_RL
            "Test model for a three-phase unbalanced inductive-resistive line specified by a Z matrix"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance sc_load1(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Loads.Impedance sc_load2(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            Loads.Impedance sc_load3(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
            Lines.TwoPortMatrixRL Rline_1(
              Z11={10,10},
              Z12={0,0},
              Z13={0,0},
              Z22={10,10},
              Z23={0,0},
              Z33={10,10},
              V_nominal=100*sqrt(3)) "RL line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Lines.TwoPortMatrixRL Rline_2a(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=0.5*{10,10},
              Z22=0.5*{10,10},
              Z33=0.5*{10,10},
              V_nominal=100*sqrt(3)) "RL line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Lines.TwoPortMatrixRL Rline_2b(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=0.5*{10,10},
              Z22=0.5*{10,10},
              Z33=0.5*{10,10},
              V_nominal=100*sqrt(3)) "RL line that connects to load 2"
              annotation (Placement(transformation(extent={{-36,-10},{-16,10}})));
            Lines.TwoPortMatrixRL Rline_3a(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=2*{10,10},
              Z22=2*{10,10},
              Z33=2*{10,10},
              V_nominal=100*sqrt(3)) "RL line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
            Lines.TwoPortMatrixRL Rline_3b(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=2*{10,10},
              Z22=2*{10,10},
              Z33=2*{10,10},
              V_nominal=100*sqrt(3)) "RL line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
          equation
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, sc_load1.terminal) annotation (Line(
                points={{-40,30},{0,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,6.66134e-16},{-60,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,0},{-36,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, sc_load2.terminal) annotation (Line(
                points={{-16,0},{-4.44089e-16,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-30},{-60,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-30},{-20,-30},{-20,-40},{0,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-40},{0,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLineMatrix_RL.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use an inductive resistive line model to connect
a source to a load. The model is parameterized using the impedance matrix <i>Z</i>.
</p>
<p>
The model has three loads. The loads represent a short circuit <i>R=0</i>.
The current that flows through the load depends on the resistance of the line.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLineMatrix_RL;

          model ACLineMatrix_RLC
            "Test model for a three-phase unbalanced RLC line specified by Z and B matrices"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance sc_load1(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Lines.TwoPortMatrixRLC Rline_1(
              Z11={10,10},
              Z12={0,0},
              Z13={0,0},
              Z22={10,10},
              Z23={0,0},
              Z33={10,10},
              V_nominal=100*sqrt(3),
              B12=0,
              B13=0,
              B23=0,
              B11=10,
              B22=10,
              B33=10) "RL line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Lines.TwoPortMatrixRLC Rline_2(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              V_nominal=100*sqrt(3),
              B12=0,
              B13=0,
              B23=0,
              Z11={0,0},
              Z22={0,0},
              Z33={0,0},
              B11=0.1,
              B22=0.1,
              B33=0.1) "RL line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, sc_load1.terminal) annotation (Line(
                points={{-40,30},{0,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,6.66134e-16},{-60,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLineMatrix_RLC.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a RLC line model to connect
a source to a load. The model is parameterized using the impedance matrix Z
and the admittance matrix B.
</p>
<p>
The example shows two configurations to test a zero and non-zero matrix <i>B</i>.
In the second case the impedance matrix <i>Z</i> has been set to zero.
Therefore, the line model does not have a load connected to it.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLineMatrix_RLC;

          model ACLineMatrix_RLC_N
            "Test model for a three-phase unbalanced RLC line with neutral cable specified by Z and B matrices"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance_N sc_load1(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Lines.TwoPortMatrixRLC_N Rline_1(
              Z11={10,10},
              Z12={0,0},
              Z13={0,0},
              Z22={10,10},
              Z23={0,0},
              Z33={10,10},
              V_nominal=100*sqrt(3),
              B12=0,
              B13=0,
              B23=0,
              B11=10,
              B22=10,
              B33=10,
              Z14={0,0},
              Z24={0,0},
              Z34={0,0},
              Z44={10,10},
              B14=0,
              B24=0,
              B34=0,
              B44=10) "RL line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Lines.TwoPortMatrixRLC_N Rline_2(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              V_nominal=100*sqrt(3),
              B12=0,
              B13=0,
              B23=0,
              Z11={0,0},
              Z22={0,0},
              Z33={0,0},
              B11=0.1,
              B22=0.1,
              B33=0.1,
              Z14={0,0},
              Z24={0,0},
              B14=0,
              B24=0,
              B34=0,
              B44=0.1,
              Z34={0,0},
              Z44={0,0}) "RL line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2.terminal_n) annotation (Line(
                points={{-80,0},{-60,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, sc_load1.terminal) annotation (Line(
                points={{-40,30},{0,30}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLineMatrix_RLC_N.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a RLC line model with neutral line to connect
a source to a load. The model is parameterized using the impedance matrix Z
and the admittance matrix B.
</p>
<p>
The example shows two configurations to test a zero and non-zero matrix <i>B</i>.
In the second case the impedance matrix <i>Z</i> has been set to zero.
Therefore, the line model does not have a load connected to it.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLineMatrix_RLC_N;

          model ACLineMatrix_RL_N
            "Test model for a three-phase unbalanced inductive-resistive line with neutral cable specified by a Z matrix"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance_N sc_load1(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Loads.Impedance_N sc_load2(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            Loads.Impedance_N sc_load3(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
            Lines.TwoPortMatrixRL_N Rline_1(
              Z11={10,10},
              Z12={0,0},
              Z13={0,0},
              Z22={10,10},
              Z23={0,0},
              Z33={10,10},
              V_nominal=100*sqrt(3),
              Z14={0,0},
              Z24={0,0},
              Z34={0,0},
              Z44={10,10}) "RL line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Lines.TwoPortMatrixRL_N Rline_2a(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=0.5*{10,10},
              Z22=0.5*{10,10},
              Z33=0.5*{10,10},
              V_nominal=100*sqrt(3),
              Z14={0,0},
              Z24={0,0},
              Z34={0,0},
              Z44=0.5*{10,10}) "RL line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Lines.TwoPortMatrixRL_N Rline_2b(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=0.5*{10,10},
              Z22=0.5*{10,10},
              Z33=0.5*{10,10},
              V_nominal=100*sqrt(3),
              Z14={0,0},
              Z24={0,0},
              Z34={0,0},
              Z44=0.5*{10,10}) "RL line that connects to load 2"
              annotation (Placement(transformation(extent={{-32,-10},{-12,10}})));
            Lines.TwoPortMatrixRL_N Rline_3a(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=2*{10,10},
              Z22=2*{10,10},
              Z33=2*{10,10},
              V_nominal=100*sqrt(3),
              Z14={0,0},
              Z24={0,0},
              Z34={0,0},
              Z44=2*{10,10}) "RL line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-40},{-40,-20}})));
            Lines.TwoPortMatrixRL_N Rline_3b(
              Z12={0,0},
              Z13={0,0},
              Z23={0,0},
              Z11=2*{10,10},
              Z22=2*{10,10},
              Z33=2*{10,10},
              V_nominal=100*sqrt(3),
              Z14={0,0},
              Z24={0,0},
              Z34={0,0},
              Z44=2*{10,10}) "RL line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
          equation
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-60,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-30},{-60,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-40},{0,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-30},{-20,-30},{-20,-40},{0,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, sc_load2.terminal) annotation (Line(
                points={{-12,0},{0,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, sc_load1.terminal) annotation (Line(
                points={{-40,30},{0,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,0},{-32,0}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLineMatrix_RL_N.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use an inductive resistive line model with neutral line to connect
a source to a load. The model is parameterized using the impedance matrix <i>Z</i>.
</p>
<p>
The model has three loads. The loads represent a short circuit <i>R=0</i>.
The current that flows through the load depends on the resistance of the line.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLineMatrix_RL_N;

          model ACLine_L "Test model for a three-phase unbalanced inductive line"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Inductance Lbase=10/2/Modelica.Constants.pi/60
              "Base value for the line inductances";
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance L1(R=0, L=Lbase) "Inductive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance L2(R=0, L=Lbase) "Inductive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance L3(R=0, L=Lbase) "Inductive load 3"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance sc_load(R=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Lines.TwoPortInductance Lline_sc(L=6*Lbase)
              "Inductive line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            Lines.TwoPortInductance Rline_1(L=3*Lbase)
              "Inductive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            Lines.TwoPortInductance Rline_2a(L=3*Lbase/2)
              "Inductive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Lines.TwoPortInductance Rline_2b(L=3*Lbase/2)
              "Inductive line that connects to load 2"
              annotation (Placement(transformation(extent={{-36,-30},{-16,-10}})));
            Lines.TwoPortInductance Rline_3a(L=6*Lbase)
              "Inductive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Lines.TwoPortInductance Rline_3b(L=6*Lbase)
              "Inductive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(E.terminal,Lline_sc. terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Lline_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p,L1. terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-36,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p,L2. terminal) annotation (Line(
                points={{-16,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p,L3. terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p,L3. terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_L.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a purely inductive line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the resistance of the line.
</p>
<p>
The remaining three loads <code>L1</code>, <code>L2</code>, and <code>L3</code>
are inductive loads. Each load is connected to the source with different configurations,
but the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_L;

          model ACLine_L_N
            "Test model for a three-phase unbalanced inductive line with neutral cable"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Inductance Lbase=10/2/Modelica.Constants.pi/60
              "Base value for the line inductances";
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance_N L1(R=0, L=Lbase) "Inductive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance_N L2(R=0, L=Lbase) "Inductive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance_N L3(R=0, L=Lbase) "Inductive load 3"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance_N sc_load(R=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Lines.TwoPortInductance_N Lline_sc(L=6*Lbase, Ln=Lbase)
              "Inductive line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            Lines.TwoPortInductance_N Rline_1(L=3*Lbase, Ln=0.5*Lbase)
              "Inductive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            Lines.TwoPortInductance_N Rline_2a(L=3*Lbase/2, Ln=0.5*Lbase/2)
              "Inductive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Lines.TwoPortInductance_N Rline_2b(L=3*Lbase/2, Ln=0.5*Lbase/2)
              "Inductive line that connects to load 2"
              annotation (Placement(transformation(extent={{-32,-30},{-12,-10}})));
            Lines.TwoPortInductance_N Rline_3a(L=6*Lbase, Ln=Lbase)
              "Inductive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Lines.TwoPortInductance_N Rline_3b(L=6*Lbase, Ln=Lbase)
              "Inductive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(E.terminal, Lline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, L3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, L3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, L2.terminal) annotation (Line(
                points={{-12,-20},{0,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-32,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, L1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Lline_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_L_N.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a purely inductive line model with neutral cable to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the resistance of the line.
</p>
<p>
The remaining three loads <code>L1</code>, <code>L2</code>, and <code>L3</code>
are inductive loads. Each load is connected to the source with different configurations,
but the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_L_N;

          model ACLine_N
            "Test model for a three-phase unbalanced commercial cable with neutral"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
            Loads.Impedance_N R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{22,20},{42,40}})));
            Loads.Impedance_N R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{22,-10},{42,10}})));
            Loads.Impedance_N R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{22,-50},{42,-30}})));
            Line_N line_1(
              l=1000,
              P_nominal=2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 1"
              annotation (Placement(transformation(extent={{-38,20},{-18,40}})));
            Line_N line_2a(
              l=500,
              P_nominal=2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 2"
              annotation (Placement(transformation(extent={{-44,-10},{-24,10}})));
            Line_N line_2b(
              l=500,
              P_nominal=2000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 2"
              annotation (Placement(transformation(extent={{-14,-10},{6,10}})));
            Line_N line_3a(
              l=2000,
              P_nominal=1000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 3"
              annotation (Placement(transformation(extent={{-38,-40},{-18,-20}})));
            Line_N line_3b(
              l=2000,
              P_nominal=1000,
              V_nominal=480,
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu35
                commercialCable) "Cable that connects to load 3"
              annotation (Placement(transformation(extent={{-38,-60},{-18,-40}})));
          equation
            connect(E.terminal, line_2a.terminal_n) annotation (Line(
                points={{-60,0},{-44,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, line_1.terminal_n) annotation (Line(
                points={{-60,0},{-50,0},{-50,30},{-38,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line_1.terminal_p, R1.terminal) annotation (Line(
                points={{-18,30},{22,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, line_3a.terminal_n) annotation (Line(
                points={{-60,0},{-50,0},{-50,-30},{-38,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, line_3b.terminal_n) annotation (Line(
                points={{-60,4.44089e-16},{-50,4.44089e-16},{-50,-50},{-38,-50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line_2a.terminal_p, line_2b.terminal_n) annotation (Line(
                points={{-24,0},{-14,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-18,-30},{2,-30},{2,-40},{22,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-18,-50},{2,-50},{2,-40},{22,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line_2b.terminal_p, R2.terminal) annotation (Line(
                points={{6,0},{22,0}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_N.mos"
                  "Simulate and plot"),
           Documentation(info="<html>
<p>
This example demonstrates how to use a cable line model with
neutral to connect a source to a load.
</p>
<p>
The model has three resistive loads <code>R1</code>, <code>R2</code>, and <code>R3</code>.
Each load is connected to the source with different configurations,
but the equivalent resistance between each load and the source is the same.
Since the equivalent resistances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_N;

          model ACLine_R "Test model for a three-phase unbalanced resistive line"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance sc_load(R=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Lines.TwoPortResistance Rline_sc(      useHeatPort=false, R=60)
              "Resistive line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            Lines.TwoPortResistance Rline_1(R=30)
              "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            Lines.TwoPortResistance Rline_2a(R=15)
              "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Lines.TwoPortResistance Rline_2b(R=15)
              "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-36,-30},{-16,-10}})));
            Lines.TwoPortResistance Rline_3a(R=60)
              "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Lines.TwoPortResistance Rline_3b(R=60)
              "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(E.terminal, Rline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-36,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-16,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_R.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a resistive line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the resistance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations,
but the equivalent resistance between each load and the source is the same.
Since the equivalent resistances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_R;

          model ACLine_RL
            "Test model for a three-phase unbalanced inductive-resistive line"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Resistance Rbase=3*10
              "Base value for the line resistance";
            parameter Modelica.Units.SI.Inductance Lbase=Rbase/2/Modelica.Constants.pi/60
              "Base value for the line inductance";
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance load_sc_1(R=0) "Short circuit 1"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Loads.Impedance load_sc_2(R=0) "Short circuit 2"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            Lines.TwoPortRL RL_2(
              R=Rbase,
              L=Lbase) "Resistive-Inductive line connected to short circuit 2"
              annotation (Placement(transformation(extent={{-48,-10},{-28,10}})));
            Lines.TwoPortResistance R_1(R=Rbase)
              "Resistance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Lines.TwoPortInductance L_1(L=Lbase)
              "Inductance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-30,20},{-10,40}})));
            Lines.TwoPortRL RL_3(
              R=Rbase,
              L=Lbase,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic)
              "Dynamic resistive-inductive line connected to short circuit 3"
              annotation (Placement(transformation(extent={{-48,-40},{-28,-20}})));
            Loads.Impedance load_sc_3(R=0) "Short circuit 3"
              annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          equation
            connect(E.terminal, R_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(R_1.terminal_p, L_1.terminal_n) annotation (Line(
                points={{-40,30},{-30,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(L_1.terminal_p, load_sc_1.terminal) annotation (Line(
                points={{-10,30},{0,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_2.terminal_n) annotation (Line(
                points={{-80,0},{-48,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RL_2.terminal_p, load_sc_2.terminal) annotation (Line(
                points={{-28,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RL_3.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-30},{-48,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RL_3.terminal_p, load_sc_3.terminal) annotation (Line(
                points={{-28,-30},{0,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (  experiment(StopTime=1.0,Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_RL.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
August 24, 2014, by Marco Bonvini:<br/>
Documentation and example revised.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a resistive-inductive line model to connect
a source to a load.
</p>
<p>
The model has three loads <code>load_sc_1</code>, <code>load_sc_2</code>,
and <code>load_sc_3</code> representing short circuits <i>R=0</i>.
The current that flows through the load depends on the impedance of the line.
</p>
<p>
Each load is connected to the source with different configurations,
but the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draw the same current.
</p>
<p>
<b>Note:</b>
The line model <code>RL_3</code> is the same as <code>RL_2</code> but it uses
dynamic phasors.
</p>
</html>"));
          end ACLine_RL;

          model ACLine_RLC "Test model for a three-phase unbalanced RLC line"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Resistance RBase=3*10
              "Base value for the line resistance";
            parameter Modelica.Units.SI.Inductance LBase=RBase/(2*Modelica.Constants.pi*
                60) "Base value for the line inductances";
            parameter Modelica.Units.SI.Capacitance CBase=3*0.1/(2*Modelica.Constants.pi*
                60) "Base value for the line inductances";
            Sources.FixedVoltage E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance sc_load1(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance sc_load2(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance sc_load3(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance sc_load(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Lines.TwoPortRLC RLCLine_sc(
              R=RBase,
              C=CBase,
              L=LBase,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic,
              V_nominal=480) "RLC line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            Lines.TwoPortRLC RLCLine_1(
              R=RBase,
              C=CBase,
              L=LBase,
              V_nominal=480) "RLC line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            Lines.TwoPortRLC RLCLine_2a(
              V_nominal=480,
              R=RBase/2,
              L=LBase/2,
              C=CBase/2) "RLC line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Lines.TwoPortRLC RLCLine_2b(
              V_nominal=480,
              R=RBase/2,
              L=LBase/2,
              C=CBase/2) "RLC line that connects to load 2"
              annotation (Placement(transformation(extent={{-30,-30},{-10,-10}})));
            Lines.TwoPortRLC RLCLine_3a(
              R=2*RBase,
              L=2*LBase,
              V_nominal=480,
              C=CBase/2) "RLC line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Lines.TwoPortRLC RLCLine_3b(
              R=2*RBase,
              L=2*LBase,
              V_nominal=480,
              C=CBase/2) "RLC line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(E.terminal, RLCLine_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RLCLine_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RLCLine_1.terminal_p, sc_load1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RLCLine_2a.terminal_p, RLCLine_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-30,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RLCLine_2b.terminal_p, sc_load2.terminal) annotation (Line(
                points={{-10,-20},{-4.44089e-16,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RLCLine_3a.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(RLCLine_3b.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (  experiment(StopTime=1.0,Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_RLC.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use an RLC line model to connect
a source to a load.
</p>
<p>
The model has four different loads. The loads <code>sc_load</code>,
<code>sc_load1</code>, <code>sc_load2</code>, <code>sc_load3</code> represent
short circuits <i>R=0</i>. The current that flows through the load depends
on the resistance, inductance and capacitance of the line.
</p>
<p>
The parameter <i>R</i>, <i>L</i> and <i>C</i> are such that at the nominal
frequency <i>f<sub>nom</sub> = 60 Hz</i> the respective resistance and
reactances are all equal to 10 &Omega;.
</p>
<p>
The lines used in this example have a T model (see
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC</a>).
The equivalent impedance of the line on each phase is equal to
</p>
<p align=\"center\" style=\"font-style:italic;\">
Z<sub>EQ</sub> = R/2 +jX<sub>L</sub>/2 + (R/2 +jX<sub>L</sub>/2)(-jX<sub>C</sub>)/
(R/2 +jX<sub>L</sub>/2 -jX<sub>C</sub>)
</p>
<p>
that in this case is equal to <i>Z<sub>EQ</sub> = 15 + j5 </i> &Omega;.
</p>
<p>
Given the equivalent impedance of each phase, and a voltage
with an RMS value of 100 V produces a current equal to
<i>I = 6 - j2 </i> A flowing through phase 1.
</p>
<h4>Notes</h4>
<p>
<b>(1) Note:</b>
The line model <code>RLCLine_sc</code> is the same as <code>RLCLine_1</code> but it uses
dynamic phasors.
</p>

<p>
<b>(2) Note:</b>
The line model <code>RLCLine_2a</code> has a current that is different
from the one passing in <code>RLCLine_1</code> because the series of two T
line models is different from the sum of the two separate line models.
</p>

<p>
<b>(3) Note:</b>
The line models <code>RLCLine_3a</code> and <code>RLCLine_3b</code> have currents that are
50% of the other lines because they are in parallel.
</p>
</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_RLC;

          model ACLine_RLC_N
            "Test model for a three-phase unbalanced RLC line with neutral cable"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Resistance RBase=3*10
              "Base value for the line resistance";
            parameter Modelica.Units.SI.Inductance LBase=RBase/(2*Modelica.Constants.pi*
                60) "Base value for the line inductances";
            parameter Modelica.Units.SI.Capacitance CBase=3*0.1/(2*Modelica.Constants.pi*
                60) "Base value for the line inductances";
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance_N sc_load1(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance_N sc_load2(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance_N sc_load3(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance_N sc_load(R=0, L=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Lines.TwoPortRLC_N RLCLine_sc(
              R=RBase,
              C=CBase,
              L=LBase,
              mode=ProsNet.Electrical.Types.Load.FixedZ_dynamic,
              V_nominal=480,
              Rn=RBase,
              Cn=CBase,
              Ln=LBase) "RLC line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            Lines.TwoPortRLC_N RLCLine_1(
              R=RBase,
              C=CBase,
              L=LBase,
              V_nominal=480,
              Rn=RBase,
              Cn=CBase,
              Ln=LBase) "RLC line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            Lines.TwoPortRLC_N RLCLine_2a(
              V_nominal=480,
              R=RBase/2,
              L=LBase/2,
              C=CBase/2,
              Rn=RBase/2,
              Cn=CBase/2,
              Ln=LBase/2) "RLC line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Lines.TwoPortRLC_N RLCLine_2b(
              V_nominal=480,
              R=RBase/2,
              L=LBase/2,
              C=CBase/2,
              Rn=RBase/2,
              Cn=CBase/2,
              Ln=LBase/2) "RLC line that connects to load 2"
              annotation (Placement(transformation(extent={{-30,-30},{-10,-10}})));
            Lines.TwoPortRLC_N RLCLine_3a(
              R=2*RBase,
              L=2*LBase,
              V_nominal=480,
              C=CBase/2,
              Rn=2*RBase,
              Cn=CBase/2,
              Ln=2*LBase) "RLC line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Lines.TwoPortRLC_N RLCLine_3b(
              R=2*RBase,
              L=2*LBase,
              V_nominal=480,
              C=CBase/2,
              Rn=2*RBase,
              Cn=CBase/2,
              Ln=2*LBase) "RLC line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(RLCLine_2a.terminal_p, RLCLine_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-30,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(RLCLine_2b.terminal_p, sc_load2.terminal) annotation (Line(
                points={{-10,-20},{0,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(RLCLine_3a.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(RLCLine_3b.terminal_p, sc_load3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(RLCLine_1.terminal_p, sc_load1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(RLCLine_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, RLCLine_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (  experiment(StopTime=1.0,Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_RLC_N.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use an RLC line model with neutral cable to connect
a source to a load.
</p>
<p>
The model has four different loads. The loads <code>sc_load</code>,
<code>sc_load1</code>, <code>sc_load2</code>, <code>sc_load3</code> represent
short circuits <i>R=0</i>. The current that flows through the load depends
on the resistance, inductance and capacitance of the line.
</p>
<p>
The parameter <i>R</i>, <i>L</i> and <i>C</i> are such that at the nominal
frequency <i>f<sub>nom</sub> = 60 Hz</i> the respective resistance and
reactances are all equal to 10 &Omega;.
</p>
<p>
The lines used in this example have a T model (see
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortRLC</a>).
The equivalent impedance of the line on each phase is equal to
</p>
<p align=\"center\" style=\"font-style:italic;\">
Z<sub>EQ</sub> = R/2 +jX<sub>L</sub>/2 + (R/2 +jX<sub>L</sub>/2)(-jX<sub>C</sub>)/
(R/2 +jX<sub>L</sub>/2 -jX<sub>C</sub>)
</p>
<p>
that in this case is equal to <i>Z<sub>EQ</sub> = 15 + j5 </i> &Omega;.
</p>
<p>
Given the equivalent impedance of each phase, and a voltage
with an RMS value of 100 V produces a current equal to
<i>I = 6 - j2 </i> A flowing through phase 1.
</p>
<h4>Notes</h4>
<p>
<b>(1) Note:</b>
The line model <code>RLCLine_sc</code> is the same as <code>RLCLine_1</code> but it uses
dynamic phasors.
</p>

<p>
<b>(2) Note:</b>
The line model <code>RLCLine_2a</code> has a current that is different
from the one passing in <code>RLCLine_1</code> because the series of two T
line models is different from the sum of the two separate line models.
</p>

<p>
<b>(3) Note:</b>
The line models <code>RLCLine_3a</code> and <code>RLCLine_3b</code> have currents that are
50% of the other lines because they are in parallel.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_RLC_N;

          model ACLine_RL_N
            "Test model for a three-phase unbalanced inductive-resistive line with neutral cable"
            extends Modelica.Icons.Example;
            parameter Modelica.Units.SI.Resistance Rbase=3*10
              "Base value for the line resistance";
            parameter Modelica.Units.SI.Inductance Lbase=Rbase/2/Modelica.Constants.pi/60
              "Base value for the line inductance";
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=100*sqrt(3)) "Voltage source"
              annotation (Placement(transformation(extent={{-96,-10},{-76,10}})));
            Loads.Impedance_N load_sc_1(R=0) "Short circuit 1"
              annotation (Placement(transformation(extent={{0,20},{20,40}})));
            Loads.Impedance_N load_sc_2(R=0) "Short circuit 2"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            Lines.TwoPortRL_N RL_2(
              R=Rbase,
              L=Lbase,
              Rn=0.5*Rbase,
              Ln=0.5*Lbase) "Resistive-Inductive line connected to short circuit 2"
              annotation (Placement(transformation(extent={{-48,-10},{-28,10}})));
            Lines.TwoPortResistance_N R_1(R=Rbase, Rn=0.5*Rbase)
              "Resistance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Lines.TwoPortInductance_N L_1(L=Lbase, Ln=0.5*Lbase)
              "Inductance line connected to short circuit 1"
              annotation (Placement(transformation(extent={{-30,20},{-10,40}})));
          equation
            connect(RL_2.terminal_p, load_sc_2.terminal) annotation (Line(
                points={{-28,0},{0,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(L_1.terminal_p, load_sc_1.terminal) annotation (Line(
                points={{-10,30},{0,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(L_1.terminal_n, R_1.terminal_p) annotation (Line(
                points={{-30,30},{-40,30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(R_1.terminal_n, E.terminal) annotation (Line(
                points={{-60,30},{-70,30},{-70,0},{-76,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, RL_2.terminal_n) annotation (Line(
                points={{-76,0},{-48,0}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (  experiment(StopTime=1.0,Tolerance=1e-06),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_RL_N.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
March 20, 2015, by Michael Wetter:<br/>
Removed dynamic load model as this caused divergence.
(Dassault SR00259003.)
</li>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added initial conditions for the dynamic load model.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a resistive-inductive line model with neutral cable to connect
a source to a load.
</p>
<p>
The model has two loads <code>load_sc_1</code> and <code>load_sc_2</code>
representing short circuits <i>R=0</i>.
The current that flows through the load depends on the impedance of the line.
</p>
<p>
Each load is connected to the source with different configurations,
but the equivalent impedance between each load and the source is the same.
Since the equivalent impedances are the same, each load draw the same current.
</p>
</html>"));
          end ACLine_RL_N;

          model ACLine_R_N
            "Test model for a three-phase unbalanced resistive line with neutral cable"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N E(
              definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-100,-10},{-80,10}})));
            Loads.Impedance_N R1(R=10) "Resistive load 1"
              annotation (Placement(transformation(extent={{0,0},{20,20}})));
            Loads.Impedance_N R2(R=10) "Resistive load 2"
              annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
            Loads.Impedance_N R3(R=10) "Resistive load 3"
              annotation (Placement(transformation(extent={{0,-70},{20,-50}})));
            Loads.Impedance_N sc_load(R=0) "Short circuit load"
              annotation (Placement(transformation(extent={{0,40},{20,60}})));
            Lines.TwoPortResistance_N Rline_sc(      useHeatPort=false, R=60,
              Rn=20) "Resistive line that connects to the short circuit"
              annotation (Placement(transformation(extent={{-60,60},{-40,40}})));
            Lines.TwoPortResistance_N Rline_1(R=30, Rn=10)
              "Resistive line that connects to load 1"
              annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
            Lines.TwoPortResistance_N Rline_2a(R=15, Rn=5)
              "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
            Lines.TwoPortResistance_N Rline_2b(R=15, Rn=5)
              "Resistive line that connects to load 2"
              annotation (Placement(transformation(extent={{-32,-30},{-12,-10}})));
            Lines.TwoPortResistance_N Rline_3a(R=60, Rn=20)
              "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Lines.TwoPortResistance_N Rline_3b(R=60, Rn=20)
              "Resistive line that connects to load 3"
              annotation (Placement(transformation(extent={{-60,-80},{-40,-60}})));
          equation
            connect(Rline_sc.terminal_p, sc_load.terminal) annotation (Line(
                points={{-40,50},{0,50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_1.terminal_p, R1.terminal) annotation (Line(
                points={{-40,10},{0,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_2b.terminal_p, R2.terminal) annotation (Line(
                points={{-12,-20},{0,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_2a.terminal_p, Rline_2b.terminal_n) annotation (Line(
                points={{-40,-20},{-32,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_3b.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-70},{-20,-70},{-20,-60},{0,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(Rline_3a.terminal_p, R3.terminal) annotation (Line(
                points={{-40,-50},{-20,-50},{-20,-60},{0,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_sc.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,50},{-60,50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_1.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,10},{-60,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_2a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-20},{-60,-20}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3a.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-50},{-60,-50}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(E.terminal, Rline_3b.terminal_n) annotation (Line(
                points={{-80,0},{-70,0},{-70,-70},{-60,-70}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACLine_R_N.mos"
                  "Simulate and plot"),
              Documentation(info="<html>
<p>
This example demonstrates how to use a resistive line model with neutral cable to connect
a source to a load.
</p>
<p>
The model has four different loads. The load <code>sc_load</code> represents
a short circuit <i>R=0</i>. The current that flows through the load depends
on the resistance of the line.
</p>
<p>
The remaining three loads <code>R1</code>, <code>R2</code>, and <code>R3</code>
are resistive loads. Each load is connected to the source with different configurations,
but the equivalent resistance between each load and the source is the same.
Since the equivalent resistances are the same, each load draws the same current.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end ACLine_R_N;

          model ACSimpleGrid
            "Test model for a network model for three-phase unbalanced systems without neutral cable"
            extends Modelica.Icons.Example;
            Network network(
              redeclare ProsNet.Electrical.Transmission.Grids.TestGrid2Nodes   grid,
              V_nominal=480)
              "Network model that represents the connection between the source and the load"
              annotation (Placement(transformation(extent={{20,-10},{0,10}})));
            Loads.Inductive load(
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              plugPhase3=false) "Load connected to the network"
              annotation (Placement(transformation(extent={{-34,10},{-54,30}})));
            Sources.FixedVoltage E(f=60, V=480,
              definiteReference=true) "Voltage source"           annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={-50,-20})));
            Modelica.Blocks.Sources.Ramp load_inputs(
              height=5000,
              offset=-2000,
              duration=0.5,
              startTime=0.25) "Input signal for the power consumption of the loads"
              annotation (Placement(transformation(extent={{-90,10},{-70,30}})));
          equation
            connect(E.terminal, network.terminal[1]) annotation (Line(
                points={{-40,-20},{-20,-20},{-20,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.terminal, network.terminal[2]) annotation (Line(
                points={{-34,20},{-20,20},{-20,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow1) annotation (Line(
                points={{-69,20},{-62,20},{-62,28},{-56,28}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow2) annotation (Line(
                points={{-69,20},{-56,20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
          __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACSimpleGrid.mos"
                  "Simulate and plot"),
          Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a network model to connect
a source to a load. In this simple case the network has two nodes
that are connected by a commercial cable without a neutral line.
</p>
<p>
At the beginning of the simulation, the load consumes power while at the
and it produces power. The voltage at the load at the beginning is lower
than the nominal RMS voltage (480 V), while at the end of the simulation it is higher.
The voltage drop and increase are due to the presence of the cable between
the source and the load.
</p>
<p>
The network uses cables of the type <code>LowVoltageCable.Cu35</code> with
a length of <i>200</i> m.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
</html>"));
          end ACSimpleGrid;

          model ACSimpleGrid_N
            "Test model for a network model for three-phase unbalanced systems with neutral cable"
            extends Modelica.Icons.Example;
            Network_N network(
              redeclare ProsNet.Electrical.Transmission.Grids.TestGrid2Nodes   grid,
              V_nominal=480)
              "Network model that represents the connection between the source and the load"
              annotation (Placement(transformation(extent={{20,-10},{0,10}})));
            Loads.Inductive_N load(
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              plugPhase3=false) "Load connected to the network"
              annotation (Placement(transformation(extent={{-34,10},{-54,30}})));
            Sources.FixedVoltage_N E(
              f=60,
              V=480,
              definiteReference=true) "Voltage source"
              annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=180,
                  origin={-50,-20})));
            Modelica.Blocks.Sources.Ramp load_inputs(
              height=5000,
              offset=-2000,
              duration=0.5,
              startTime=0.25) "Input signal for the power consumption of the loads"
              annotation (Placement(transformation(extent={{-90,10},{-70,30}})));
          equation
            connect(E.terminal, network.terminal[1]) annotation (Line(
                points={{-40,-20},{-20,-20},{-20,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load.terminal, network.terminal[2]) annotation (Line(
                points={{-34,20},{-20,20},{-20,0},{0,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow1) annotation (Line(
                points={{-69,20},{-62,20},{-62,28},{-56,28}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load_inputs.y, load.Pow2) annotation (Line(
                points={{-69,20},{-56,20}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
          __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Lines/Examples/ACSimpleGrid_N.mos"
                  "Simulate and plot"),
          Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example demonstrates how to use a network model to connect
a source to a load. In this simple case the network has two nodes
that are connected by a commercial cable with neutral line.
</p>
<p>
At the beginning of the simulation the load consumes power while at the
and it produces power. The voltage at the load at the beginning is lower
than the nominal RMS voltage (480 V) while at the end of the simulation it is higher.
The voltage drop and increase are due to the presence of the cable between
the source and the load.
</p>
<p>
The network uses cables of the type <code>LowVoltageCable.Cu35</code> with
a length of <i>200</i> m.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
</html>"));
          end ACSimpleGrid_N;
          annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Lines</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Icon(graphics={
            Ellipse(
              extent={{42,6},{18,-30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{30,6},{-52,6},{-62,6},{-70,-12},{-62,-30},{-50,-30},{30,-30}},
              color={0,0,0},
              smooth=Smooth.Bezier),
            Line(
              points={{-68,-12},{-86,-12}},
              color={0,0,0},
              smooth=Smooth.None),
            Line(
              points={{56,-12},{30,-12}},
              color={0,0,0},
              smooth=Smooth.None)}), Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Revised package: added examples, checked results and added unit tests.
</li>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",       info="<html>
<p>
This package contains models for transmission lines and electrical networks
of AC three-phase unbalanced systems.
</p>
</html>"));
      end Lines;

      package Loads "Package with load models for three-phase unbalanced AC systems"
        extends Modelica.Icons.VariantsPackage;

        model Capacitive
          "Model of a three-phase unbalanced capacitive load without neutral cable"
          extends BaseClasses.LoadCtrl(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load1(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load2(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load3(pf=pf,
                use_pf_in=use_pf_in));
          parameter Boolean use_pf_in = false
            "If true, the power factor is defined by an input"
            annotation(Dialog(group="Modeling assumption"));
          parameter Real pf(min=0, max=1) = 0.8 "Power factor"
          annotation(Dialog(group="Nominal conditions"));
          Modelica.Blocks.Interfaces.RealInput pf_in_1(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase1) "Power factor of load on phase 1" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120}),
                                  iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_2(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase2) "Power factor of load on phase 2" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={30,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_3(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase3) "Power factor of load on phase 3" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={80,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={60,-100})));
        equation
          connect(pf_in_1, load1.pf_in) annotation (Line(
              points={{-60,-120},{-60,56},{10,56}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_2, load2.pf_in) annotation (Line(
              points={{30,-120},{30,-14},{10,-14}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_3, load3.pf_in) annotation (Line(
              points={{80,-120},{80,-82},{10,-82}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
                Rectangle(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(points={{-42,-5.14335e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-2,0},
                  rotation=180),
                  Line(points={{-26,-3.18398e-15},{6.85214e-44,8.39117e-60}},
                                                 color={0,0,0},
                  origin={48,0},
                  rotation=180),
                  Line(points={{-10,-1.22461e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                  Line(points={{-2,-2.44921e-16},{16,1.95937e-15}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,1},
                  rotation=90),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{44,5.38825e-15}},
                                                 color={0,0,0},
                  origin={60,50},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,51},
                  rotation=90),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,-51},
                  rotation=90),
                Line(
                  points={{60,50},{76,0},{60,-52}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,-52},
                  rotation=180),
                Line(
                  points={{10,68},{10,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{16,68},{16,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{60,7.34764e-15}},
                                                 color={0,0,0},
                  origin={76,0},
                  rotation=180),
                Line(
                  points={{16,18},{16,-18}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{10,18},{10,-18}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{44,5.38825e-15}},
                                                 color={0,0,0},
                  origin={60,-52},
                  rotation=180),
                Line(
                  points={{16,-34},{16,-70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{10,-34},{10,-70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,-52},
                  rotation=180)}),    Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced capacitive load.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
The model computes the voltages, currents and powers on each phase.
</p>
<p>
For more information, see <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl</a> and
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Capacitive\">
Buildings.Electrical.AC.OnePhase.Loads.Capacitive</a>.
</p>
</html>"));
        end Capacitive;

        model Capacitive_N
          "Model of a three-phase unbalanced capacitive load with neutral cable"
          extends BaseClasses.LoadCtrl_N(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load1(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load2(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Capacitive load3(pf=pf,
                use_pf_in=use_pf_in));
          parameter Boolean use_pf_in = false
            "If true, the power factor is defined by an input"
            annotation(Dialog(group="Modeling assumption"));
          parameter Real pf(min=0, max=1) = 0.8 "Power factor"
          annotation(Dialog(group="Nominal conditions"));
          Modelica.Blocks.Interfaces.RealInput pf_in_1(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase1) "Power factor of load on phase 1" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120}),
                                  iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_2(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase2) "Power factor of load on phase 2" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={30,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_3(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase3) "Power factor of load on phase 3" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={80,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={60,-100})));
        equation
          connect(pf_in_1, load1.pf_in) annotation (Line(
              points={{-60,-120},{-60,56},{10,56}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_2, load2.pf_in) annotation (Line(
              points={{30,-120},{30,-14},{10,-14}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_3, load3.pf_in) annotation (Line(
              points={{80,-120},{80,-82},{10,-82}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          annotation (
          defaultComponentName="loa",
          Icon(graphics={
                Rectangle(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                  Line(points={{-42,-5.14335e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-2,0},
                  rotation=180),
                  Line(points={{-26,-3.18398e-15},{6.85214e-44,8.39117e-60}},
                                                 color={0,0,0},
                  origin={48,0},
                  rotation=180),
                  Line(points={{-10,-1.22461e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                  Line(points={{-2,-2.44921e-16},{16,1.95937e-15}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,1},
                  rotation=90),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{44,5.38825e-15}},
                                                 color={0,0,0},
                  origin={60,50},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,51},
                  rotation=90),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,-51},
                  rotation=90),
                Line(
                  points={{60,50},{76,0},{60,-52}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,-52},
                  rotation=180),
                Line(
                  points={{10,68},{10,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{16,68},{16,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{60,7.34764e-15}},
                                                 color={0,0,0},
                  origin={76,0},
                  rotation=180),
                Line(
                  points={{16,18},{16,-18}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{10,18},{10,-18}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{44,5.38825e-15}},
                                                 color={0,0,0},
                  origin={60,-52},
                  rotation=180),
                Line(
                  points={{16,-34},{16,-70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{10,-34},{10,-70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(
                  points={{0,0},{32,3.91873e-15}},
                  color={0,0,0},
                  origin={10,-52},
                  rotation=180)}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced capacitive load.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
The model computes the voltages, currents and powers on each phase.
</p>
<p>
This model has a connector with four cables and it represents the neutral cable.
The current in the neutral cable is computed as the algebraic sum of the currents
of the loads.
</p>
<p>
For more information, see <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N</a> and
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Capacitive\">
Buildings.Electrical.AC.OnePhase.Loads.Capacitive</a>.
</p>
</html>"));
        end Capacitive_N;

        model Impedance
          "Model of a three-phase unbalanced impedance without neutral cable"
          extends BaseClasses.Impedance(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Impedance load1,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Impedance load2,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Impedance load3);
        equation

          annotation (
          defaultComponentName="imp",
          Icon(graphics={      Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={7.10543e-15,7.10543e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{18,2.20429e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,-80},{120,-120}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{-66,50},{-26,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,49},
                  rotation=90),
                Line(
                  points={{34,50},{54,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{54,50},{70,0},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{34,0},{70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,1},
                  rotation=90),
                Line(
                  points={{-66,0},{-26,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,-50},{-26,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,-49},
                  rotation=90),
                Line(
                  points={{34,-50},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None)}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced impedance without neutral cable.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.Impedance\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.Impedance</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Impedance\">
Buildings.Electrical.AC.OnePhase.Loads.Impedance</a>.
The model computes the voltages, currents and powers on each phase.
</p>
</html>"));
        end Impedance;

        model Impedance_N
          "Model of a three-phase unbalanced impedance with neutral cable"
          extends BaseClasses.Impedance_N(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Impedance load1,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Impedance load2,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Impedance load3);
        equation

          annotation (
          defaultComponentName="imp",
          Icon(graphics={      Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={7.10543e-15,7.10543e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{18,2.20429e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,-80},{120,-120}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{-66,50},{-26,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,49},
                  rotation=90),
                Line(
                  points={{34,50},{54,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{54,50},{70,0},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{34,0},{70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,1},
                  rotation=90),
                Line(
                  points={{-66,0},{-26,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,-50},{-26,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,-49},
                  rotation=90),
                Line(
                  points={{34,-50},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None)}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced impedance with neutral cable.
The current in the neutral cable is computed as the algebraic sum of the currents
of the loads.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.Impedance_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.Impedance_N</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Impedance\">
Buildings.Electrical.AC.OnePhase.Loads.Impedance</a>.
The model computes the voltages, currents and powers on each phase.
</p>
</html>"));
        end Impedance_N;

        model Inductive
          "Model of a three-phase unbalanced inductive load without neutral cable"
          extends BaseClasses.LoadCtrl(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Inductive load1(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Inductive load2(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Inductive load3(pf=pf,
                use_pf_in=use_pf_in));
          parameter Boolean use_pf_in = false
            "If true, the power factor is defined by an input"
            annotation(Dialog(group="Modeling assumption"));
          parameter Real pf(min=0, max=1) = 0.8 "Power factor"
          annotation(Dialog(group="Nominal conditions"));
          Modelica.Blocks.Interfaces.RealInput pf_in_1(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase1) "Power factor of load on phase 1" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120}),
                                  iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_2(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase2) "Power factor of load on phase 2" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={50,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_3(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase3) "Power factor of load on phase 3" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={20,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={62,-100})));

        equation
          connect(pf_in_1, load1.pf_in) annotation (Line(
              points={{-60,-120},{-60,56},{10,56}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_2, load2.pf_in) annotation (Line(
              points={{50,-120},{50,-14},{10,-14}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_3, load3.pf_in) annotation (Line(
              points={{20,-120},{20,-82},{10,-82}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}),
                           graphics={
                Rectangle(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                           Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                Rectangle(
                  extent={{0,0},{60,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={70,0},
                  rotation=180),
                  Line(points={{-10,-1.22461e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Ellipse(extent={{-10,-10},{10,10}},
                  rotation=360),
                Ellipse(extent={{30,-10},{50,10}}),
                Ellipse(extent={{10,-10},{30,10}}),
                Rectangle(
                  extent={{-10,0},{50,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{26,3.18398e-15}},
                                                 color={0,0,0},
                  origin={76,0},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,1},
                  rotation=90),
                  Line(points={{-2,-2.44921e-16},{18,2.20429e-15}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={0,50},
                  rotation=360),
                Ellipse(extent={{30,40},{50,60}}),
                Ellipse(extent={{10,40},{30,60}}),
                Rectangle(
                  extent={{-10,50},{50,38}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={60,50},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,51},
                  rotation=90),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={0,-52},
                  rotation=360),
                Ellipse(extent={{30,-62},{50,-42}}),
                Ellipse(extent={{10,-62},{30,-42}}),
                Rectangle(
                  extent={{-10,-52},{50,-64}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,-52},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={60,-52},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,-51},
                  rotation=90),
                Line(
                  points={{60,50},{76,0},{60,-52}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,-52},
                  rotation=180)}),    Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced inductive load.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
The model computes the voltages, currents and powers on each phase.
</p>
<p>
For more information, see <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl</a> and
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Inductive\">
Buildings.Electrical.AC.OnePhase.Loads.Inductive</a>.
</p>
</html>"));
        end Inductive;

        model Inductive_N
          "Model of a three-phase unbalanced inductive load with neutral cable"
          extends BaseClasses.LoadCtrl_N(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Inductive load1(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Inductive load2(pf=pf,
                use_pf_in=use_pf_in),
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Inductive load3(pf=pf,
                use_pf_in=use_pf_in));
          parameter Boolean use_pf_in = false
            "If true, the power factor is defined by an input"
            annotation(Dialog(group="Modeling assumption"));
          parameter Real pf(min=0, max=1) = 0.8 "Power factor"  annotation(Dialog(group="Nominal conditions"));
          Modelica.Blocks.Interfaces.RealInput pf_in_1(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase1) "Power factor of load on phase 1" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={80,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_2(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase2) "Power factor of load on phase 2" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={40,-120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={0,-100})));
          Modelica.Blocks.Interfaces.RealInput pf_in_3(
            min=0,
            max=1,
            unit="1") if (use_pf_in and plugPhase3) "Power factor of load on phase 3" annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-120}),
                                  iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={62,-100})));
        equation
          connect(pf_in_1, load1.pf_in) annotation (Line(
              points={{80,-120},{80,56},{10,56}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_2, load2.pf_in) annotation (Line(
              points={{40,-120},{40,-14},{10,-14}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          connect(pf_in_3, load3.pf_in) annotation (Line(
              points={{-60,-120},{-60,-82},{10,-82}},
              color={0,0,127},
              smooth=Smooth.None,
              pattern=LinePattern.Dash));
          annotation (
          defaultComponentName="loa",
          Icon(graphics={
                Rectangle(
                  extent={{-80,80},{80,-80}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                                           Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                Rectangle(
                  extent={{0,0},{60,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={70,0},
                  rotation=180),
                  Line(points={{-10,-1.22461e-15},{10,0}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Ellipse(extent={{-10,-10},{10,10}},
                  rotation=360),
                Ellipse(extent={{30,-10},{50,10}}),
                Ellipse(extent={{10,-10},{30,10}}),
                Rectangle(
                  extent={{-10,0},{50,-12}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{26,3.18398e-15}},
                                                 color={0,0,0},
                  origin={76,0},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,1},
                  rotation=90),
                  Line(points={{-2,-2.44921e-16},{18,2.20429e-15}},
                                                 color={0,0,0},
                  origin={-82,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={0,50},
                  rotation=360),
                Ellipse(extent={{30,40},{50,60}}),
                Ellipse(extent={{10,40},{30,60}}),
                Rectangle(
                  extent={{-10,50},{50,38}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={60,50},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,51},
                  rotation=90),
                Ellipse(extent={{-10,-10},{10,10}},
                  origin={0,-52},
                  rotation=360),
                Ellipse(extent={{30,-62},{50,-42}}),
                Ellipse(extent={{10,-62},{30,-42}}),
                Rectangle(
                  extent={{-10,-52},{50,-64}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                  Line(points={{0,0},{12,1.46953e-15}},
                                                 color={0,0,0},
                  origin={-10,-52},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={60,-52},
                  rotation=180),
                Rectangle(
                  extent={{-11,22},{11,-22}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={-44,-51},
                  rotation=90),
                Line(
                  points={{60,50},{76,0},{60,-52}},
                  color={0,0,0},
                  smooth=Smooth.None),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,50},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                                                 color={0,0,0},
                  origin={-66,-52},
                  rotation=180)}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced inductive load.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
The model computes the voltages, currents and powers on each phase.
</p>
<p>
This model has a connector with four cables and it represents the neutral cable.
The current in the neutral cable is computed as the algebraic sum of the currents
of the loads.
</p>
<p>
For more information, see <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N</a> and
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Inductive\">
Buildings.Electrical.AC.OnePhase.Loads.Inductive</a>.
</p>
</html>"));
        end Inductive_N;

        model Resistive
          "Model of a three-phase unbalanced resistive load without neutral cable"
          extends BaseClasses.LoadCtrl(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Resistive load1,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Resistive load2,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Resistive load3);
        equation

          annotation (
          defaultComponentName="loa",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={      Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={7.10543e-15,7.10543e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{18,2.20429e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-120,120},{120,80}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{-66,50},{-26,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,49},
                  rotation=90),
                Line(
                  points={{34,50},{54,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{54,50},{70,0},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{34,0},{70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,1},
                  rotation=90),
                Line(
                  points={{-66,0},{-26,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,-50},{-26,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,-49},
                  rotation=90),
                Line(
                  points={{34,-50},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None)}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced resistive load.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
The model computes the voltages, currents and powers on each phase.
</p>
<p>
For more information, see <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl</a> and
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Resistive\">
Buildings.Electrical.AC.OnePhase.Loads.Resistive</a>.
</p>
</html>"));
        end Resistive;

        model Resistive_N
          "Model of a three-phase unbalanced resistive load with neutral cable"
          extends BaseClasses.LoadCtrl_N(
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Resistive load1,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Resistive load2,
            redeclare ProsNet.Electrical.AC.OnePhase.Loads.Resistive load3);
        equation

          annotation (
          defaultComponentName="loa",
          Icon(graphics={      Rectangle(extent={{-100,100},{100,-100}},
                    lineColor={255,255,255}),
                  Rectangle(
                    extent={{-80,80},{80,-80}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                  origin={7.10543e-15,7.10543e-15},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{12,1.46953e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                  Line(points={{-6.85214e-44,-8.39117e-60},{18,2.20429e-15}},
                                               color={0,0,0},
                  origin={-80,0},
                  rotation=180),
                Text(
                  extent={{-114,116},{126,76}},
                  textColor={0,0,0},
                  textString="%name"),
                Line(
                  points={{-66,50},{-26,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,49},
                  rotation=90),
                Line(
                  points={{34,50},{54,50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{54,50},{70,0},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{34,0},{70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,1},
                  rotation=90),
                Line(
                  points={{-66,0},{-26,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-66,-50},{-26,-50}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-11,30},{11,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  origin={4,-49},
                  rotation=90),
                Line(
                  points={{34,-50},{54,-50}},
                  color={0,0,0},
                  smooth=Smooth.None)}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents a three-phase unbalanced resistive load.
The model extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N</a>
and uses the load model from the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads\">
Buildings.Electrical.AC.OnePhase.Loads</a>.
The model computes the voltages, currents and powers on each phase.
</p>
<p>
This model has a connector with four cables and it represents the neutral cable.
The current in the neutral cable is computed as the algebraic sum of the currents
of the loads.
</p>
<p>
For more information, see <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.LoadCtrl_N</a> and
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Resistive\">
Buildings.Electrical.AC.OnePhase.Loads.Resistive</a>.
</p>
</html>"));
        end Resistive_N;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model Impedances
            "This model tests three-phase unbalanced impedances with and without neutral cable"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N sou_N(definiteReference=true,
              f=60,
              V=480) "Voltage source with neutral cable"
              annotation (Placement(transformation(extent={{-94,-50},{-74,-30}})));
            Sensors.GeneralizedSensor_N sen_N "Power sensor with neutral cable"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            Impedance_N imp_N(
              plugPhase2=false,
              use_R_in=true,
              RMin=1,
              RMax=10,
              use_L_in=true,
              LMin=0.1,
              LMax=1) "Impedance with neutral cable"
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
            Sources.FixedVoltage sou(definiteReference=true,
              f=60,
              V=480) "Voltage source without neutral cable"
              annotation (Placement(transformation(extent={{-94,30},{-74,50}})));
            Sensors.GeneralizedSensor sen "Power sensor without neutral cable"
              annotation (Placement(transformation(extent={{-60,30},{-40,50}})));
            Impedance imp(
              plugPhase2=false,
              use_R_in=true,
              RMin=1,
              RMax=10,
              use_L_in=true,
              LMin=0.1,
              LMax=1) "Impedance without neutral cable"
              annotation (Placement(transformation(extent={{0,30},{20,50}})));
            Modelica.Blocks.Sources.Ramp var_RL(
              duration=0.5,
              startTime=0.25,
              height=1,
              offset=0) "Power signal for loads on phase 1"
              annotation (Placement(transformation(extent={{60,-10},{40,10}})));
          equation

            connect(sou.terminal, sen.terminal_n) annotation (Line(
                points={{-74,40},{-60,40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_p, imp.terminal) annotation (Line(
                points={{-40,40},{0,40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(var_RL.y, imp.y_R) annotation (Line(
                points={{39,0},{36,0},{36,70},{6,70},{6,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(var_RL.y, imp.y_L) annotation (Line(
                points={{39,6.66134e-16},{26,6.66134e-16},{26,62},{14,62},{14,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(var_RL.y, imp_N.y_R) annotation (Line(
                points={{39,0},{6,0},{6,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(var_RL.y, imp_N.y_L) annotation (Line(
                points={{39,0},{14,0},{14,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(sou_N.terminal, sen_N.terminal_n) annotation (Line(
                points={{-74,-40},{-60,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen_N.terminal_p, imp_N.terminal) annotation (Line(
                points={{-40,-40},{0,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),      graphics={Text(
                    extent={{-80,80},{0,74}},
                    textColor={0,0,0},
                    pattern=LinePattern.Dash,
                    textString="Without neutral"), Text(
                    extent={{-80,-10},{0,-16}},
                    textColor={0,0,0},
                    pattern=LinePattern.Dash,
                    textString="With neutral")}),        Documentation(info="<html>
<p>
This example model shows how to use three-phase unbalanced impedances with and without neutral cable.
</p>
<p>
This model contains two identical inductive impedances with and without neutral cable.
The impedances have inputs that allow to change the value of their resistances and inductances
externally. The values start to change from their minimum to their maximum values at time
<i>t = 0.25 s</i>.
</p>
<p>
The unbalanced impedance that has the neutral cable
<code>sen_N.I[4]</code> is able to measure the current in the neutral. that is
the current necessary to satisfy the Kirchoff Current Law (KCL)
such that the algebraic sum of the phase current in each impedance is equal to zero.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model from previus version and added documentation.
</li>
</ul>
</html>"),    experiment(Tolerance=1e-6, StopTime=1.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Loads/Examples/Impedances.mos"
                  "Simulate and plot"));
          end Impedances;

          model LoadCtrl
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N sou(f=60, V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
            Modelica.Blocks.Sources.Sine pow_1(
              f=0.1,
              amplitude=4500,
              offset=6000) "Power on phase 1"
              annotation (Placement(transformation(extent={{60,10},{40,30}})));
            Resistive_N load_ctrl(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              vThresh=0.05,
              tDelay=2,
              voltageCtrl=true,
              plugPhase2=false,
              plugPhase3=false,
              V_nominal=480) "Voltage controlled load"
                        annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
            Lines.Line_N line1(
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu10
                commercialCable,
              l=400,
              P_nominal=10000,
              V_nominal=480) "Transmission line to voltage controlled load"
              annotation (Placement(transformation(extent={{-46,-10},{-26,10}})));
            Resistive_N load(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              plugPhase2=false,
              plugPhase3=false,
              V_nominal=480) "Load"
              annotation (Placement(transformation(extent={{-8,-40},{12,-20}})));
            Lines.Line_N line(
              mode=ProsNet.Electrical.Types.CableMode.commercial,
              redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Cu10
                commercialCable,
              l=400,
              P_nominal=10000,
              V_nominal=480)
              annotation (Placement(transformation(extent={{-46,-40},{-26,-20}})));
          equation
            connect(pow_1.y, load_ctrl.Pow1) annotation (Line(
                points={{39,20},{30,20},{30,8},{14,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(pow_1.y, load.Pow1) annotation (Line(
                points={{39,20},{30,20},{30,-22},{14,-22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(sou.terminal, line1.terminal_n) annotation (Line(
                points={{-60,0},{-46,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sou.terminal, line.terminal_n) annotation (Line(
                points={{-60,0},{-54,0},{-54,-30},{-46,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line.terminal_p, load.terminal) annotation (Line(
                points={{-26,-30},{-8,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line1.terminal_p, load_ctrl.terminal) annotation (Line(
                points={{-26,0},{-8,0}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (    experiment(Tolerance=1e-6, StopTime=10.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Loads/Examples/LoadCtrl.mos"
                  "Simulate and plot"),
          Documentation(info="<html>
<p>
This example model shows how the voltage controller can act on a three-phase unbalanced load.
</p>
<p>
This model contains two loads: one with voltage control and one without.
The loads produce power only on the first phase that is connected through a transmission line to a voltage
source. When the power production increases, the losses on the line cause an increase of the voltage
at the load. The load with voltage controller detects when the overvoltage happens
and unplugs the load for 2 seconds. After 2 seconds the load is plugged again and if this causes an other
overvoltage it will be unplugged again.
</p>
<p>
The model contains both a controlled and a not controlled load so the user can
compare the difference in the voltages and powers when the load is unplugged.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2015, by Michael Wetter:<br/>
Removed assignment of <code>P_nominal</code> to avoid the warning
\"The following parameters with fixed = false also have a binding\"
in Dymola 2016.
</li>
<li>
March 10, 2015, by Marco Bonvini:<br/>
Revised documentation of the example.
</li>
</ul>
</html>"));
          end LoadCtrl;

          model Loads "This model tests the load models without neutral cable connection"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage sou(definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-94,-10},{-74,10}})));
            Modelica.Blocks.Sources.Sine ph_1(
              amplitude=2000,
              f=10,
              offset=-2500) "Power signal for loads on phase 1"
              annotation (Placement(transformation(extent={{80,30},{60,50}})));
            Modelica.Blocks.Sources.Constant ph_23(k=0)
              "Power signal for loads on phase 2 and 3"
              annotation (Placement(transformation(extent={{100,-10},{80,10}})));
            Resistive loaR(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              V_nominal=480) "Resistive load"
              annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
            Inductive loaRL(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              V_nominal=480) "Inductive load"
              annotation (Placement(transformation(extent={{-8,-40},{12,-20}})));
            Capacitive loaRC(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              V_nominal=480) "Capacitive load"
              annotation (Placement(transformation(extent={{-8,-80},{12,-60}})));
            Sensors.GeneralizedSensor sen "Power sensor"
              annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
            Sensors.GeneralizedSensor senSingleConn "Power sensor"
              annotation (Placement(transformation(extent={{-60,50},{-40,70}})));
            Capacitive loaRC1(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              plugPhase2=false,
              plugPhase3=false,
              V_nominal=480) "Capacitive load"
              annotation (Placement(transformation(extent={{10,30},{30,50}})));
            Inductive loaRL1(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              plugPhase2=false,
              plugPhase3=false,
              V_nominal=480) "Inductive load"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            Resistive loaR1(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              plugPhase2=false,
              plugPhase3=false,
              V_nominal=480) "Resistive load"
              annotation (Placement(transformation(extent={{-30,70},{-10,90}})));
          equation
            connect(ph_1.y, loaR.Pow1) annotation (Line(
                points={{59,40},{54,40},{54,8},{14,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaR.Pow3) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-8},{14,-8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaR.Pow2) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,6.66134e-16},{14,6.66134e-16}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_1.y, loaRL.Pow1) annotation (Line(
                points={{59,40},{54,40},{54,-22},{14,-22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_1.y, loaRC.Pow1) annotation (Line(
                points={{59,40},{54,40},{54,-62},{14,-62}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRL.Pow2) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-30},{14,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRL.Pow3) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-38},{14,-38}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRC.Pow2) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-70},{14,-70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRC.Pow3) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-78},{14,-78}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(sou.terminal, sen.terminal_n) annotation (Line(
                points={{-74,5.55112e-16},{-66,5.55112e-16},{-66,4.44089e-16},{-64,4.44089e-16}},
                color={0,120,120},
                smooth=Smooth.None));

            connect(sen.terminal_p, loaR.terminal) annotation (Line(
                points={{-44,0},{-8,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_p, loaRL.terminal) annotation (Line(
                points={{-44,0},{-26,0},{-26,-30},{-8,-30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_p, loaRC.terminal) annotation (Line(
                points={{-44,0},{-26,0},{-26,-70},{-8,-70}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(senSingleConn.terminal_p, loaR1.terminal) annotation (Line(
                points={{-40,60},{-36,60},{-36,80},{-30,80}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(senSingleConn.terminal_p, loaRL1.terminal) annotation (Line(
                points={{-40,60},{-10,60}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(senSingleConn.terminal_p, loaRC1.terminal) annotation (Line(
                points={{-40,60},{-16,60},{-16,40},{10,40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ph_1.y, loaRC1.Pow1) annotation (Line(
                points={{59,40},{46,40},{46,48},{32,48}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_1.y, loaRL1.Pow1) annotation (Line(
                points={{59,40},{46,40},{46,68},{12,68}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_1.y, loaR1.Pow1) annotation (Line(
                points={{59,40},{46,40},{46,88},{-8,88}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(sou.terminal, senSingleConn.terminal_n) annotation (Line(
                points={{-74,0},{-68,0},{-68,60},{-60,60}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation ( Documentation(info="<html>
<p>
This example model shows how three-phase unbalanced loads can be used.
</p>
<p>
This model contains two set of loads (one for each type: resistive, inductive and capacitive)
that consume power just on the first phase. The example shows how it's possible to model
this situation in two different ways. It's possible to not connect the loads on the phases
setting the parameters <code>plugLoad*=false</code>.
The alternative is to impose the load on a specific phase equal to zero.
</p>
<p>
The power measured by the sensors on each phase show that the results are equal.
</p>
<h4>Note:</h4>
<p>
Whenever possible it is preferred to disable the load on a specific phase using the parameter <code>plugLoad*</code>
because the equations relative to the load are conditionally removed, reducing the size
of the system of equations.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2015, by Michael Wetter:<br/>
Removed assignment of <code>P_nominal</code> to avoid the warning
\"The following parameters with fixed = false also have a binding\"
in Dymola 2016.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model from previus version and added documentation.
</li>
</ul>
</html>"),    experiment(Tolerance=1e-6, StopTime=1.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Loads/Examples/Loads.mos"
                  "Simulate and plot"));
          end Loads;

          model Loads_N
            "This model tests unbalanced load models with neutral cable connection"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage_N
                                 sou(definiteReference=true,
              f=60,
              V=480) "Voltage source"
              annotation (Placement(transformation(extent={{-94,-10},{-74,10}})));
            Modelica.Blocks.Sources.Ramp ph_1(
              offset=-1000,
              duration=0.5,
              startTime=0.25,
              height=-500) "Power signal for loads on phase 1"
                         annotation (Placement(transformation(extent={{80,30},{60,50}})));
            Modelica.Blocks.Sources.Constant ph_23(k=-1000)
              "Power signal for loads on phase 2 and 3"
              annotation (Placement(transformation(extent={{100,-10},{80,10}})));
            Resistive_N loaR_N(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              V_nominal=480) "Resistive load with neutral cable"
              annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
            Inductive_N loaRL_N(mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
                pf=0.9,
              V_nominal=480) "Inductive load with neutral cable"
              annotation (Placement(transformation(extent={{-8,-40},{12,-20}})));
            Capacitive_N loaRC_N(
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
              pf=0.7,
              V_nominal=480) "Capacitive load with neutral cable"
              annotation (Placement(transformation(extent={{-8,-80},{12,-60}})));
            Sensors.GeneralizedSensor_N
                                      sen "Power sensor with neutral cable"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          equation
            connect(ph_1.y, loaR_N.Pow1) annotation (Line(
                points={{59,40},{54,40},{54,8},{14,8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaR_N.Pow3) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-8},{14,-8}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaR_N.Pow2) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,6.66134e-16},{14,6.66134e-16}},
                color={0,0,127},
                smooth=Smooth.None));

            connect(ph_1.y, loaRL_N.Pow1) annotation (Line(
                points={{59,40},{54,40},{54,-22},{14,-22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_1.y, loaRC_N.Pow1) annotation (Line(
                points={{59,40},{54,40},{54,-62},{14,-62}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRL_N.Pow2) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-30},{14,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRL_N.Pow3) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-38},{14,-38}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRC_N.Pow2) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-70},{14,-70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ph_23.y, loaRC_N.Pow3) annotation (Line(
                points={{79,4.44089e-16},{68,4.44089e-16},{68,-78},{14,-78}},
                color={0,0,127},
                smooth=Smooth.None));

            connect(sou.terminal, sen.terminal_n) annotation (Line(
                points={{-74,0},{-60,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen.terminal_p, loaR_N.terminal) annotation (Line(
                points={{-40,0},{-8,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen.terminal_p, loaRL_N.terminal) annotation (Line(
                points={{-40,0},{-26,0},{-26,-30},{-8,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen.terminal_p, loaRC_N.terminal) annotation (Line(
                points={{-40,0},{-26,0},{-26,-70},{-8,-70}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation ( Documentation(info="<html>
<p>
This example model shows how three-phase unbalanced loads with the neutral cable can be used.
</p>
<p>
This model contains three different loads of different type. They start in a balanced configuration
and at time <i>t = 0.25 s</i> the loads on the first phase start to increase their power consumption.
</p>
<p>
When the loads start to be unbalanced the sensors starts to measure a current in the neutral cable
<code>sen.I[4]</code>. This is the current necessary to satisfy the Kirchoff Current Law (KCL)
such that the algebraic sum of the phase current in each load is equal to zero.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Loads/Examples/unbalancedLoads.png\"/>
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2015, by Michael Wetter:<br/>
Removed assignment of <code>P_nominal</code> to avoid the warning
\"The following parameters with fixed = false also have a binding\"
in Dymola 2016.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model from previus version and added documentation.
</li>
</ul>
</html>"),    experiment(Tolerance=1e-6, StopTime=1.0),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Loads/Examples/Loads_N.mos"
                  "Simulate and plot"));
          end Loads_N;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Examples;

        package BaseClasses "Package with base class models"
        extends Modelica.Icons.BasesPackage;

          partial model BaseImpedance
            "Partial model of a three-phase unbalanced impedance"
            extends ProsNet.Electrical.Interfaces.PartialPluggableUnbalanced;
            replaceable ProsNet.Electrical.AC.OnePhase.Loads.Impedance load1(
              inductive=inductive,
              R=R,
              L=L,
              C=C,
              use_R_in=use_R_in,
              RMin=RMin,
              RMax=RMax,
              use_C_in=use_C_in,
              CMin=CMin,
              CMax=CMax,
              use_L_in=use_L_in,
              LMin=LMin,
              LMax=LMax) if plugPhase1 "Load 1"
              annotation (Placement(transformation(extent={{-10,30},{10,50}})));
            replaceable ProsNet.Electrical.AC.OnePhase.Loads.Impedance load2(
              inductive=inductive,
              R=R,
              L=L,
              C=C,
              use_R_in=use_R_in,
              RMin=RMin,
              RMax=RMax,
              use_C_in=use_C_in,
              CMin=CMin,
              CMax=CMax,
              use_L_in=use_L_in,
              LMin=LMin,
              LMax=LMax) if plugPhase2 "Load 2" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));
            replaceable ProsNet.Electrical.AC.OnePhase.Loads.Impedance load3(
              inductive=inductive,
              R=R,
              L=L,
              C=C,
              use_R_in=use_R_in,
              RMin=RMin,
              RMax=RMax,
              use_C_in=use_C_in,
              CMin=CMin,
              CMax=CMax,
              use_L_in=use_L_in,
              LMin=LMin,
              LMax=LMax) if plugPhase3 "Load 3" annotation (Placement(
                  transformation(extent={{-10,-50},{10,-30}})));
            parameter ProsNet.Electrical.Types.LoadConnection loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg
              "Type of load connection (Yg or D)";
            parameter Boolean inductive=true
              "If =true the load is inductive, otherwise it is capacitive"
              annotation (Evaluate=true, choices(
                choice=true "Inductive",
                choice=false "Capacitive",
                __Dymola_radioButtons=true));
            parameter Modelica.Units.SI.Resistance R(
              start=1,
              min=0) = 1 "Resistance" annotation (Dialog(enable=not use_R_in));
            parameter Modelica.Units.SI.Inductance L(
              start=0,
              min=0) = 0 "Inductance"
              annotation (Dialog(enable=inductive and (not use_L_in)));
            parameter Modelica.Units.SI.Capacitance C(
              start=0,
              min=0) = 0 "Capacitance"
              annotation (Dialog(enable=(not inductive) and (not use_C_in)));
            parameter Boolean use_R_in = false "if true, R is specified by an input"
               annotation(Evaluate=true, Dialog(tab = "Variable load", group="Resistance"));
            parameter Modelica.Units.SI.Resistance RMin(
              start=R,
              min=Modelica.Constants.eps) = 1e-4 "Minimum value of the resistance"
              annotation (Evaluate=true, Dialog(
                enable=use_R_in,
                tab="Variable load",
                group="Resistance"));
            parameter Modelica.Units.SI.Resistance RMax(
              start=R,
              min=Modelica.Constants.eps) = 1e2 "Maximum value of the resistance"
              annotation (Evaluate=true, Dialog(
                enable=use_R_in,
                tab="Variable load",
                group="Resistance"));
            parameter Boolean use_C_in = false "if true, C is specified by an input"
              annotation(Evaluate=true, Dialog(tab = "Variable load", group="Capacitance"));
            parameter Modelica.Units.SI.Capacitance CMin(
              start=C,
              min=Modelica.Constants.eps) = 1e-4 "Minimum value of the capacitance"
              annotation (Evaluate=true, Dialog(
                enable=use_C_in,
                tab="Variable load",
                group="Capacitance"));
            parameter Modelica.Units.SI.Capacitance CMax(
              start=C,
              min=Modelica.Constants.eps) = 1e2 "Maximum value of the capacitance"
              annotation (Evaluate=true, Dialog(
                enable=use_C_in,
                tab="Variable load",
                group="Capacitance"));
            parameter Boolean use_L_in = false "if true, L is specified by an input"
               annotation(Evaluate=true, Dialog(tab = "Variable load", group="Inductance"));
            parameter Modelica.Units.SI.Inductance LMin(
              start=L,
              min=Modelica.Constants.eps) = 1e-4 "Minimum value of the inductance"
              annotation (Evaluate=true, Dialog(
                enable=use_L_in,
                tab="Variable load",
                group="Inductance"));
            parameter Modelica.Units.SI.Inductance LMax(
              start=L,
              min=Modelica.Constants.eps) = 1e2 "Maximum value of the inductance"
              annotation (Evaluate=true, Dialog(
                enable=use_L_in,
                tab="Variable load",
                group="Inductance"));
            Modelica.Blocks.Interfaces.RealInput y_R(min=0, max=1) if use_R_in
              "Input that sepecifies variable R"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={-40,100})));
            Modelica.Blocks.Interfaces.RealInput y_C(min=0, max=1) if use_C_in
              "Input that sepecifies variable C"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={0,100})));
            Modelica.Blocks.Interfaces.RealInput y_L(min=0, max=1) if use_L_in
              "Input that sepecifies variable L"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={40,100})));

            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta wyeToDelta if (
              loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_delta)
              "Wye to delta load connection"
              annotation (Placement(transformation(extent={{-64,0},{-44,20}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToWyeGround
              wyeToWyeGround if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg)
              "Wye to grounded wye connection" annotation (Placement(
                  transformation(extent={{-64,-20},{-44,0}})));
          protected
            Interfaces.Adapter3to3 adaDel if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_delta)
              "Adapter"
              annotation (Placement(transformation(extent={{-40,-50},{-60,-30}})));
            Interfaces.Adapter3to3 adaWye if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg)
              "Adapter"
              annotation (Placement(transformation(extent={{-40,-80},{-60,-60}})));
          equation

            // Conditional connections to load 1
            if plugPhase1 then
              if use_R_in then
                connect(y_R, load1.y_R) annotation (Line(
                points={{-40,100},{-40,60},{-4,60},{-4,50}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if use_C_in then
                connect(y_C, load1.y_C) annotation (Line(
                points={{8.88178e-16,100},{8.88178e-16,75},{0,75},{0,50}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if use_L_in then
                connect(y_L, load1.y_L) annotation (Line(
                points={{40,100},{40,60},{4,60},{4,50}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
            end if;
            // Conditional connections to load 2
            if plugPhase2 then
              if use_R_in then
                connect(y_R, load2.y_R) annotation (Line(
                points={{-40,100},{-40,20},{-4,20},{-4,10}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if use_L_in then
                connect(y_L, load2.y_L) annotation (Line(
                points={{40,100},{40,10},{4,10}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if use_C_in then
                connect(y_C, load2.y_C) annotation (Line(
                  points={{0,100},{0,70},{-20,70},{-20,24},{0,24},{0,10}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;
            end if;

            // Conditional connections to load 3
            if plugPhase3 then
              if use_R_in then
                connect(y_R, load3.y_R) annotation (Line(
                points={{-40,100},{-40,-20},{-4,-20},{-4,-30}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if use_C_in then
                connect(y_C, load3.y_C) annotation (Line(
                  points={{0,100},{0,70},{-20,70},{-20,-16},{0,-16},{0,-30}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;
              if use_L_in then
                connect(y_L, load3.y_L) annotation (Line(
                  points={{40,100},{40,-20},{4,-20},{4,-30}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;
            end if;

            // Connection of the single loads to the 3phases connector
            if plugPhase1 then
              connect(load1.terminal, adaDel.terminals[1]) annotation (Line(points={{-10,40},
                      {-26,40},{-26,-40.5333},{-40,-40.5333}},
                                                             color={0,120,120}));
              connect(load1.terminal, adaWye.terminals[1]) annotation (Line(points={{-10,40},
                      {-26,40},{-26,-70.5333},{-40,-70.5333}},
                                                             color={0,120,120}));
            end if;

            if plugPhase2 then
              connect(load2.terminal, adaDel.terminals[2]) annotation (Line(points={{-10,0},
                      {-22,0},{-22,-40},{-40,-40}}, color={0,120,120}));
              connect(load2.terminal, adaWye.terminals[2]) annotation (Line(points={{-10,0},
                      {-22,0},{-22,-70},{-40,-70}}, color={0,120,120}));
            end if;
            if plugPhase3 then
              connect(load3.terminal, adaDel.terminals[3]) annotation (Line(points={{-10,-40},
                      {-20,-40},{-20,-40},{-30,-40},{-30,-39.4667},{-40,-39.4667}},
                                                                        color={0,120,120}));
              connect(load3.terminal, adaWye.terminals[3]) annotation (Line(points={{-10,-40},
                      {-20,-40},{-20,-69.4667},{-40,-69.4667}},
                                                              color={0,120,120}));
            end if;

            connect(adaDel.terminal, wyeToDelta.delta) annotation (Line(points={{-60,-40},
                    {-64,-40},{-64,-20},{-28,-20},{-28,10},{-44,10}}, color={0,120,120}));
            connect(adaWye.terminal, wyeToWyeGround.wyeg) annotation (Line(points={{-60,-70},
                    {-66,-70},{-66,-18},{-30,-18},{-30,-10},{-44,-10}}, color={0,120,120}));

            annotation (    Documentation(info="<html>
<p>
This model represents a partial interface for a three-phase AC
unbalanced impedance.
</p>
<p>
The model can be configured in order to represent different type of
impedances as well as configurations.
</p>
<p>
The loads can be connected either in wye (Y) or delta (D) configuration.
The parameter <code>loadConn</code> can be used for such a purpose.
</p>
<p>
The model has three impedances that can be either connected in Y or
D configuration. The parameter <code>loadConn</code> can be used for
such a purpose. The Boolean parameter <code>inductive</code> can be selected
to specify the type of impedance.
</p>
<p>
The impedances on each phase can be removed using the boolean flags
<code>plugPhase1</code>, <code>plugPhase2</code>, and <code>plugPhase3</code>.
These parameters can be used to generate unbalanced loads.
</p>
<p>
The values of the impedances are computed starting from the parameters <code>R</code>,
<code>L</code>, and <code>C</code>. Depending on the values of the boolean flag
<code>inductive</code> some of these parameters may be disabled. There are additional
flags <code>use_R_in</code>, <code>use_L_in</code>, and <code>use_C_in</code> that can
be used to specify time varying impedances.
</p>
</html>",           revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapters for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model from previus version.
</li>
</ul>
</html>"));
          end BaseImpedance;

          partial model BaseLoadCtrl
            "Partial model of a three-phase unbalanced load with voltage controllers"
            extends ProsNet.Electrical.Interfaces.PartialPluggableUnbalanced;
            parameter ProsNet.Electrical.Types.LoadConnection loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg
              "Type of load connection (Yg or D)";
            parameter Boolean linearized = false
              "If =true introduce a linearization in the load" annotation(Dialog(group="Modeling assumption"));
            parameter ProsNet.Electrical.Types.Load mode(
              min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
              max=ProsNet.Electrical.Types.Load.VariableZ_y_input)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
              "Parameters that specifies the mode of the load (e.g., steady state,
    dynamic, prescribed power consumption, etc.)"
              annotation (Dialog(group="Modeling assumption"));

            parameter Modelica.Units.SI.Power P_nominal=0
              "Nominal power (negative if consumed, positive if generated)" annotation (
                Dialog(group="Nominal conditions", enable=mode <> ProsNet.Electrical.Types.Load.VariableZ_P_input));

            parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
              "Nominal voltage (V_nominal >= 0)"
              annotation (Dialog(group="Nominal conditions"));
            parameter Boolean voltageCtrl = false "This flag enables the voltage control"
                                                      annotation(Evaluate=true, Dialog(group="Voltage CTRL"));
            parameter Real vThresh(min=0.0, max=1.0) = 0.1
              "Threshold that activates voltage ctrl (ratio of nominal voltage)" annotation(Dialog(group="Voltage CTRL",
                  enable = voltageCtrl));
            parameter Modelica.Units.SI.Time tDelay=300
              "Time to wait before plugging the load again after disconnection"
              annotation (Dialog(group="Voltage CTRL", enable=voltageCtrl));
            parameter Types.InitMode initMode=ProsNet.Electrical.Types.InitMode.zero_current
              "Initialization mode for homotopy operator"
              annotation (Dialog(tab="Initialization"));
            replaceable ProsNet.Electrical.Interfaces.Load load1(
              redeclare package PhaseSystem =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n
                terminal,
              final linearized=linearized,
              final mode=mode,
              final P_nominal=P_nominal,
              final V_nominal=V_nominal/sqrt(3),
              final initMode=initMode) if plugPhase1 "Load 1"
              annotation (Placement(transformation(extent={{-10,40},{10,60}})));
            replaceable ProsNet.Electrical.Interfaces.Load load2(
              redeclare package PhaseSystem =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n
                terminal,
              final linearized=linearized,
              final mode=mode,
              final P_nominal=P_nominal,
              final V_nominal=V_nominal/sqrt(3),
              final initMode=initMode) if plugPhase2 "Load 2" annotation (
                Placement(transformation(extent={{-10,-30},{10,-10}})));
            replaceable ProsNet.Electrical.Interfaces.Load load3(
              redeclare package PhaseSystem =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n
                terminal,
              final linearized=linearized,
              final mode=mode,
              final P_nominal=P_nominal,
              final V_nominal=V_nominal/sqrt(3),
              final initMode=initMode) if plugPhase3 "Load 3" annotation (
                Placement(transformation(extent={{-10,-98},{10,-78}})));
            Modelica.Blocks.Interfaces.RealInput y1 if plugPhase1 and mode ==
              ProsNet.Electrical.Types.Load.VariableZ_y_input
              "Fraction of the nominal power consumed"                       annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,80}),iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,80})));
            Modelica.Blocks.Interfaces.RealInput Pow1(unit="W") if plugPhase1
               and mode == ProsNet.Electrical.Types.Load.VariableZ_P_input
                                                                        "Power consumed"
                                                     annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,80}),iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,80})));
            Modelica.Blocks.Interfaces.RealInput y2 if plugPhase2 and mode ==
              ProsNet.Electrical.Types.Load.VariableZ_y_input
              "Fraction of the nominal power consumed"                       annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,0}), iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,0})));
            Modelica.Blocks.Interfaces.RealInput Pow2(unit="W") if plugPhase2
               and mode == ProsNet.Electrical.Types.Load.VariableZ_P_input
                                                                        "Power consumed"
                                                     annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,0}), iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,0})));
            Modelica.Blocks.Interfaces.RealInput y3 if plugPhase3 and mode ==
              ProsNet.Electrical.Types.Load.VariableZ_y_input
              "Fraction of the nominal power consumed"                       annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,-80}),
                                   iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,-80})));
            Modelica.Blocks.Interfaces.RealInput Pow3(unit="W") if plugPhase3
               and mode == ProsNet.Electrical.Types.Load.VariableZ_P_input
                                                                        "Power consumed"
                                                     annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,-80}),
                                   iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=180,
                  origin={120,-80})));
            ProsNet.Electrical.Utilities.VoltageControl vCTRL_1(
              redeclare package PhaseSystem =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n
                terminal,
              vThresh=vThresh,
              tDelay=tDelay,
              V_nominal=V_nominal/sqrt(3)) if plugPhase1 and voltageCtrl
              "Voltage controller for load 1"
              annotation (Placement(transformation(extent={{10,80},{30,100}})));
            Modelica.Blocks.Math.Product cmd1 if plugPhase1 and voltageCtrl
              "Block that impose voltage ctrl"
              annotation (Placement(transformation(extent={{56,56},{36,76}})));
            ProsNet.Electrical.Utilities.VoltageControl vCTRL_2(
              redeclare package PhaseSystem =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n
                terminal,
              vThresh=vThresh,
              tDelay=tDelay,
              V_nominal=V_nominal/sqrt(3)) if plugPhase2 and voltageCtrl
              "Voltage controller for load 2"
              annotation (Placement(transformation(extent={{10,10},{30,30}})));
            Modelica.Blocks.Math.Product cmd2 if plugPhase2 and voltageCtrl
              "Block that impose voltage ctrl"
              annotation (Placement(transformation(extent={{56,-16},{36,4}})));
            ProsNet.Electrical.Utilities.VoltageControl vCTRL_3(
              redeclare package PhaseSystem =
                  ProsNet.Electrical.PhaseSystems.OnePhase,
              redeclare ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n
                terminal,
              vThresh=vThresh,
              tDelay=tDelay,
              V_nominal=V_nominal/sqrt(3)) if plugPhase3 and voltageCtrl
              "Voltage controller for load 3" annotation (Placement(
                  transformation(extent={{10,-60},{30,-40}})));
            Modelica.Blocks.Math.Product cmd3 if plugPhase3 and voltageCtrl
              "Block that impose voltage ctrl"
              annotation (Placement(transformation(extent={{56,-80},{36,-60}})));
            Interfaces.WyeToDelta
              wyeToDelta if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_delta)
              "Wye to delta load connection"
              annotation (Placement(transformation(extent={{-54,0},{-34,20}})));
            Interfaces.WyeToWyeGround
              wyeToWyeGround if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg)
              "Wye to wye grounded connection"
              annotation (Placement(transformation(extent={{-54,-20},{-34,0}})));
          protected
            Interfaces.Adapter3to3 adaDel if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_delta)
              "Adapter"
              annotation (Placement(transformation(extent={{-40,-50},{-60,-30}})));
            Interfaces.Adapter3to3 adaWye if (loadConn == ProsNet.Electrical.Types.LoadConnection.wye_to_wyeg)
              "Adapter"
              annotation (Placement(transformation(extent={{-40,-80},{-60,-60}})));
          equation
            // Connections enabled when the input provided is y (between 0 and 1)
            if mode == ProsNet.Electrical.Types.Load.VariableZ_y_input then
              if plugPhase1 and voltageCtrl then
                connect(cmd1.y, load1.y) annotation (Line(
                  points={{35,66},{20,66},{20,50},{10,50}},
                  color={0,0,127},
                  smooth=Smooth.None));
                connect(cmd1.u2, y1) annotation (Line(
                  points={{58,60},{90,60},{90,80},{120,80}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;
              if plugPhase1 and not voltageCtrl then
                connect(y1, load1.y) annotation (Line(
                  points={{120,80},{66,80},{66,50},{10,50}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;

              if plugPhase2 and voltageCtrl then
                connect(cmd2.y, load2.y) annotation (Line(
                points={{35,-6},{23,-6},{23,-20},{10,-20}},
                color={0,0,127},
                smooth=Smooth.None));
                connect(cmd2.u2, y2) annotation (Line(
                points={{58,-12},{72,-12},{72,0},{120,0}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if plugPhase2 and not voltageCtrl then
                connect(y2, load2.y) annotation (Line(
                points={{120,0},{66,0},{66,-20},{10,-20}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;

              if plugPhase3 and voltageCtrl then
                connect(cmd3.y, load3.y) annotation (Line(
                points={{35,-70},{24,-70},{24,-88},{10,-88}},
                color={0,0,127},
                smooth=Smooth.None));
                connect(cmd3.u2, y3) annotation (Line(
                points={{58,-76},{72,-76},{72,-80},{120,-80}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if plugPhase3 and not voltageCtrl then
                connect(y3, load3.y) annotation (Line(
                points={{120,-80},{72,-80},{72,-88},{10,-88}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
            end if;

            // Connections enabled when the input provided is the power
            if mode == ProsNet.Electrical.Types.Load.VariableZ_P_input then
              if plugPhase1 and voltageCtrl then
                connect(cmd1.y, load1.Pow) annotation (Line(
                  points={{35,66},{20,66},{20,50},{10,50}},
                  color={0,0,127},
                  smooth=Smooth.None));
                connect(cmd1.u2, Pow1) annotation (Line(
                  points={{58,60},{82,60},{82,80},{120,80}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;
              if plugPhase1 and not voltageCtrl then
                connect(Pow1, load1.Pow) annotation (Line(
                  points={{120,80},{70,80},{70,50},{10,50}},
                  color={0,0,127},
                  smooth=Smooth.None));
              end if;

              if plugPhase2 and voltageCtrl then
                connect(cmd2.y, load2.Pow) annotation (Line(
                points={{35,-6},{23,-6},{23,-20},{10,-20}},
                color={0,0,127},
                smooth=Smooth.None));
                connect(cmd2.u2, Pow2) annotation (Line(
                points={{58,-12},{72,-12},{72,0},{120,0}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if plugPhase2 and not voltageCtrl then
                connect(Pow2, load2.Pow) annotation (Line(
                points={{120,0},{72,0},{72,-20},{10,-20}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;

              if plugPhase3 and voltageCtrl then
                connect(cmd3.y, load3.Pow) annotation (Line(
                points={{35,-70},{24,-70},{24,-88},{10,-88}},
                color={0,0,127},
                smooth=Smooth.None));
                connect(cmd3.u2, Pow3) annotation (Line(
                points={{58,-76},{72,-76},{72,-80},{120,-80}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
              if plugPhase3 and not voltageCtrl then
                connect(Pow3, load3.Pow) annotation (Line(
                points={{120,-80},{72,-80},{72,-88},{10,-88}},
                color={0,0,127},
                smooth=Smooth.None));
              end if;
            end if;

            // Connections enabled when phase 1 is plugged and voltage ctrl activated
            if plugPhase1 and voltageCtrl then
              connect(load1.terminal, vCTRL_1.terminal)        annotation (Line(
                points={{-10,50},{-20,50},{-20,90},{10,90}},
                color={0,120,120},
                smooth=Smooth.None));
              connect(vCTRL_1.y, cmd1.u1)        annotation (Line(
                  points={{30.6,90},{70,90},{70,72},{58,72}},
                  color={0,0,127},
                  smooth=Smooth.None));
            end if;

            if plugPhase2 and voltageCtrl then
              connect(load2.terminal, vCTRL_2.terminal) annotation (Line(
                points={{-10,-20},{-20,-20},{-20,20},{10,20}},
                color={0,120,120},
                smooth=Smooth.None));
              connect(vCTRL_2.y, cmd2.u1) annotation (Line(
                  points={{30.6,20},{66,20},{66,0},{58,0}},
                  color={0,0,127},
                  smooth=Smooth.None));
            end if;

            if plugPhase3 and voltageCtrl then
              connect(load3.terminal, vCTRL_3.terminal) annotation (Line(
                points={{-10,-88},{-20,-88},{-20,-50},{10,-50}},
                color={0,120,120},
                smooth=Smooth.None));
              connect(vCTRL_3.y, cmd3.u1) annotation (Line(
                  points={{30.6,-50},{66,-50},{66,-64},{58,-64}},
                  color={0,0,127},
                  smooth=Smooth.None));
            end if;

            // Connection of the single loads to the 3phases connector
            if plugPhase1 then
              connect(load1.terminal, adaDel.terminals[1]) annotation (Line(points={{-10,50},
                      {-26,50},{-26,-39.4667},{-40.2,-39.4667}},
                                                             color={0,120,120}));
              connect(load1.terminal, adaWye.terminals[1]) annotation (Line(points={{-10,50},
                      {-26,50},{-26,-69.4667},{-40.2,-69.4667}},
                                                             color={0,120,120}));
            end if;

            if plugPhase2 then
              connect(load2.terminal, adaDel.terminals[2]) annotation (Line(points={{-10,-20},
                      {-22,-20},{-22,-40},{-40.2,-40}},
                                                    color={0,120,120}));
              connect(load2.terminal, adaWye.terminals[2]) annotation (Line(points={{-10,-20},
                      {-22,-20},{-22,-70},{-40.2,-70}},
                                                    color={0,120,120}));
            end if;
            if plugPhase3 then
              connect(load3.terminal, adaDel.terminals[3]) annotation (Line(points={{-10,-88},
                      {-16,-88},{-20,-88},{-20,-40.5333},{-40.2,-40.5333}},
                                                                        color={0,120,120}));
              connect(load3.terminal, adaWye.terminals[3]) annotation (Line(points={{-10,-88},
                      {-20,-88},{-20,-70.5333},{-40.2,-70.5333}},
                                                              color={0,120,120}));
            end if;

            connect(adaDel.terminal, wyeToDelta.delta) annotation (Line(points={{-60,-40},
                    {-64,-40},{-64,-20},{-28,-20},{-28,10},{-34,10}}, color={0,120,120}));
            connect(adaWye.terminal, wyeToWyeGround.wyeg) annotation (Line(points={{-60,-70},
                    {-66,-70},{-66,-18},{-30,-18},{-30,-10},{-34,-10}}, color={0,120,120}));
              annotation (    Documentation(info="<html>
<p>
This model represents a partial interface for a three-phase AC unbalanced
load.
</p>
<p>
The loads on each phase can be removed using the boolean flags
<code>plugPhase1</code>, <code>plugPhase2</code>, and <code>plugPhase3</code>.
These parameters can be used to generate unbalanced loads.
</p>
<p>
The loads can be connected either in wye (Y) or delta (D) configuration.
The parameter <code>loadConn</code> can be used for such a purpose.
</p>
<p>
Each load model has the option to be controlled by a voltage controller.
When enabled, the voltage controller unplugs the load for a certain amount of
time if the voltage exceeds a given threshold. Mode information about the
voltage controller can be found
<a href=\"modelica://Buildings.Electrical.Utilities.VoltageControl\">here</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 17, 2016, by Michael Wetter:<br/>
Corrected wrong annotation to avoid an error in the pedantic model check
in Dymola 2017 FD01 beta2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapters for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Provided value for <code>P_nominal</code> if
<code>mode &lt;&gt; Buildings.Electrical.Types.Load.VariableZ_P_input</code>.
This avoids a warning during translation of
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.Inductive\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.Inductive</a>.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end BaseLoadCtrl;

          partial model Impedance
            "Partial model of a three-phase unbalanced impedance without neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.BaseImpedance;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal_n terminal
              "Electrical connector" annotation (Placement(transformation(
                    extent={{-110,-10},{-90,10}})));

          equation
            connect(terminal, wyeToDelta.wye) annotation (Line(
                points={{-100,0},{-80,0},{-80,10},{-64,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(terminal, wyeToWyeGround.wye) annotation (Line(
                points={{-100,0},{-80,0},{-80,-10},{-64,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (    Documentation(info="<html>
<p>
This model represents a partial interface for a three-phase AC
unbalanced impedance without neutral cable.
</p>
<p>
The model can be configured in order to represent different type of
impedances as well as configurations.
</p>
<p>
The loads can be connected either in wye (Y) or delta (D) configuration.
The parameter <code>loadConn</code> can be used for such a purpose.
</p>
<p>
The model has three impedances that can be either connected in Y or
Delta configuration. The parameter <code>loadConn</code> can be used for
such a purpose. The Boolean parameter <code>inductive</code> can be selected
to specify the type of impedance.
</p>
<p>
The impedances on each phase can be removed using the boolean flags
<code>plugPhase1</code>, <code>plugPhase2</code>, and <code>plugPhase3</code>.
These parameters can be used to generate unbalanced loads.
</p>
<p>
The values of the impedances are computed starting from the parameters <code>R</code>,
<code>L</code>, and <code>C</code>. Depending on the values of the boolean flag
<code>inductive</code> some of these parameters may be disabled. There are additional
flags <code>use_R_in</code>, <code>use_L_in</code>, and <code>use_C_in</code> that can
be used to specify time varying impedances.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model from previus version.
</li>
</ul>
</html>"));
          end Impedance;

          partial model Impedance_N
            "Partial model of a three-phase unbalanced impedance with neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.BaseImpedance;
            Interfaces.Terminal4_n terminal "Electrical connector"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Interfaces.Connection3to4_n connection3to4
              "Connection from three-phase and neutral to three-phase" annotation (Placement(transformation(extent={{-88,-10},{-68,10}})));
          equation

            connect(connection3to4.terminal3, wyeToDelta.wye) annotation (Line(
                points={{-68,6.66134e-16},{-68,10},{-64,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(connection3to4.terminal3, wyeToWyeGround.wye) annotation (Line(
                points={{-68,4.44089e-16},{-68,-10},{-64,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(connection3to4.terminal4, terminal) annotation (Line(
                points={{-88,0},{-100,0}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (    Documentation(info="<html>
<p>
This model represents a partial interface for a three-phase AC
unbalanced impedance with a neutral cable. The current in the neutral
cable is computed as the algebraic sum of the currents in the loads.
</p>
<p>
The model can be configured in order to represent different type of
impedances as well as configurations.
</p>
<p>
The loads can be connected either in wye (Y) or delta (D) configuration.
The parameter <code>loadConn</code> can be used for such a purpose.
</p>
<p>
The model has three impedances that can be either connected in Y or
Delta configuration. The parameter <code>loadConn</code> can be used for
such a purpose. The Boolean parameter <code>inductive</code> can be selected
to specify the type of impedance.
</p>
<p>
The impedances on each phase can be removed using the boolean flags
<code>plugPhase1</code>, <code>plugPhase2</code>, and <code>plugPhase3</code>.
These parameters can be used to generate unbalanced loads.
</p>
<p>
The values of the impedances are computed starting from the parameters <code>R</code>,
<code>L</code>, and <code>C</code>. Depending on the values of the boolean flag
<code>inductive</code> some of these parameters may be disabled. There are additional
flags <code>use_R_in</code>, <code>use_L_in</code>, and <code>use_C_in</code> that can
be used to specify time varying impedances.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Created model from previus version.
</li>
</ul>
</html>"));
          end Impedance_N;

          partial model LoadCtrl
            "Partial model of a three-phase load with voltage controller without neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.BaseLoadCtrl;
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal_n
              terminal
              "Connector for three-phase unbalanced systems without neutral cable"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          equation

            connect(terminal, wyeToDelta.wye) annotation (Line(
                points={{-100,0},{-78,0},{-78,10},{-54,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(terminal, wyeToWyeGround.wye) annotation (Line(
                points={{-100,0},{-78,0},{-78,-10},{-54,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (    Documentation(info="<html>
<p>
This model represents a partial interface for a three-phase AC unbalanced
load without neutral cable.
</p>
<p>
The loads on each phase can be removed using the boolean flags
<code>plugPhase1</code>, <code>plugPhase2</code>, and <code>plugPhase3</code>.
These parameters can be used to generate unbalanced loads.
</p>
<p>
The loads can be connected either in wye (Y) or delta (D) configuration.
The parameter <code>loadConn</code> can be used for such a purpose.
</p>
<p>
Each load model has the option to be controlled by a voltage controller.
When enabled, the voltage controller unplugs the load for a certain amount of
time if the voltage exceeds a given threshold. Mode information about the
voltage controller can be found
<a href=\"modelica://Buildings.Electrical.Utilities.VoltageControl\">here</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised model, it now extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.PartialLoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.PartialLoadCtrl</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end LoadCtrl;

          partial model LoadCtrl_N
            "Partial model of a three-phase unbalanced load with voltage controller and neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.BaseLoadCtrl;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal4_n terminal
              "Connector for three-phase unbalanced systems with neutral cable"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Connection3to4_n
              connection3to4
              "Connection from three-phase and neutral to three-phase"
              annotation (Placement(transformation(extent={{-84,-10},{-64,10}})));
          equation

            connect(connection3to4.terminal3, wyeToDelta.wye) annotation (Line(
                points={{-64,0},{-58,0},{-58,10},{-54,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(connection3to4.terminal3, wyeToWyeGround.wye) annotation (Line(
                points={{-64,0},{-58,0},{-58,-10},{-54,-10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(connection3to4.terminal4, terminal) annotation (Line(
                points={{-84,0},{-100,0}},
                color={127,0,127},
                smooth=Smooth.None));
              annotation (    Documentation(info="<html>
<p>
This model represents a partial interface for a three-phase AC unbalanced
load with neutral cable. The current in the neutral cable is computed as the
algebraic sum of the currents in the loads.
</p>
<p>
The loads on each phase can be removed using the boolean flags
<code>plugPhase1</code>, <code>plugPhase2</code>, and <code>plugPhase3</code>.
These parameters can be used to generate unbalanced loads.
</p>
<p>
The loads can be connected either in wye (Y) or delta (D) configuration.
The parameter <code>loadConn</code> can be used for such a purpose.
</p>
<p>
Each load model has the option to be controlled by a voltage controller.
When enabled, the voltage controller unplugs the load for a certain amount of
time if the voltage exceeds a given threshold. Mode information about the
voltage controller can be found
<a href=\"modelica://Buildings.Electrical.Utilities.VoltageControl\">here</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised model, it now extends from
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.PartialLoadCtrl\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads.BaseClasses.PartialLoadCtrl</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end LoadCtrl_N;
        annotation (Documentation(info="<html>
<p>
This package contains base classes used by the models that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Loads</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end BaseClasses;
      annotation (Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised load models, now they all have the optional voltage controller and the
ability to select the type of connection: Wye (Y) or Delta (D).
</li>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",       info="<html>
<p>
This package contains models that represent different types of three
phases unbalanced AC loads.
</p>
</html>"));
      end Loads;

      package Sensors "Package with sensor models for three-phase unbalanced AC systems"
        extends Modelica.Icons.SensorsPackage;

        model GeneralizedSensor
          "Sensor for power, voltage and current (3 wire system, no neutral cable)"

          Interfaces.Terminal_n terminal_n "Electrical connector side N"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Interfaces.Terminal_p terminal_p "Electrical connector side P"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.Blocks.Interfaces.RealOutput V[3](each final quantity="ElectricPotential",
                                                  each final unit="V") "Voltage"           annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={10,-40}),  iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-90})));
          Modelica.Blocks.Interfaces.RealOutput I[3](each final quantity="ElectricCurrent",
                                                  each final unit="A") "Current"           annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={70,-40}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={60,-90})));
          Modelica.Blocks.Interfaces.RealOutput S[3,ProsNet.Electrical.PhaseSystems.OnePhase.n](
             each final quantity="Power", each final unit="W") "Phase powers"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-50,-40}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-90})));
        equation

          for i in 1:3 loop
            V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal_n.phase[i].v);
            I[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemCurrent(
              terminal_n.phase[i].i);
            S[i, :] = ProsNet.Electrical.PhaseSystems.OnePhase.phasePowers_vi(v=
               terminal_n.phase[i].v, i=terminal_n.phase[i].i);
          end for;

          connect(terminal_n, terminal_p) annotation (Line(
              points={{-100,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (defaultComponentName="sen",
         Icon(graphics={
                Rectangle(
                  extent={{-70,28},{70,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-60,60},{60,-60}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-92,0},{-70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-120,-42},{0,-82}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="S"),
                Polygon(
                  points={{-0.48,33.6},{18,28},{18,59.2},{-0.48,33.6}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-37.6,15.7},{-54,22}},     color={0,0,0}),
                Line(points={{-22.9,34.8},{-32,50}},     color={0,0,0}),
                Line(points={{0,60},{0,42}}, color={0,0,0}),
                Line(points={{22.9,34.8},{32,50}},     color={0,0,0}),
                Line(points={{37.6,15.7},{54,24}},     color={0,0,0}),
                Line(points={{0,2},{9.02,30.6}}, color={0,0,0}),
                Ellipse(
                  extent={{-5,7},{5,-3}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{70,0},{92,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-60,-42},{60,-82}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="V"),
                Text(
                  extent={{0,-40},{120,-80}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="I"),
                Text(
                  extent={{-120,100},{120,60}},
                  textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Ideal sensor that measures power, voltage and current in a three-phase unbalanced system
without a neutral cable.
The two components of the power <i>S</i> are the active and reactive power for each phase.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Corrected wrong access to phase system.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/570\">#570</a>.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end GeneralizedSensor;

        model GeneralizedSensor_N
          "Sensor for power, voltage and current (4 wire system, with neutral cable)"

          Interfaces.Terminal4_n terminal_n "Electrical connector side N"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          Interfaces.Terminal4_p terminal_p "Electrical connector side P"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Modelica.Blocks.Interfaces.RealOutput V[4](each final quantity="ElectricPotential",
                                                  each final unit="V") "Voltage"
            annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={10,-40}),  iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-90})));
          Modelica.Blocks.Interfaces.RealOutput I[4](each final quantity="ElectricCurrent",
                                                  each final unit="A") "Current"
           annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={70,-40}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={60,-90})));
          Modelica.Blocks.Interfaces.RealOutput S[4,ProsNet.Electrical.PhaseSystems.OnePhase.n](
             each final quantity="Power", each final unit="W") "Phase powers"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-50,-40}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-60,-90})));
        equation

          for i in 1:4 loop
            V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
              terminal_n.phase[i].v);
            I[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemCurrent(
              terminal_n.phase[i].i);
            S[i, :] = ProsNet.Electrical.PhaseSystems.OnePhase.phasePowers_vi(v=
               terminal_n.phase[i].v, i=terminal_n.phase[i].i);
          end for;

          connect(terminal_n, terminal_p) annotation (Line(
              points={{-100,0},{100,0}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (defaultComponentName="sen",
         Icon(graphics={
                Rectangle(
                  extent={{-70,28},{70,-30}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-60,60},{60,-60}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-92,0},{-70,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-120,-42},{0,-82}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="S"),
                Polygon(
                  points={{-0.48,33.6},{18,28},{18,59.2},{-0.48,33.6}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{-37.6,15.7},{-54,22}},     color={0,0,0}),
                Line(points={{-22.9,34.8},{-32,50}},     color={0,0,0}),
                Line(points={{0,60},{0,42}}, color={0,0,0}),
                Line(points={{22.9,34.8},{32,50}},     color={0,0,0}),
                Line(points={{37.6,15.7},{54,24}},     color={0,0,0}),
                Line(points={{0,2},{9.02,30.6}}, color={0,0,0}),
                Ellipse(
                  extent={{-5,7},{5,-3}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{70,0},{92,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-60,-42},{60,-82}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="V"),
                Text(
                  extent={{0,-40},{120,-80}},
                  textColor={0,0,0},
                  lineThickness=1,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="I"),
                Text(
                  extent={{-120,100},{120,60}},
                  textColor={0,0,0},
                  textString="%name")}),
            Documentation(info="<html>
<p>
Ideal sensor that measures power, voltage and current in a three-phase unbalanced system
with neutral cable.
The two components of the power <i>S</i> are the active and reactive power for each phase.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 8, 2016, by Michael Wetter:<br/>
Corrected wrong access to phase system.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/570\">#570</a>.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end GeneralizedSensor_N;

        model ProbeDelta
          "Model of a probe that measures voltage magnitude and angle (Delta configuration)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe;
          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal_n term
            "Electrical connector" annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-90})));
          Interfaces.WyeToDelta wyeToDelta "Y to D transformation"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                origin={20,0})));
        equation
          for i in 1:3 loop
            theta[i] = ProsNet.Electrical.PhaseSystems.OnePhase.phase(
              wyeToDelta.delta.phase[i].v);
              if perUnit then
              V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
                wyeToDelta.delta.phase[i].v)/V_nominal;
              else
              V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
                wyeToDelta.delta.phase[i].v);
              end if;
          end for;

          connect(term, wyeToDelta.wye) annotation (Line(
              points={{0,-90},{0,4.44089e-16},{10,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (defaultComponentName="sen",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Text(
                  extent={{40,60},{100,40}},
                  textColor={0,120,120},
                  pattern=LinePattern.Dash,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid,
                  textString="V"), Text(
                  extent={{18,-40},{140,-60}},
                  textColor={0,120,120},
                  pattern=LinePattern.Dash,
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid,
                  textString="theta"),
                Line(
                  points={{-20,-44},{0,-14},{20,-44},{-20,-44}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5)}),         Documentation(info="<html>
<p>
This model represents a probe that measures the RMS voltage and the angle
of the voltage phasors at a given point. The probes are connected
in the Wye (Y) grounded configuration.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ProbeDelta;

        model ProbeWye
          "Model of a probe that measures voltage magnitude and angle (Wye configuration)"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe;
          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal_n term
            "Electrical connector" annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-90})));
          Interfaces.WyeToWyeGround wyeToWyeGround "Y to Y grounded transformation"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                origin={20,0})));
        equation
          for i in 1:3 loop
            theta[i] = ProsNet.Electrical.PhaseSystems.OnePhase.phase(
              wyeToWyeGround.wyeg.phase[i].v);
              if perUnit then
              V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
                wyeToWyeGround.wyeg.phase[i].v)/(V_nominal/sqrt(3));
              else
              V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
                wyeToWyeGround.wyeg.phase[i].v);
              end if;
          end for;

          connect(term, wyeToWyeGround.wye) annotation (Line(
              points={{0,-90},{0,4.44089e-16},{10,4.44089e-16}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (defaultComponentName="sen",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{0,-10},{0,-30},{-14,-44}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,-30},{14,-44}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5)}),
        Documentation(info="<html>
<p>
This model represents a probe that measures the RMS voltage and the angle
of the voltage phasors at a given point. The probes are connected
in the Wye (Y) grounded configuration.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ProbeWye;

        model ProbeWye_N
          "Model of a probe that measures voltage magnitude and angle (Wye configuration) witn neutral cable connection"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe;
          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal4_n term
            "Electrical connector" annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-90})));
        equation

          for i in 1:4 loop
            term.phase[i].i = zeros(ProsNet.Electrical.PhaseSystems.OnePhase.n);
          end for;

          for i in 1:3 loop
            theta[i] = ProsNet.Electrical.PhaseSystems.OnePhase.phase(term.phase[
              i].v - term.phase[4].v);
              if perUnit then
              V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
                term.phase[i].v - term.phase[4].v)/(V_nominal/sqrt(3));
              else
              V[i] = ProsNet.Electrical.PhaseSystems.OnePhase.systemVoltage(
                term.phase[i].v - term.phase[4].v);
              end if;
          end for;
          annotation (defaultComponentName="sen",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{0,-10},{0,-30},{-14,-44}},
                  color={127,0,127},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,-30},{14,-44}},
                  color={127,0,127},
                  smooth=Smooth.None,
                  thickness=0.5)}),
        Documentation(info="<html>
<p>
This model represents a probe that measures the RMS voltage and the angle
of the voltage phasors at a given point. The probes are connected
in the Wye (Y) grounded configuration.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ProbeWye_N;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model Sensors "Test models for sensors and probes"
            extends Modelica.Icons.Example;
            Sources.FixedVoltage source(
              f=60,
              V=480)
              "Voltage source without neutral cable"
                     annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
            Loads.Resistive load(
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input)
              "Load model"
              annotation (Placement(transformation(extent={{20,20},{40,40}})));
            ProbeWye probeWye(V_nominal=480) "Probe that measures the phase voltages"
              annotation (Placement(transformation(extent={{-46,48},{-26,68}})));
            ProbeDelta probeDelta(V_nominal=480) "Probe that measures the line voltages"
              annotation (Placement(transformation(extent={{-20,48},{0,68}})));
            Sources.FixedVoltage_N source_N(
              f=60,
              V=480)
              "Voltage source with neutral cable"
              annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
            Loads.Resistive_N load_N(
              V_nominal=480,
              mode=ProsNet.Electrical.Types.Load.VariableZ_P_input)
              "Load model"
              annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
            ProbeWye_N probeWye_N(V_nominal=480)
              annotation (Placement(transformation(extent={{-30,-12},{-10,8}})));
            GeneralizedSensor sen "Generalized sensor withour neutral cable"
              annotation (Placement(transformation(extent={{-4,20},{16,40}})));
            GeneralizedSensor_N sen_N "Generalized sensor with neutral cable"
              annotation (Placement(transformation(extent={{-8,-40},{12,-20}})));
            Modelica.Blocks.Sources.Ramp ramp(
              height=2e4,
              duration=0.5,
              offset=-1e4,
              startTime=0.25)
              annotation (Placement(transformation(extent={{80,-10},{60,10}})));
          equation
            connect(probeWye.term, source.terminal) annotation (Line(
                points={{-36,49},{-36,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(probeDelta.term, source.terminal) annotation (Line(
                points={{-10,49},{-10,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(source_N.terminal, probeWye_N.term) annotation (Line(
                points={{-60,-30},{-20,-30},{-20,-11}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(source_N.terminal, sen_N.terminal_n) annotation (Line(
                points={{-60,-30},{-8,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen_N.terminal_p, load_N.terminal) annotation (Line(
                points={{12,-30},{20,-30}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen.terminal_p, load.terminal) annotation (Line(
                points={{16,30},{20,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_n, source.terminal) annotation (Line(
                points={{-4,30},{-60,30}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow1) annotation (Line(
                points={{59,0},{50,0},{50,38},{42,38}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow2) annotation (Line(
                points={{59,0},{50,0},{50,30},{42,30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, load.Pow3) annotation (Line(
                points={{59,0},{50,0},{50,22},{42,22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, load_N.Pow1) annotation (Line(
                points={{59,0},{50,0},{50,-22},{42,-22}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, load_N.Pow2) annotation (Line(
                points={{59,0},{50,0},{50,-30},{42,-30}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(ramp.y, load_N.Pow3) annotation (Line(
                points={{59,0},{50,0},{50,-38},{42,-38}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation ( Documentation(
          revisions="<html>
<ul>
<li>
February 27, 2016 by Michael Wetter:<br/>
Stored example in a single file rather than a file with multiple examples.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/488\">#488</a>.
</li>
<li>
February 26, 2016, by Michael Wetter:<br/>
Removed unused parameter assignment for <code>P_nominal</code>.
</li>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>", info="<html>
<p>
This example shows how different types of sensors and probes can be used
to measure the voltages, currents and powers in a three-phase
unbalanced system.
</p>
<p>
In this example all the loads are directly connected to the sources,
avoiding voltage losses. The loads are all resistive and they start
by consuming <i>10</i> kW for each phase, while at the end of the simulation
they all produce <i>10</i> kW.
</p>
</html>"),experiment(StopTime=1.0, Tolerance=1e-6),
          __Dymola_Commands(file=
           "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Sensors/Examples/Sensors.mos"
                  "Simulate and plot"));
          end Sensors;
          annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors</a>.
</p>
</html>"));
        end Examples;

        package BaseClasses "Package that contains base classes"
        extends Modelica.Icons.BasesPackage;

          partial model GeneralizedProbe
            "Partial model of a generalized three-phase probe"
            extends Icons.GeneralizedProbe;
            parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
              "RMS Nominal voltage (V_nominal >= 0)";
            parameter Boolean perUnit = true "This flag display voltage in p.u.";
            Modelica.Blocks.Interfaces.RealOutput V[3](each unit="1")
              "Voltage in per unit"                                                         annotation (Placement(
                  transformation(extent={{60,20},{80,40}}), iconTransformation(extent={{60,
                      20},{80,40}})));
            Modelica.Blocks.Interfaces.RealOutput theta[3](each unit="rad", each displayUnit="deg") "Angle" annotation (Placement(
                  transformation(extent={{60,-40},{80,-20}}), iconTransformation(extent={{60,
                      -40},{80,-20}})));
            annotation (Icon(graphics={      Text(
                    extent={{40,60},{100,40}},
                    textColor={0,0,0},
                    pattern=LinePattern.Dash,
                    fillColor={0,120,120},
                    fillPattern=FillPattern.Solid,
                    textString="V"), Text(
                    extent={{18,-40},{140,-60}},
                    textColor={0,0,0},
                    pattern=LinePattern.Dash,
                    fillColor={0,120,120},
                    fillPattern=FillPattern.Solid,
                    textString="theta")}), Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
This model contains the parameters and connectors that are used by
probe models such as <a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye</a> and
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta</a>.
The output connectors are for the RMS voltage and the angle of the voltage phasors.
</p>
</html>"));
          end GeneralizedProbe;
        annotation (Documentation(info="<html>
<p>
This package contains base classes used by the models that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Sensors</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end BaseClasses;
      annotation (Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",       info="<html>
<p>
This package contains models that represent different types of three
phases unbalanced AC/AC sensors.
</p>
</html>"));
      end Sensors;

      package Sources "Package with sources model for three-phase unbalanced AC systems"
        extends Modelica.Icons.SourcesPackage;

        model FixedVoltage "Fixed voltage source"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.PartialSource;
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Voltage V(start=480) "RMS voltage of the source";
          parameter Modelica.Units.SI.Angle phiSou=0 "Phase shift of the source";
          parameter Boolean potentialReference = true
            "Serve as potential root for the reference angle theta"
             annotation (Evaluate=true, Dialog(group="Reference Parameters"));
          parameter Boolean definiteReference = false
            "Serve as definite root for the reference angle theta"
             annotation (Evaluate=true, Dialog(group="Reference Parameters"));
          constant Modelica.Units.SI.Angle angle120=2*Modelica.Constants.pi/3
            "Phase shift between the phase voltages";
          OnePhase.Sources.FixedVoltage vPhase[3](
            each f=f,
            potentialReference={potentialReference, potentialReference, potentialReference},
            definiteReference={definiteReference, false, false},
            phiSou={phiSou,phiSou - angle120,phiSou + angle120},
            each V=V/sqrt(3)) "Voltage sources on the three-phase"
                     annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
        protected
          Interfaces.Adapter3to3 ada "Adapter between the different connectors"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        equation

          connect(vPhase.terminal, ada.terminals)
            annotation (Line(points={{-30,0},{-9.8,0},{-9.8,0}},
                                                               color={0,120,120}));
          connect(ada.terminal, connection3to4.terminal4)
            annotation (Line(points={{10,0},{25,0},{40,0}}, color={0,120,120}));
          annotation (
          defaultComponentName="sou",
         Icon(graphics={
                Ellipse(
                  extent={{-60,60},{60,-60}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Line(
                  points={{-34,0},{-14,40},{6,0},{26,-40},{46,0}},
                  color={120,120,120},
                  smooth=Smooth.Bezier),          Line(
                  points={{-44,0},{-24,40},{-4,0},{16,-40},{36,0}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),          Line(
                  points={{-24,0},{-4,40},{16,0},{36,-40},{56,0}},
                  color={215,215,215},
                  smooth=Smooth.Bezier),
                Line(
                  points={{60,0},{90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-120,100},{120,60}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-120,-60},{120,-100}},
                  textColor={0,0,0},
                  textString="V = %V")}),
            Documentation(info="<html>
<p>
This is a constant voltage source, specifying the complex voltage
by the RMS voltage and the phase shift.
</p>
<p>
The parameters <code>potentialReference</code> and <code>definiteReference</code>
are used to define if the source model should be selected as source for
the reference angles <code>theta</code> or not.
More information about overdetermined connectors can be found
in <a href=\"#Olsson2008\">Olsson Et Al. (2008)</a>.
</p>

<h4>References</h4>
<p>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Updated documentation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/427\">issue 427</a>.
</li>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter model for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end FixedVoltage;

        model FixedVoltage_N "Fixed voltage source with neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.PartialSource_N;
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Voltage V(start=480) "RMS voltage of the source";
          parameter Modelica.Units.SI.Angle phiSou=0 "Phase shift of the source";
          parameter Boolean potentialReference = true
            "Serve as potential root for the reference angle theta"
             annotation (Evaluate=true, Dialog(group="Reference Parameters"));
          parameter Boolean definiteReference = false
            "Serve as definite root for the reference angle theta"
             annotation (Evaluate=true, Dialog(group="Reference Parameters"));
          constant Modelica.Units.SI.Angle angle120=2*Modelica.Constants.pi/3
            "Phase shift between the phase voltages";
          OnePhase.Sources.FixedVoltage vPhase[3](
            each f=f,
            phiSou={phiSou, phiSou + angle120, phiSou + 2*angle120},
            potentialReference={potentialReference, potentialReference, potentialReference},
            definiteReference={definiteReference, false, false},
            each V=V/sqrt(3)) "Voltage sources on the three-phase"
                     annotation (Placement(transformation(extent={{-30,-10},{-10,10}})));
        equation

          connect(vPhase[1].terminal, terminal.phase[1]) annotation (Line(
              points={{-10,0},{20,0},{20,0.05},{100.05,0.05}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(vPhase[2].terminal, terminal.phase[2]) annotation (Line(
              points={{-10,0},{10,0},{10,0.05},{100.05,0.05}},
              color={0,120,120},
              smooth=Smooth.None));
          connect(vPhase[3].terminal, terminal.phase[3]) annotation (Line(
              points={{-10,0},{45,0},{45,0.05},{100.05,0.05}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="sou",
         Icon(graphics={
                Ellipse(
                  extent={{-60,60},{60,-60}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Line(
                  points={{-34,0},{-14,40},{6,0},{26,-40},{46,0}},
                  color={120,120,120},
                  smooth=Smooth.Bezier),          Line(
                  points={{-44,0},{-24,40},{-4,0},{16,-40},{36,0}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),          Line(
                  points={{-24,0},{-4,40},{16,0},{36,-40},{56,0}},
                  color={215,215,215},
                  smooth=Smooth.Bezier),
                Line(
                  points={{60,0},{90,0}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Text(
                  extent={{-120,100},{120,60}},
                  textColor={0,0,0},
                  textString="%name"),
                Text(
                  extent={{-120,-60},{120,-100}},
                  textColor={0,0,0},
                  textString="V = %V")}),
            Documentation(info="<html>
<p>
This is a constant voltage source, specifying the complex
voltage by the RMS voltage and the phase shift. The model has also
the neutral cable, connected to a ground reference by default.
</p>
<p>
The parameters <code>potentialReference</code> and <code>definiteReference</code>
are used to define if the source model should be selected as source for
the reference angles <code>theta</code> or not.
More information about overdetermined connectors can be found
in <a href=\"#Olsson2008\">Olsson Et Al. (2008)</a>.
</p>

<h4>References</h4>
<p>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Updated documentation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/427\">issue 427</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end FixedVoltage_N;

        model Grid "Electrical grid"
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Voltage V(start=480) "RMS voltage of the source";
          parameter Modelica.Units.SI.Angle phiSou=0 "Phase shift of the source";
          ProsNet.Electrical.AC.Interfaces.PowerOutput P[3]
            "Power consumed from grid if positive, or fed to grid if negative"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal_p terminal
            "Connector for three-phase unbalanced systems" annotation (
              Placement(transformation(extent={{-10,-110},{10,-90}}),
                iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-100})));

          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.FixedVoltage sou(
            potentialReference=true,
            definiteReference=true,
            f=f,
            V=V,
            phiSou=phiSou) "Voltage source" annotation (Placement(
                transformation(extent={{10,-10},{-10,10}}, origin={10,0})));
        equation
          for i in 1:3 loop
            P[i].real = -sou.vPhase[i].S[1];
            P[i].apparent = sqrt(sou.vPhase[i].S[2]^2 + sou.vPhase[i].S[1]^2);
            P[i].phi = sou.vPhase[i].phi;
            P[i].cosPhi = cos(sou.vPhase[i].phi);
          end for;
          connect(sou.terminal, terminal) annotation (Line(
              points={{-4.44089e-16,6.66134e-16},{-4.44089e-16,-100},{4.44089e-16,-100}},
              color={0,120,120},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="gri",
            Documentation(info="<html>
<p>
Model that can be used to represent the electrical grid supply.
</p>
<p>
The model has an output connector named <code>P[n]</code> with <code>n = 3</code> that
contains information about the power supplied by the grid to the network.
The convention is that <code>P[i].real</code> is positive if real power is
consumed from the grid, and negative if it is fed into the grid.
The connector has size equal to three because each element
of the vector refers to a single phase.
</p>
<p>
The parameter <code>V</code> is the root means square of the voltage.
In US, a typical value <i>480</i> Volts.
</p>
</html>",revisions="<html>
<ul>
<li>
August 31, 2016, by Michael Wetter:<br/>
Corrected sign error in documentation string of variable <code>P</code>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-120,130},{120,100}},
                  textColor={0,120,120},
                  textString="%name"),
                Line(
                  points={{-60,-32},{-60,-72}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-74,-32},{-44,-32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-72,-38},{-48,-28},{-28,-16},{-16,-2},{-12,14}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-46,-38},{-22,-28},{-2,-16},{10,-2},{14,14}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-72,-32},{-72,-38}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-46,-32},{-46,-38}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-14,20},{16,20}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,20},{0,-20}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-12,20},{-12,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{14,20},{14,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{14,14},{38,24},{58,36},{70,50},{74,66}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-12,14},{12,24},{32,36},{44,50},{48,66}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{60,72},{60,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{46,72},{76,72}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{48,72},{48,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{74,72},{74,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-100,-76},{-96,-74},{-88,-68},{-76,-54},{-72,-38}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-100,-88},{-82,-80},{-62,-68},{-50,-54},{-46,-38}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{48,68},{72,78},{92,90},{98,94},{100,96}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{74,68},{84,72},{100,82}},
                  color={175,175,175},
                  smooth=Smooth.Bezier)}));
        end Grid;

        model Grid_N "Electrical grid with neutral cable"
          parameter Modelica.Units.SI.Frequency f(start=60) "Frequency of the source";
          parameter Modelica.Units.SI.Voltage V(start=480) "RMS voltage of the source";
          parameter Modelica.Units.SI.Angle phiSou=0 "Phase shift of the source";
          ProsNet.Electrical.AC.Interfaces.PowerOutput P[3]
            "Power consumed from grid if positive, or fed to grid if negative"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.Terminal4_p terminal
            "Connector for three-phase unbalanced systems" annotation (
              Placement(transformation(extent={{-10,-110},{10,-90}}),
                iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,-100})));
          ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.FixedVoltage_N sou(
            potentialReference=true,
            definiteReference=true,
            f=f,
            V=V,
            phiSou=phiSou) "Voltage source" annotation (Placement(
                transformation(extent={{10,-10},{-10,10}}, origin={10,0})));
        equation
          for i in 1:3 loop
            P[i].real = -sou.vPhase[i].S[1];
            P[i].apparent = sqrt(sou.vPhase[i].S[2]^2 + sou.vPhase[i].S[1]^2);
            P[i].phi = sou.vPhase[i].phi;
            P[i].cosPhi = cos(sou.vPhase[i].phi);
          end for;
          connect(sou.terminal, terminal) annotation (Line(
              points={{-4.44089e-16,6.66134e-16},{-4.44089e-16,-100},{4.44089e-16,-100}},
              color={127,0,127},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="gri",
            Documentation(info="<html>
<p>
Model that can be used to represent the electrical grid supply with a neutral cable connection.
The neutral cable is connected to the ground.
</p>
<p>
The model has an output connector named <code>P[n]</code> with <code>n = 3</code> that
contains information about the power supplied by the grid to the network.
The convention is that <code>P[i].real</code> is positive if real power is
consumed from the grid, and negative if it is fed into the grid.
The connector has size equal to three because each element
of the vector refers to a single phase.
</p>
<p>
The parameter <code>V</code> is the root means square of the voltage.
In US, a typical value <i>480</i> Volts.
</p>
</html>",revisions="<html>
<ul>
<li>
August 31, 2016, by Michael Wetter:<br/>
Corrected sign error in documentation string of variable <code>P</code>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={2,2}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-120,130},{120,100}},
                  textColor={0,120,120},
                  textString="%name"),
                Line(
                  points={{-60,-32},{-60,-72}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-74,-32},{-44,-32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-72,-38},{-48,-28},{-28,-16},{-16,-2},{-12,14}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-46,-38},{-22,-28},{-2,-16},{10,-2},{14,14}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-72,-32},{-72,-38}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-46,-32},{-46,-38}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-14,20},{16,20}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,20},{0,-20}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-12,20},{-12,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{14,20},{14,14}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{14,14},{38,24},{58,36},{70,50},{74,66}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-12,14},{12,24},{32,36},{44,50},{48,66}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{60,72},{60,32}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{46,72},{76,72}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{48,72},{48,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{74,72},{74,66}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-100,-76},{-96,-74},{-88,-68},{-76,-54},{-72,-38}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-100,-88},{-82,-80},{-62,-68},{-50,-54},{-46,-38}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{48,68},{72,78},{92,90},{98,94},{100,96}},
                  color={175,175,175},
                  smooth=Smooth.Bezier),
                Line(
                  points={{74,68},{84,72},{100,82}},
                  color={175,175,175},
                  smooth=Smooth.Bezier)}));
        end Grid_N;

        model PVsimple "Simple PV source without neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.UnbalancedPV(
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase1,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase2,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase3);

          Modelica.Blocks.Interfaces.RealInput G(unit="W/m2")
            "Total solar irradiation per unit area"
             annotation (Placement(transformation(
                origin={0,110},
                extent={{-20,-20},{20,20}},
                rotation=270), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,110})));
        equation
          connect(G, G_int) annotation (Line(
              points={{0,110},{0,94},{0,94},{0,88},{-94,88},{-94,20},{-80,20}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="pv",
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Simple PV model for three-phase unbalanced systems without neutral cable connection.
</p>
<p>
For more information, see
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimple\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimple</a>.
</p>
</html>"));
        end PVsimple;

        model PVsimpleOriented
          "Simple PV source with orientation and without neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.UnbalancedPV(
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase1,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase2,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase3);

          parameter Modelica.Units.SI.Angle til "Surface tilt"
            annotation (Dialog(group="Orientation"));
          parameter Modelica.Units.SI.Angle azi "Surface Azimith"
            annotation (Dialog(group="Orientation"));
          Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(final til
              =til, final azi=azi) "Diffuse irradiation on tilted surface"
            annotation (Placement(transformation(extent={{20,-80},{0,-60}})));
          Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(final til
              =til, final azi=azi) "Direct irradiation on tilted surface"
            annotation (Placement(transformation(extent={{60,-99},{40,-79}})));
          Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-76,-70})));
          Buildings.BoundaryConditions.WeatherData.Bus weaBus
            "Bus with weather data" annotation (Placement(transformation(extent
                  ={{76,-62},{96,-42}}), iconTransformation(extent={{-10,80},{
                    10,100}})));
        equation
          connect(HDifTil.weaBus,weaBus)  annotation (Line(
              points={{20,-70},{72,-70},{72,-52},{86,-52}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus,HDirTil. weaBus) annotation (Line(
              points={{86,-52},{72,-52},{72,-89},{60,-89}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(HDifTil.H, G.u2) annotation (Line(
              points={{-1,-70},{-52,-70},{-52,-64},{-64,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(G.y, G_int) annotation (Line(
              points={{-87,-70},{-94,-70},{-94,20},{-80,20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil.H, G.u1) annotation (Line(
              points={{39,-89},{-60,-89},{-60,-76},{-64,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="pv",
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Simple PV model with orientation for three-phase unbalanced systems
without neutral cable connection.
</p>
<p>
For more information, see
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented</a>.
</p>
</html>"));
        end PVsimpleOriented;

        model PVsimpleOriented_N "Simple PV source with orientation and neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.UnbalancedPV_N(
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase1,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase2,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase3);

          parameter Modelica.Units.SI.Angle til "Surface tilt"
            annotation (Dialog(group="Orientation"));
          parameter Modelica.Units.SI.Angle azi "Surface Azimith"
            annotation (Dialog(group="Orientation"));
          Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(final til
              =til, final azi=azi) "Diffuse irradiation on tilted surface"
            annotation (Placement(transformation(extent={{20,-80},{0,-60}})));
          Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(final til
              =til, final azi=azi) "Direct irradiation on tilted surface"
            annotation (Placement(transformation(extent={{60,-99},{40,-79}})));
          Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=180,
                origin={-76,-70})));
          Buildings.BoundaryConditions.WeatherData.Bus weaBus
            "Bus with weather data" annotation (Placement(transformation(extent
                  ={{76,-62},{96,-42}}), iconTransformation(extent={{-10,80},{
                    10,100}})));
        equation
          connect(HDifTil.weaBus,weaBus)  annotation (Line(
              points={{20,-70},{72,-70},{72,-52},{86,-52}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus,HDirTil. weaBus) annotation (Line(
              points={{86,-52},{72,-52},{72,-89},{60,-89}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(HDifTil.H, G.u2) annotation (Line(
              points={{-1,-70},{-52,-70},{-52,-64},{-64,-64}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(G.y, G_int) annotation (Line(
              points={{-87,-70},{-94,-70},{-94,20},{-80,20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil.H, G.u1) annotation (Line(
              points={{39,-89},{-60,-89},{-60,-76},{-64,-76}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="pv",
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Simple PV model with orientation for three-phase unbalanced systems
with neutral cable connection.
</p>
<p>
For more information, see
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimpleOriented</a>.
</p>
</html>"));
        end PVsimpleOriented_N;

        model PVsimple_N "Simple PV source with neutral cable"
          extends
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.UnbalancedPV_N(
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase1,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase2,
            redeclare ProsNet.Electrical.AC.OnePhase.Sources.PVSimple pv_phase3);

          Modelica.Blocks.Interfaces.RealInput G(unit="W/m2")
            "Total solar irradiation per unit area"
             annotation (Placement(transformation(
                origin={0,110},
                extent={{-20,-20},{20,20}},
                rotation=270), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,110})));
        equation
          connect(G, G_int) annotation (Line(
              points={{0,110},{0,94},{0,94},{0,88},{-94,88},{-94,20},{-80,20}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
          defaultComponentName="pv",
            Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
October 7, 2019, by Michael Wetter:<br/>
Corrected model to include DC/AC conversion in output <code>P</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Simple PV model for three-phase unbalanced systems with neutral cable connection.
</p>
<p>
For more information, see
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.PVSimple\">
Buildings.Electrical.AC.OnePhase.Sources.PVSimple</a>.
</p>
</html>"));
        end PVsimple_N;

        model WindTurbine "Simple wind turbine source without neutral cable"
          extends BaseClasses.UnbalancedWindTurbine(
          redeclare ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine wt_phase1,
          redeclare ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine wt_phase2,
          redeclare ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine wt_phase3);
          annotation (
          defaultComponentName="winTur",
         Documentation(revisions="<html>
<ul>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Simple wind turbine model for three-phase unbalanced systems
without neutral cable connection.
</p>
<p>
For more information, see
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.WindTurbine\">
Buildings.Electrical.AC.OnePhase.Sources.WindTurbine</a>.
</p>
</html>"));
        end WindTurbine;

        model WindTurbine_N "Simple wind turbine source with neutral cable"
          extends BaseClasses.UnbalancedWindTurbine_N(
          redeclare ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine wt_phase1,
          redeclare ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine wt_phase2,
          redeclare ProsNet.Electrical.AC.OnePhase.Sources.WindTurbine wt_phase3);
          annotation (
          defaultComponentName="winTur",
         Documentation(revisions="<html>
<ul>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Simple wind turbine model for three-phase unbalanced systems
with neutral cable connection.
</p>
<p>
For more information, see
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Sources.WindTurbine\">
Buildings.Electrical.AC.OnePhase.Sources.WindTurbine</a>.
</p>
</html>"));
        end WindTurbine_N;

        package Examples "Package with example models"
          extends Modelica.Icons.ExamplesPackage;

          model FixedVoltageSource
            "This example illustrates how using a fixed voltage source"
            extends Modelica.Icons.Example;
            FixedVoltage                             grid(
              f=60,
              V=480,
              definiteReference=true,
              phiSou=0.17453292519943) "AC one phase electrical grid"
              annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
            Sensors.ProbeWye                  sen(V_nominal=480)
              "Probe that measures the voltage at the load"
              annotation (Placement(transformation(extent={{-10,60},{10,80}})));
            Loads.Inductive loa(P_nominal=-2000, V_nominal=480) "Inductive load"
              annotation (Placement(transformation(extent={{20,30},{40,50}})));
            FixedVoltage_N grid_N(
              f=60,
              V=480,
              definiteReference=true,
              phiSou=0.17453292519943) "AC one phase electrical grid"
              annotation (Placement(transformation(extent={{-40,-70},{-20,-50}})));
            Sensors.ProbeWye_N sen_N(V_nominal=480)
              "Probe that measures the voltage at the load"
              annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
            Loads.Inductive_N loa_N(P_nominal=-2000, V_nominal=480) "Inductive load"
              annotation (Placement(transformation(extent={{20,-70},{40,-50}})));
          equation
            connect(grid.terminal, loa.terminal) annotation (Line(
                points={{-20,40},{20,40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, sen.term) annotation (Line(
                points={{-20,40},{0,40},{0,61}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid_N.terminal, loa_N.terminal) annotation (Line(
                points={{-20,-60},{20,-60}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(grid_N.terminal, sen_N.term) annotation (Line(
                points={{-20,-60},{0,-60},{0,-39}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=1.0, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Sources/Examples/FixedVoltageSource.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a fixed voltage generator model.
</p>
</html>"));
          end FixedVoltageSource;

          model PVPanels "This example illustrates how to use PV panel models"
            extends Modelica.Icons.Example;
            ThreePhasesUnbalanced.Loads.Inductive RL(
              mode=Types.Load.VariableZ_y_input,
              P_nominal=-2000,
              V_nominal=480,
              plugPhase3=false) "Load taht consumes the power generted by the PVs"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
            ThreePhasesUnbalanced.Sources.Grid grid(f=60, V=480) "Electrical grid model"
                     annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Sources.Constant  load(k=0.5) "Load consumption"
              annotation (Placement(transformation(extent={{78,-50},{58,-30}})));
            Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Diffuse irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,72},{-32,92}})));
            Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Direct irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,32},{-32,52}})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false, filNam=
                  Modelica.Utilities.Files.loadResource(
                  "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              annotation (Placement(transformation(extent={{-100,72},{-80,92}})));
            Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
              annotation (Placement(transformation(extent={{-12,52},{8,72}})));
            PVsimple pvSimple(
              V_nominal=480,
              A=100,
              areaFraction={0.5,0.3,0.2}) "PV array simplified"
              annotation (Placement(transformation(extent={{60,0},{40,20}})));
            PVsimpleOriented pvOriented(
              V_nominal=480,
              A=100,
              til=0.34906585039887,
              azi=-0.78539816339745,
              areaFraction={0.5,0.3,0.2}) "PV array oriented"
              annotation (Placement(transformation(extent={{10,0},{-10,20}})));
          equation
            connect(weaDat.weaBus,HDifTil. weaBus) annotation (Line(
                points={{-80,82},{-52,82}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaDat.weaBus,HDirTil. weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,42},{-52,42}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(HDifTil.H,G. u1) annotation (Line(
                points={{-31,82},{-24,82},{-24,68},{-14,68}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(HDirTil.H,G. u2) annotation (Line(
                points={{-31,42},{-24,42},{-24,56},{-14,56}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(G.y,pvSimple. G) annotation (Line(
                points={{9,62},{50,62},{50,21}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(weaDat.weaBus, pvOriented.weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,26},{4.44089e-16,26},{4.44089e-16,19}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(load.y, RL.y2) annotation (Line(
                points={{57,-40},{50,-40},{50,-40},{42,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.y, RL.y1) annotation (Line(
                points={{57,-40},{50,-40},{50,-32},{42,-32}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(grid.terminal, RL.terminal) annotation (Line(
                points={{-50,-20},{-50,-40},{20,-40}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, pvOriented.terminal) annotation (Line(
                points={{-50,-20},{-50,-40},{-18,-40},{-18,10},{-10,10}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(grid.terminal, pvSimple.terminal) annotation (Line(
                points={{-50,-20},{-50,-40},{14,-40},{14,10},{40,10}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=172800, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Sources/Examples/PVPanels.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed assignment of parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a simple PV model without orientation
as well as a PV model with orientation. The power produced by the PV is
partially consumed by the load, and the remaining part is fed into
the grid.
</p>
<p>
The PV produces different amounts of power on each phase according to the fractions
specified by the vector <code>areaFraction={0.5,0.3,0.2}</code>. In this example, 50%
of the power generation is on phase 1, 30% on phase 2 and 20% on phase 3.
</p>
</html>"));
          end PVPanels;

          model PVPanels_N
            "This example illustrates how to use PV panel models with neutral cable"
            extends Modelica.Icons.Example;
            ThreePhasesUnbalanced.Loads.Inductive_N                                             RL(
              mode=Types.Load.VariableZ_y_input,
              P_nominal=-2000,
              V_nominal=480,
              plugPhase3=false) "Load taht consumes the power generted by the PVs"
              annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
            ThreePhasesUnbalanced.Sources.Grid_N grid(f=60, V=480)
              "Electrical grid model"
                     annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Sources.Constant  load(k=0.5) "Load consumption"
              annotation (Placement(transformation(extent={{78,-50},{58,-30}})));
            Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Diffuse irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,72},{-32,92}})));
            Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(til=
                  0.34906585039887, azi=-0.78539816339745)
              "Direct irradiation on tilted surface" annotation (Placement(
                  transformation(extent={{-52,32},{-32,52}})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false, filNam=
                  Modelica.Utilities.Files.loadResource(
                  "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              annotation (Placement(transformation(extent={{-100,72},{-80,92}})));
            Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
              annotation (Placement(transformation(extent={{-12,52},{8,72}})));
            PVsimple_N                               pvSimple(      V_nominal=480,
              A=100,
              plugPhase2=false,
              areaFraction={0.4,0.0,0.6}) "PV array simplified"
              annotation (Placement(transformation(extent={{60,0},{40,20}})));
            PVsimpleOriented_N                               pvOriented(
              V_nominal=480,
              A=100,
              plugPhase2=false,
              til=0.34906585039887,
              azi=-0.78539816339745,
              areaFraction={0.4,0.0,0.6}) "PV array oriented"
              annotation (Placement(transformation(extent={{10,0},{-10,20}})));
          equation
            connect(weaDat.weaBus,HDifTil. weaBus) annotation (Line(
                points={{-80,82},{-52,82}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaDat.weaBus,HDirTil. weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,42},{-52,42}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(HDifTil.H,G. u1) annotation (Line(
                points={{-31,82},{-24,82},{-24,68},{-14,68}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(HDirTil.H,G. u2) annotation (Line(
                points={{-31,42},{-24,42},{-24,56},{-14,56}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(G.y,pvSimple. G) annotation (Line(
                points={{9,62},{50,62},{50,21}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(weaDat.weaBus, pvOriented.weaBus) annotation (Line(
                points={{-80,82},{-66,82},{-66,26},{4.44089e-16,26},{4.44089e-16,19}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(load.y, RL.y2) annotation (Line(
                points={{57,-40},{50,-40},{50,-40},{42,-40}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(load.y, RL.y1) annotation (Line(
                points={{57,-40},{50,-40},{50,-32},{42,-32}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(grid.terminal, RL.terminal) annotation (Line(
                points={{-50,-20},{-50,-40},{20,-40}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(grid.terminal, pvOriented.terminal) annotation (Line(
                points={{-50,-20},{-50,-40},{-20,-40},{-20,10},{-10,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(grid.terminal, pvSimple.terminal) annotation (Line(
                points={{-50,-20},{-50,-40},{14,-40},{14,10},{40,10}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (experiment(StopTime=172800, Tolerance=1e-6),
              __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Sources/Examples/PVPanels_N.mos"
                  "Simulate and plot"),
              Documentation(revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed assignment of parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
January 10, 2015, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>",           info="<html>
<p>
This example shows how to use a simple PV model with neutral cable connection and without orientation
as well as a PV model with orientation. The power produced by the PV is
partially consumed by the load, and the remaining part is fed into
the grid.
</p>
<p>
The PV produces different amounts of power on each phase according to the fractions
specified by the vector <code>areaFraction={0.4,0.0,0.6}</code>. In this example, 40%
of the power generation is on phase 1, 0% on phase 2 (disconnected) and 60% on phase 3.
</p>
</html>"));
          end PVPanels_N;

          model WindTurbine "Example for the WindTurbine AC model"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.WindTurbine tur(
              table=[3.5,0; 5.5,100; 12,900; 14,1000; 25,1000],
              h=10,
              scale=10,
              V_nominal=480,
              scaleFraction={0.5,0.25,0.25}) "Wind turbine" annotation (
                Placement(transformation(extent={{10,-10},{-10,10}}, origin={60,
                      0})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false,
                filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              "Weather data"
              annotation (Placement(transformation(extent={{-52,36},{-32,56}})));
            Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather bus";
            Loads.Resistive                           res(P_nominal=-500, V_nominal=480)
              "Resistive line"
              annotation (Placement(transformation(extent={{-22,-30},{-2,-10}})));
            Grid                                                     sou(f=60, V=480)
              "Voltage source"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            Sensors.GeneralizedSensor                         sen "Generalized sensor"
              annotation (Placement(transformation(extent={{8,-10},{28,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Lines.Line line(
              l=200,
              P_nominal=5000,
              V_nominal=480) annotation (Placement(transformation(extent={{-40,
                      -10},{-20,10}})));
          equation
            connect(weaDat.weaBus,weaBus)  annotation (Line(
                points={{-32,46},{26,46}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaBus.winSpe,tur. vWin) annotation (Line(
                points={{26,46},{60,46},{60,12}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(sou.terminal, res.terminal) annotation (Line(
                points={{-70,10},{-70,-20},{-22,-20}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sen.terminal_p, tur.terminal) annotation (Line(
                points={{28,0},{50,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(sou.terminal, line.terminal_n) annotation (Line(
                points={{-70,10},{-70,0},{-40,5.55112e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(line.terminal_p, sen.terminal_n) annotation (Line(
                points={{-20,5.55112e-16},{8,0},{8,6.66134e-16}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=172800, Tolerance=1e-6),
              Documentation(info="<html>
<p>
This model illustrates the use of the wind turbine model,
which is connected to a AC voltage source and a resistive load.
This voltage source can represent the grid to which the
circuit is connected.
Wind data for San Francisco, CA, are used.
The turbine cut-in wind speed is <i>3.5</i> m/s,
and hence it is off in the first day when the wind speed is low.
</p>
<p>
The wind turbines produce different amounts of power on each phase according to the fractions
specified by the vector <code>scaleFraction={0.5,0.25,0.25}</code>. In this example, 50%
of the power generation is on phase 1, 30% on phase 2 and 20% on phase 3.
As expected the phase with the higher power production has the higher voltage deviation
from the nominal condition.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Created model and documentation
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Sources/Examples/WindTurbine.mos"
                  "Simulate and plot"));
          end WindTurbine;

          model WindTurbine_N "Example for the WindTurbine AC model with neutral cable"
            extends Modelica.Icons.Example;
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.WindTurbine_N tur(
              table=[3.5,0; 5.5,100; 12,900; 14,1000; 25,1000],
              h=10,
              scale=10,
              V_nominal=480,
              plugPhase2=false,
              scaleFraction={0.4,0.0,0.6}) "Wind turbine" annotation (Placement(
                  transformation(extent={{10,-10},{-10,10}}, origin={60,0})));
            Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
                computeWetBulbTemperature=false,
                filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
              "Weather data"
              annotation (Placement(transformation(extent={{-52,36},{-32,56}})));
            Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather bus";
            Loads.Resistive_N                          res(P_nominal=-500, V_nominal=480)
              "Resistive line"
              annotation (Placement(transformation(extent={{-22,-30},{-2,-10}})));
            Grid_N                                                     sou(f=60, V=480)
              "Voltage source"
              annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
            Sensors.GeneralizedSensor_N                         sen "Generalized sensor"
              annotation (Placement(transformation(extent={{8,-10},{28,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Lines.Line_N line(
              l=200,
              P_nominal=5000,
              V_nominal=480) annotation (Placement(transformation(extent={{-40,
                      -10},{-20,10}})));
          equation
            connect(weaDat.weaBus,weaBus)  annotation (Line(
                points={{-32,46},{26,46}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(weaBus.winSpe,tur. vWin) annotation (Line(
                points={{26,46},{60,46},{60,12}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(tur.terminal, sen.terminal_p) annotation (Line(
                points={{50,0},{28,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(sen.terminal_n, line.terminal_p) annotation (Line(
                points={{8,0},{-20,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(line.terminal_n, sou.terminal) annotation (Line(
                points={{-40,0},{-70,0},{-70,10}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(res.terminal, sou.terminal) annotation (Line(
                points={{-22,-20},{-70,-20},{-70,10}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation (    experiment(StopTime=172800, Tolerance=1e-6),
              Documentation(info="<html>
<p>
This model illustrates the use of the wind turbine model with neutral cable,
which is connected to a AC voltage source and a resistive load.
This voltage source can represent the grid to which the
circuit is connected.
Wind data for San Francisco, CA, are used.
The turbine cut-in wind speed is <i>3.5</i> m/s,
and hence it is off in the first day when the wind speed is low.
</p>
<p>
The wind turbines produce different amounts of power on each phase according to the fractions
specified by the vector <code>scaleFraction={0.4,0.0,0.6}</code>. In this example, 40%
of the power generation is on phase 1, 0% on phase 2 (disconnected) and 60% on phase 3.
As expected the phase with the higher power production has the higher voltage deviation
from the nominal condition.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 10, 2014, by Marco Bonvini:<br/>
Created model and documentation
</li>
</ul>
</html>"),    __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Sources/Examples/WindTurbine_N.mos"
                  "Simulate and plot"));
          end WindTurbine_N;
          annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Sources\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Sources</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Examples;

        package BaseClasses "Package with base class models"
          extends Modelica.Icons.BasesPackage;

          partial model BaseUnbalancedPV "Partial model for an unbalanced PV source"
            extends ProsNet.Electrical.Interfaces.PartialPluggableUnbalanced;
            extends ProsNet.Electrical.Interfaces.PartialPvBase;
            extends ProsNet.Electrical.Interfaces.PartialAcDcParameters;
            parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=480)
              "Nominal voltage (V_nominal >= 0)"
              annotation (Dialog(group="Nominal conditions"));
            parameter Real areaFraction[3](each min=0, each max=1.0) = ones(3)/3
              "Fraction of area occupied by the PVs of each phase";
            replaceable OnePhase.Sources.PVSimple pv_phase2(
              pf=pf,
              eta_DCAC=eta_DCAC,
              A=A*areaFraction[2],
              fAct=fAct,
              eta=eta,
              V_nominal=V_nominal/sqrt(3))
              if plugPhase2 "PV phase 2"
              annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));
            replaceable OnePhase.Sources.PVSimple pv_phase3(
              pf=pf,
              eta_DCAC=eta_DCAC,
              A=A*areaFraction[3],
              fAct=fAct,
              eta=eta,
              V_nominal=V_nominal/sqrt(3))
              if plugPhase3 "PV phase 3"
              annotation (Placement(transformation(extent={{-20,-60},{-40,-40}})));
            replaceable OnePhase.Sources.PVSimple pv_phase1(
              pf=pf,
              eta_DCAC=eta_DCAC,
              A=A*areaFraction[1],
              fAct=fAct,
              eta=eta,
              V_nominal=V_nominal/sqrt(3))
              if plugPhase1 "PV phase 1"
              annotation (Placement(transformation(extent={{-18,40},{-38,60}})));
            Modelica.Blocks.Math.Add3 sumBlock "Sum of the generated power on each phase"
              annotation (Placement(transformation(extent={{40,84},{60,64}})));
          protected
            Modelica.Blocks.Interfaces.RealOutput G_int
              "Total solar irradiation per unit area" annotation (Placement(
                  transformation(
                  extent={{-20,-20},{20,20}},
                  origin={-80,20}),
                                  iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={0,100})));
          equation
            assert(abs(sum(areaFraction)-1) < Modelica.Constants.eps,
            "Model that extends Buildings.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.BaseUnbalancedPV,
  has an invalid value for the vector areaFraction[:]. The sum of the
  elements has to be equal to 1.0.",
            level=AssertionLevel.error);

            if plugPhase1 then
              connect(pv_phase1.G, G_int)
                                       annotation (Line(
                  points={{-28,62},{-28,72},{-46,72},{-46,20},{-80,20}},
                  color={0,0,127},
                  smooth=Smooth.None));
            end if;

            if plugPhase2 then
              connect(G_int, pv_phase2.G)
                                       annotation (Line(
                points={{-80,20},{-30,20},{-30,12}},
                color={0,0,127},
                smooth=Smooth.None));
            end if;

            if plugPhase3 then
              connect(G_int, pv_phase3.G)
                                       annotation (Line(
                  points={{-80,20},{-46,20},{-46,-26},{-30,-26},{-30,-38}},
                  color={0,0,127},
                  smooth=Smooth.None));
            end if;

            if plugPhase1 then
              connect(pv_phase1.P, sumBlock.u1) annotation (Line(
                points={{-39,57},{-48,57},{-48,76},{10,76},{10,66},{38,66}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            else
              sumBlock.u1 = 0;
            end if;

            if plugPhase2 then
              connect(pv_phase2.P, sumBlock.u2) annotation (Line(
                points={{-41,7},{-50,7},{-50,78},{18,78},{18,74},{38,74}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            else
              sumBlock.u2 = 0;
            end if;

            if plugPhase3 then
              connect(pv_phase3.P, sumBlock.u3) annotation (Line(
                points={{-41,-43},{-52,-43},{-52,82},{38,82}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            else
              sumBlock.u3 = 0;
            end if;

            connect(sumBlock.y, P) annotation (Line(
                points={{61,74},{86,74},{86,70},{110,70}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            annotation ( Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Line(points={{58,0},{92,0}},   color={0,0,0}),
                  Text(
                    extent={{-140,-100},{160,-60}},
                    textString="%name",
                    textColor={0,0,255}),
                  Polygon(
                    points={{80,-52},{32,63},{-78,63},{-29,-52},{80,-52}},
                    smooth=Smooth.None,
                    fillColor={205,203,203},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-32,27},{-44,53},{-67,53},{-56,27},{-32,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-16,-9},{-28,17},{-51,17},{-40,-9},{-16,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-1,-45},{-13,-19},{-36,-19},{-25,-45},{-1,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{1,27},{-11,53},{-34,53},{-23,27},{1,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{17,-9},{5,17},{-18,17},{-7,-9},{17,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{32,-45},{20,-19},{-3,-19},{8,-45},{32,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{34,27},{22,53},{-1,53},{10,27},{34,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{50,-9},{38,17},{15,17},{26,-9},{50,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{65,-45},{53,-19},{30,-19},{41,-45},{65,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Documentation(info="<html>
<p>
This model is a partial class extended by three-phase unbalanced
PV power sources.
</p>
<p>
The model has boolean parameters <code>plugPhase1</code>, <code>plugPhase2</code>,
and <code>plugPhase3</code> that can be used to connect the PV in an
unbalanced configuration.
</p>
<p>
The model has an array <code>areaFraction[3]</code> that is used to determine how
to partition the power of the PVs on the three-phase. By default it is assumed
a uniform partition <code>areaFraction[3] = {1/3, 1/3, 1/3}</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end BaseUnbalancedPV;

          partial model BaseUnbalancedWindTurbine
            "Partial model for an unbalanced wind power source"
            extends ProsNet.Electrical.Interfaces.PartialPluggableUnbalanced;
            extends ProsNet.Electrical.Interfaces.PartialAcDcParameters;
            extends
              ProsNet.Electrical.BaseClasses.WindTurbine.PartialWindTurbineBase(
                V_nominal(start=480));
            parameter Real scaleFraction[3](each min=0, each max=1.0) = ones(3)/3
              "Fraction of power allocated to the wind turbines of each phase";
            replaceable OnePhase.Sources.WindTurbine wt_phase2(
              pf=pf,
              eta_DCAC=eta_DCAC,
              scale=scale*scaleFraction[2],
              h=h,
              hRef=hRef,
              nWin=nWin,
              tableOnFile=tableOnFile,
              table=table,
              tableName=tableName,
              fileName=fileName,
              V_nominal=V_nominal/sqrt(3))
                if plugPhase2 "Wind turbine phase 2"
              annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));

            replaceable OnePhase.Sources.WindTurbine wt_phase3(
              pf=pf,
              eta_DCAC=eta_DCAC,
              scale=scale*scaleFraction[3],
              h=h,
              hRef=hRef,
              nWin=nWin,
              tableOnFile=tableOnFile,
              table=table,
              tableName=tableName,
              fileName=fileName,
              V_nominal=V_nominal/sqrt(3))
                if plugPhase3 "Wind turbine phase 3"
              annotation (Placement(transformation(extent={{-20,-60},{-40,-40}})));

            replaceable OnePhase.Sources.WindTurbine wt_phase1(
              pf=pf,
              eta_DCAC=eta_DCAC,
              scale=scale*scaleFraction[1],
              h=h,
              hRef=hRef,
              nWin=nWin,
              tableOnFile=tableOnFile,
              table=table,
              tableName=tableName,
              fileName=fileName,
              V_nominal=V_nominal/sqrt(3))
                if plugPhase1 "Wind turbine phase 1"
              annotation (Placement(transformation(extent={{-18,40},{-38,60}})));
            Modelica.Blocks.Math.Add3 sumBlock "Sum of th epower generated on each phase"
              annotation (Placement(transformation(extent={{32,50},{52,70}})));
          equation

            assert(abs(sum(scaleFraction)-1) < Modelica.Constants.eps,
            "Model that extends Buildings.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.BaseUnbalancedWindTurbine,
  has an invalid value for the vector scaleFraction[:]. The sum of the
  elements has to be equal to 1.0.",
            level=AssertionLevel.error);

            if plugPhase1 then
              connect(wt_phase1.P, sumBlock.u1) annotation (Line(
                points={{-39,56},{-60,56},{-60,82},{20,82},{20,68},{30,68}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            else
              sumBlock.u1 = 0;
            end if;

            if plugPhase2 then
              connect(wt_phase2.P, sumBlock.u2) annotation (Line(
                points={{-41,6},{-64,6},{-64,86},{12,86},{12,60},{30,60}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            else
              sumBlock.u2 = 0;
            end if;

            if plugPhase3 then
              connect(wt_phase3.P, sumBlock.u3) annotation (Line(
                points={{-41,-44},{-68,-44},{-68,90},{4,90},{4,52},{30,52}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));
            else
              sumBlock.u3 = 0;
            end if;

            connect(sumBlock.y, P) annotation (Line(
                points={{53,60},{110,60}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash));

            connect(vWin, wt_phase1.vWin) annotation (Line(
                points={{0,120},{0,72},{-28,72},{-28,62}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(vWin, wt_phase2.vWin) annotation (Line(
                points={{0,120},{0,72},{-52,72},{-52,20},{-30,20},{-30,12}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(vWin, wt_phase3.vWin) annotation (Line(
                points={{0,120},{0,72},{-52,72},{-52,-26},{-30,-26},{-30,-38}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation ( Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    pattern=LinePattern.None,
                    fillColor={202,230,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{42,44},{46,-54}},
                    fillColor={233,233,233},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-42,12},{-38,-86}},
                    fillColor={233,233,233},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-44,10},{-26,-42},{-38,14},{-44,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-38,10},{8,44},{-42,16},{-38,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-42,10},{-90,38},{-38,16},{-42,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{40,42},{100,38},{42,48},{40,42}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-21,-17},{27,17},{-25,-11},{-21,-17}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    origin={29,67},
                    rotation=90,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{24,-14},{-20,22},{26,-8},{24,-14}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    origin={32,18},
                    rotation=90,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-46,18},{-34,6}},
                    lineColor={0,0,0},
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{38,50},{50,38}},
                    lineColor={0,0,0},
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
<p>
This model is a partial class extended by three-phase unbalanced
wind turbine power sources.
</p>
<p>
The model has boolean parameters <code>plugPhase1</code>, <code>plugPhase2</code>,
and <code>plugPhase3</code> that can be used to connect the wind turbines in an
unbalanced configuration.
</p>
<p>
The model has an array <code>scaleFraction[3]</code> that is used to determine how
to partition the power of the wind turbines on the three-phase. By default it is assumed
a uniform partition <code>scaleFraction[3] = {1/3, 1/3, 1/3}</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end BaseUnbalancedWindTurbine;

          partial model PartialSource
            "Partial model for a three-phase AC unbalanced voltage source without neutral cable"

            Interfaces.Connection3to3Ground_p connection3to4
              "Connection between three to four AC connectors with ground connection"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            OnePhase.Basics.Ground ground "Ground reference"
              annotation (Placement(transformation(extent={{10,-60},{30,-40}})));
            Interfaces.Terminal_p terminal "Connector for three-phase unbalanced systems"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation

            connect(connection3to4.terminal3,terminal)  annotation (Line(
                points={{60,0},{100,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(ground.terminal, connection3to4.ground4) annotation (Line(
                points={{20,-40},{20,-6},{39.6,-6}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation ( Documentation(info="<html>
<p>
This model is a partial class extended by three-phase unbalanced
voltage sources without neutral cable connection.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Created model and documentation.
</li>
</ul>
</html>"));
          end PartialSource;

          partial model PartialSource_N "Partial model for a three-phase AC unbalanced voltage source
  with neutral cable"

            OnePhase.Basics.Ground ground "Ground reference"
              annotation (Placement(transformation(extent={{10,-60},{30,-40}})));
            Interfaces.Terminal4_p terminal
              "Connector for three-phase unbalanced systems with neutral cable"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation

            connect(ground.terminal, terminal.phase[4]) annotation (Line(
                points={{20,-40},{20,0},{100,0}},
                color={127,0,127},
                smooth=Smooth.None));
            annotation ( Documentation(info="<html>
<p>
This model is a partial class extended by three-phase unbalanced
voltage sources that have a neutral cable.
</p>
<p>
The neutral cable is connected to the ground reference.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end PartialSource_N;

          model UnbalancedPV
            "Base model for an unbalanced PV source without neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.BaseUnbalancedPV;
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.PartialSource;
          protected
            Interfaces.Adapter3to3 ada "Adapter"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          equation

            if plugPhase1 then
            connect(pv_phase1.terminal, ada.terminals[1]) annotation (Line(points={{-18,50},
                      {-12,50},{-12,-0.533333},{-10,-0.533333}},
                                                               color={0,120,120}));
            end if;

            if plugPhase2 then
            connect(pv_phase2.terminal, ada.terminals[2])
              annotation (Line(points={{-20,0},{-15,0},{-10,0}}, color={0,120,120}));
            end if;

            if plugPhase3 then
             connect(pv_phase3.terminal, ada.terminals[3]) annotation (Line(points={{-20,-50},
                      {-16,-50},{-16,0.533333},{-10,0.533333}},
                                                              color={0,120,120}));
            end if;

            connect(ada.terminal, connection3to4.terminal4)
              annotation (Line(points={{10,0},{26,0},{40,0}}, color={0,120,120}));
            annotation ( Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Line(points={{58,0},{92,0}},   color={0,0,0}),
                  Text(
                    extent={{-140,-100},{160,-60}},
                    textString="%name",
                    textColor={0,0,255}),
                  Polygon(
                    points={{80,-52},{32,63},{-78,63},{-29,-52},{80,-52}},
                    smooth=Smooth.None,
                    fillColor={205,203,203},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-32,27},{-44,53},{-67,53},{-56,27},{-32,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-16,-9},{-28,17},{-51,17},{-40,-9},{-16,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-1,-45},{-13,-19},{-36,-19},{-25,-45},{-1,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{1,27},{-11,53},{-34,53},{-23,27},{1,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{17,-9},{5,17},{-18,17},{-7,-9},{17,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{32,-45},{20,-19},{-3,-19},{8,-45},{32,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{34,27},{22,53},{-1,53},{10,27},{34,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{50,-9},{38,17},{15,17},{26,-9},{50,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{65,-45},{53,-19},{30,-19},{41,-45},{65,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Documentation(info="<html>
<p>
This model is a class extended by three-phase unbalanced
PV power sources without neutral cable.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end UnbalancedPV;

          model UnbalancedPV_N
            "Base model for an unbalanced PV source with neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.BaseUnbalancedPV;
            Interfaces.Terminal4_p terminal
              "Connector for three-phase unbalanced systems with neutral cable"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Interfaces.Connection3to4_p conn3to4 "Connection between 3 to 4 wire"
              annotation (Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  origin={40,0})));
          protected
            Interfaces.Adapter3to3 ada "Adapter"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
          equation

            if plugPhase1 then
              connect(pv_phase1.terminal, ada.terminals[1]) annotation (Line(points={{-18,50},
                      {-8,50},{-8,-0.533333},{0,-0.533333}},
                                                           color={0,120,120}));
            end if;

            if plugPhase2 then
              connect(pv_phase2.terminal, ada.terminals[2])
              annotation (Line(points={{-20,0},{-10,0},{0,0}}, color={0,120,120}));
            end if;

            if plugPhase3 then
              connect(pv_phase3.terminal, ada.terminals[3]) annotation (Line(points={{-20,-50},
                      {-8,-50},{-8,0.533333},{0,0.533333}},
                                                          color={0,120,120}));
            end if;

            connect(conn3to4.terminal4, terminal) annotation (Line(
                points={{50,0},{100,0}},
                color={127,0,127},
                smooth=Smooth.None));

            connect(ada.terminal, conn3to4.terminal3)
              annotation (Line(points={{20,0},{25,0},{30,0}}, color={0,120,120}));
            annotation ( Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Line(points={{58,0},{92,0}},   color={0,0,0}),
                  Text(
                    extent={{-140,-100},{160,-60}},
                    textString="%name",
                    textColor={0,0,255}),
                  Polygon(
                    points={{80,-52},{32,63},{-78,63},{-29,-52},{80,-52}},
                    smooth=Smooth.None,
                    fillColor={205,203,203},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-32,27},{-44,53},{-67,53},{-56,27},{-32,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-16,-9},{-28,17},{-51,17},{-40,-9},{-16,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-1,-45},{-13,-19},{-36,-19},{-25,-45},{-1,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{1,27},{-11,53},{-34,53},{-23,27},{1,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{17,-9},{5,17},{-18,17},{-7,-9},{17,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{32,-45},{20,-19},{-3,-19},{8,-45},{32,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{34,27},{22,53},{-1,53},{10,27},{34,27}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{50,-9},{38,17},{15,17},{26,-9},{50,-9}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{65,-45},{53,-19},{30,-19},{41,-45},{65,-45}},
                    smooth=Smooth.None,
                    fillColor={6,13,150},
                    fillPattern=FillPattern.Solid,
                    pattern=LinePattern.None)}),
              Documentation(info="<html>
<p>
This model is a class extended by three-phase unbalanced
PV power sources with neutral cable connection.
</p>
<p>
The neutral cable is connected to the ground reference.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end UnbalancedPV_N;

          model UnbalancedWindTurbine
            "Base model for an unbalanced wind power source without neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.BaseUnbalancedWindTurbine;
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.PartialSource;
          protected
            Interfaces.Adapter3to3 ada "Adapter"
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          equation
            if plugPhase1 then
              connect(wt_phase1.terminal, ada.terminals[1]) annotation (Line(points={{-18,50},
                      {-12,50},{-12,-0.533333},{-10,-0.533333}},
                                                               color={0,120,120}));  end if;

            if plugPhase2 then
              connect(wt_phase2.terminal, ada.terminals[2])
              annotation (Line(points={{-20,0},{-15,0},{-10,0}}, color={0,120,120}));
             end if;

            if plugPhase3 then
             connect(wt_phase3.terminal, ada.terminals[3]) annotation (Line(points={{-20,-50},
                      {-14,-50},{-14,-30},{-14,0.533333},{-10,0.533333}},
                                                                        color={0,120,120}));
            end if;
            connect(ada.terminal, connection3to4.terminal4)
              annotation (Line(points={{10,0},{26,0},{40,0}}, color={0,120,120}));
            annotation ( Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    pattern=LinePattern.None,
                    fillColor={202,230,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{42,44},{46,-54}},
                    fillColor={233,233,233},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-42,12},{-38,-86}},
                    fillColor={233,233,233},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-44,10},{-26,-42},{-38,14},{-44,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-38,10},{8,44},{-42,16},{-38,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-42,10},{-90,38},{-38,16},{-42,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{40,42},{100,38},{42,48},{40,42}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-21,-17},{27,17},{-25,-11},{-21,-17}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    origin={29,67},
                    rotation=90,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{24,-14},{-20,22},{26,-8},{24,-14}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    origin={32,18},
                    rotation=90,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-46,18},{-34,6}},
                    lineColor={0,0,0},
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{38,50},{50,38}},
                    lineColor={0,0,0},
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
<p>
This model is a class extended by three-phase unbalanced
wind turbine power sources without neutral cable.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end UnbalancedWindTurbine;

          model UnbalancedWindTurbine_N
            "Base model for an unbalanced wind power source with neutral cable"
            extends
              ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.BaseClasses.BaseUnbalancedWindTurbine;
            Interfaces.Terminal4_p terminal
              "Connector for three-phase unbalanced systems with neutral cable"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Interfaces.Connection3to4_p conn3to4 "Connection between 3 to 4 wire"
              annotation (Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  origin={40,0})));
          protected
            Interfaces.Adapter3to3 ada "Adapter"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
          equation

            if plugPhase1 then
              connect(wt_phase1.terminal, ada.terminals[1]) annotation (Line(points={{-18,50},
                      {-10,50},{-10,-0.533333},{0,-0.533333}},
                                                             color={0,120,120}));
            end if;

            if plugPhase2 then
              connect(wt_phase2.terminal, ada.terminals[2])
              annotation (Line(points={{-20,0},{-10,0},{0,0}}, color={0,120,120}));
            end if;

            if plugPhase3 then
              connect(wt_phase3.terminal, ada.terminals[3]) annotation (Line(points={{-20,-50},
                      {-10,-50},{-10,0.533333},{0,0.533333}},
                                                            color={0,120,120}));
            end if;

            connect(conn3to4.terminal4, terminal) annotation (Line(
                points={{50,0},{100,0}},
                color={127,0,127},
                smooth=Smooth.None));
            connect(ada.terminal, conn3to4.terminal3)
              annotation (Line(points={{20,0},{25,0},{30,0}}, color={0,120,120}));
            annotation ( Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    pattern=LinePattern.None,
                    fillColor={202,230,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{42,44},{46,-54}},
                    fillColor={233,233,233},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{-42,12},{-38,-86}},
                    fillColor={233,233,233},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-44,10},{-26,-42},{-38,14},{-44,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-38,10},{8,44},{-42,16},{-38,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-42,10},{-90,38},{-38,16},{-42,10}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{40,42},{100,38},{42,48},{40,42}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{-21,-17},{27,17},{-25,-11},{-21,-17}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    origin={29,67},
                    rotation=90,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{24,-14},{-20,22},{26,-8},{24,-14}},
                    smooth=Smooth.None,
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid,
                    origin={32,18},
                    rotation=90,
                    lineColor={0,0,0}),
                  Ellipse(
                    extent={{-46,18},{-34,6}},
                    lineColor={0,0,0},
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{38,50},{50,38}},
                    lineColor={0,0,0},
                    fillColor={222,222,222},
                    fillPattern=FillPattern.Solid)}),
              Documentation(info="<html>
<p>
This model is a class extended by three-phase unbalanced
wind turbine power sources with neutral cable connection.
</p>
<p>
The neutral cable is connected to the ground reference.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Added adapter for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
September 25, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end UnbalancedWindTurbine_N;
          annotation (Documentation(info="<html>
<p>
This package contains base classes used by the models that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Sources\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Sources</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end BaseClasses;
      annotation (Documentation(revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",       info="<html>
<p>
This package contains models that represent different types of three
phases unbalanced AC sources.
</p>
</html>"));
      end Sources;

      package Validation "Package with validation examples and tests for the AC three-phase unbalanced models"
        extends Modelica.Icons.ExamplesPackage;

        package IEEETests "This package contains models of the IEEE tests for feeders"
        extends Modelica.Icons.ExamplesPackage;

          package Test4NodesFeeder "This package contains models for the IEEE 4 nodes test feeder"
          extends Modelica.Icons.ExamplesPackage;

            package BalancedStepDown "Package that contains the examples for balanced loads and step down transformer"
              extends Modelica.Icons.ExamplesPackage;

              model DD
                "IEEE 4 node test feeder model with balanced load and D - D connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={12339,12349,12321},
                  final V3_ref={3911,3914,3905},
                  final V4_ref={3442,3497,3384},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.7,-90.4,
                      149.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{26.5,-93.6,
                      146.4},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{22.3,-99.4,
                      140.7},
                  loadRL(use_pf_in=false, loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta));
                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepDown/DD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>D-D transformer</li>
</ul>
</html>"));
              end DD;

              model DY
                "IEEE 4 node test feeder model with balanced load and D - Y connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={12340,12349,12318},
                  final V3_ref={2249,2263,2259},
                  final V4_ref={1920,2054,1986},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.7,-90.4,
                      149.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-33.7,-153.4,
                      86.4},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-39.1,-158.3,
                      80.9},
                  loadRL(use_pf_in=false, load1(v(start={1500,1200}))));
                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownDY
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepDown/DY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
April 7, 2021, by Michael Wetter:<br/>
Set start values
<code>loadRL(load1(v(start = {1500, 1200})))</code>
as the model seems to have more than one solution.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2432\">#2432</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>D-Y transformer</li>
</ul>
</html>"));
              end DY;

              model YD
                "IEEE 4 node test feeder model with balanced load and Y - D connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={7113,7132,7123},
                  final V3_ref={3906,3915,3909},
                  final V4_ref={3437,3497,3388},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.3,-120.3,
                      119.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-3.5,-123.6,
                      116.3},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-7.8,-129.3,
                      110.6},
                  loadRL(use_pf_in=false, loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta));
                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownYD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase,
                  conv1(terminal_p(i(start={-477,327})), V1(start={7000,-400})))
                  annotation (Placement(transformation(extent={{-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-40,10},{-40,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepDown/YD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set start values for Dymola 2017FD01.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>Y-D transformer</li>
</ul>
</html>"));
              end YD;

              model YY
                "IEEE 4 node test feeder model with balanced load and Y - Y connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={7107,7140,7121},
                  final V3_ref={2247,2269,2256},
                  final V4_ref={1918,2061,1981},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.3,-120.3,
                      119.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-3.7,-123.5,
                      116.4},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-9.1,-128.3,
                      110.9},
                  loadRL(use_pf_in=false));

                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-28,0},{-8,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-28,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-8,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-28,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepDown/YY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>Y-Y transformer</li>
</ul>
</html>"));
              end YY;
            annotation (Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",             info="<html>
<p>
This package contains examples for the IEEE 4 nodes test validation
whith balanced load and step down in the voltage of the transformers.
</p>
</html>"));
            end BalancedStepDown;

            package BalancedStepUp "Package that contains the examples for balanced loads and step up transformer"
              extends Modelica.Icons.ExamplesPackage;

              model DD
                "IEEE 4 node test feeder model with balanced load and D - D connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={12361,12372,12348},
                  final V3_ref={23723,23746,23698},
                  final V4_ref={23657,23688,23625},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.7,-90.4,
                      149.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{26.7,-93.4,
                      146.6},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{26.6,-93.6,
                      146.5},
                  loadRL(use_pf_in=false, loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta));
                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepUp/DD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>D-D transformer</li>
</ul>
</html>"));
              end DD;

              model DY
                "IEEE 4 node test feeder model with balanced load and D - Y connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={12361,12372,12348},
                  final V3_ref={13697,13710,13681},
                  final V4_ref={13653,13678,13644},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.7,-90.4,
                      149.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{26.7,-93.4,
                      146.6},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{26.6,-93.5,
                      146.5},
                  loadRL(use_pf_in=false));
                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpDY
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase,
                  conv1(V1(start={11E3,6E3})),
                  conv2(V1(start={-700,-11E3}))) annotation (Placement(
                      transformation(extent={{-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepUp/DY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 9, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>D-Y transformer</li>
</ul>
</html>"));
              end DY;

              model YD
                "IEEE 4 node test feeder model with balanced load and Y - D connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={7128,7145,7137},
                  final V3_ref={23746,23722,23698},
                  final V4_ref={23680,23663,23625},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.3,-120.3,
                      119.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{56.7,-63.4,
                      176.7},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{56.6,-63.6,
                      176.5},
                  loadRL(
                    use_pf_in=false,
                    loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta,
                    load1(v(start={13000,20000}))));

                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpYD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepUp/YD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
April 7, 2021, by Michael Wetter:<br/>
Set better start values
<code>loadRL(load1(v(start = {13000, 20000})))</code>
because for one component, the start value is far from a solution
and if specified, Dymola 2022 beta3 fails to initialize the model.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2432\">#2432</a>.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start value for <code>loadRL(load1(v(each start = 15000)))</code> which
is needed for Dymola 2017 to find the correct solution.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>Y-D transformer</li>
</ul>
</html>"));
              end YD;

              model YY
                "IEEE 4 node test feeder model with balanced load and Y - Y connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={7126,7145,7137},
                  final V3_ref={13675,13715,13698},
                  final V4_ref={13631,13682,13661},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.3,-120.4,
                      119.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-3.3,-123.4,
                      116.6},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-3.5,-123.5,
                      116.5},
                  loadRL(use_pf_in=false));
                Modelica.Blocks.Sources.Constant load(k=-1800e3)
                  annotation (Placement(transformation(extent={{54,62},{74,82}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
              equation
                connect(load.y, loadRL.Pow1) annotation (Line(
                    points={{75,72},{90,72},{90,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow2) annotation (Line(
                    points={{75,72},{90,72},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load.y, loadRL.Pow3) annotation (Line(
                    points={{75,72},{90,72},{90,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, source.terminal) annotation (Line(
                    points={{-74,29},{-74,30},{-74,30},{-74,10},{-74,10},{-78,10},{-78,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/BalancedStepUp/YY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on each phase <i>P<sub>1,2,3</sub> = 1800 kW</i></li>
  <li>power factor on each phase <i>cos&phi;<sub>1,2,3</sub> = 0.9</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>Y-Y transformer</li>
</ul>
</html>"));
              end YY;
            annotation (Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",             info="<html>
<p>
This package contains examples for the IEEE 4 nodes test validation
whith balanced load and step up in the voltage of the transformers.
</p>
</html>"));
            end BalancedStepUp;

            package UnbalancedStepDown "Package that contains the examples for unbalanced loads and step down transformer"
              extends Modelica.Icons.ExamplesPackage;

              model DD
                "IEEE 4 node test feeder model with unbalanced load and D - D connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={12341,12370,12302},
                  final V3_ref={3902,3972,3871},
                  final V4_ref={3431,3647,3294},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.8,-90.5,
                      149.5},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{27.2,-93.9,
                      145.7},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{24.3,-100.4,
                      138.6},
                  loadRL(loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta,
                      use_pf_in=true));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{8,76},{28,96}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{34,58},{54,78}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{54,30},{74,50}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{-6,-30},{14,-10}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{16,-50},{36,-30}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{38,-70},{58,-50}})));
              equation
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{75,40},{80,40},{80,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{55,68},{84,68},{84,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{29,86},{88,86},{88,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{15,-20},{58,-20},{58,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{37,-40},{64,-40},{64,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{59,-60},{70.2,-60},{70.2,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepDown/DD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>D-D transformer</li>
</ul>
</html>"));
              end DD;

              model DY
                "IEEE 4 node test feeder model with unbalanced load and D - Y connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={12350,12314,12333},
                  final V3_ref={2290,2261,2214},
                  final V4_ref={2157,1936,1849},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.6,-90.4,
                      149.8},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-32.4,-153.8,
                      85.2},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-34.2,-157.0,
                      73.4},
                  loadRL(use_pf_in=true),
                  line2(terminal_p(phase(v(each start=-1)))));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownDY
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{14,76},{34,96}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{40,58},{60,78}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{22,-50},{42,-30}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{44,-70},{64,-50}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{60,30},{80,50}})));
              equation
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{21,-20},{58,-20},{58,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{43,-40},{64,-40},{64,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{65,-60},{70.2,-60},{70.2,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{61,68},{90,68},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{35,86},{94,86},{94,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{81,40},{86,40},{86,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepDown/DY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
January 12, 2019, by Michael Wetter:<br/>
Corrected wrong use of <code>each</code>.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>D-Y transformer</li>
</ul>
</html>"));
              end DY;

              model YD
                "IEEE 4 node test feeder model with unbalanced load and Y - D connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={7113,7144,7111},
                  final V3_ref={3896,3972,3875},
                  final V4_ref={3425,3646,3298},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.2,-120.4,
                      119.5},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-2.8,-123.8,
                      115.7},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-5.8,-130.3,
                      108.6},
                  loadRL(
                    loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta,
                    use_pf_in=true,
                    load1(v(each start=3000))),
                  line1(i1(each start=200)));

                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepDownYD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{14,74},{34,94}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{40,56},{60,76}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{60,28},{80,48}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{0,-32},{20,-12}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{22,-52},{42,-32}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{44,-72},{64,-52}})));
              equation
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{61,66},{90,66},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{35,84},{94,84},{94,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{81,38},{86,38},{86,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{21,-22},{58,-22},{58,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{43,-42},{64,-42},{64,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{65,-62},{70.2,-62},{70.2,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepDown/YD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>Y-D transformer</li>
</ul>
</html>"));
              end YD;

              model YY
                "IEEE 4 node test feeder model with unbalanced load and Y - Y connection (step down)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=4.16e3,
                  final VARbase=6000e3,
                  final V2_ref={7164,7110,7082},
                  final V3_ref={2305,2255,2203},
                  final V4_ref={2175,1930,1833},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.1,-120.2,
                      119.3},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-2.3,-123.6,
                      114.8},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-4.1,-126.8,
                      102.8},
                  loadRL(use_pf_in=true),
                  line1(
                    i1(start={180,-130}),
                    i2(start={-300,-160}),
                    i3(start={40,450})),
                  line2(i2(start={-900,-480}), i3(start={130,1400})));

                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{54,30},{74,50}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{28,58},{48,78}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{2,74},{22,94}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{-16,-38},{4,-18}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{2,-64},{22,-44}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{24,-88},{44,-68}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-28,0},{-8,20}})));
              equation
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{75,40},{82,40},{82,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{49,68},{84,68},{84,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{23,84},{86,84},{86,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{5,-28},{58,-28},{58,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{23,-54},{64,-54},{64,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{45,-78},{70.2,-78},{70.2,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-28,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-8,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-28,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepDown/YY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-down transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 4.16kV</i>),</li>
<li>Y-Y transformer</li>
</ul>
</html>"));
              end YY;
            annotation (Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",             info="<html>
<p>
This package contains examples for the IEEE 4 nodes test validation
whith unbalanced load and step down in the voltage of the transformers.
</p>
</html>"));
            end UnbalancedStepDown;

            package UnbalancedStepUp "Package that contains the examples for unbalanced loads and step up transformer"
              extends Modelica.Icons.ExamplesPackage;

              model DD
                "IEEE 4 node test feeder model with unbalanced load and D - D connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={12362,12392,12334},
                  final V3_ref={23675,24060,23573},
                  final V4_ref={23610,24015,23492},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.8,-90.4,
                      149.5},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{27.2,-93.6,
                      146.0},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{27.2,-93.7,
                      145.9},
                  loadRL(loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta,
                      use_pf_in=true));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerDD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{8,76},{28,96}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{34,58},{54,78}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{54,30},{74,50}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{-6,-30},{14,-10}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{16,-50},{36,-30}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{38,-70},{58,-50}})));
              equation
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{75,40},{80,40},{80,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{55,68},{84,68},{84,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{29,86},{88,86},{88,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{15,-20},{58,-20},{58,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{37,-40},{64,-40},{64,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{59,-60},{70.2,-60},{70.2,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(node1.term, source.terminal) annotation (Line(
                    points={{-74,29},{-74,30},{-74,30},{-74,10},{-74,10},{-78,10},{-78,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepUp/DD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>D-D transformer</li>
</ul>
</html>"));
              end DD;

              model DY
                "IEEE 4 node test feeder model with unbalanced load and D - Y connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=false,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={12364,12391,12333},
                  final V3_ref={13792,13733,13641},
                  final V4_ref={13768,13684,13600},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{29.8,-90.5,
                      149.6},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{27.7,-93.5,
                      145.4},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{27.7,-93.6,
                      145.2},
                  loadRL(use_pf_in=true));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpDY
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase,
                  conv1(V1(start={10E3,5.5E3}))) annotation (Placement(
                      transformation(extent={{-26,0},{-6,20}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{14,76},{34,96}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{40,58},{60,78}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{22,-50},{42,-30}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{44,-70},{64,-50}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{60,30},{80,50}})));
              equation
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{21,-20},{58,-20},{58,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{43,-40},{64,-40},{64,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{65,-60},{70.2,-60},{70.2,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{61,68},{90,68},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{35,86},{94,86},{94,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{81,40},{86,40},{86,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepUp/DY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 9, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>D-Y transformer</li>
</ul>
</html>"));
              end DY;

              model YD
                "IEEE 4 node test feeder model with unbalanced load and Y - D connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=false,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeDelta
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={7121,7147,7150},
                  final V3_ref={23703,24040,23576},
                  final V4_ref={23637,23995,23496},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.4,-120.3,
                      119.5},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{57.2,-63.6,
                      176.1},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{57.1,-63.8,
                      175.9},
                  loadRL(loadConn=ProsNet.Electrical.Types.LoadConnection.wye_to_delta,
                      use_pf_in=true));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformerStepUpYD
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase) annotation (Placement(transformation(extent={
                          {-26,0},{-6,20}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{14,76},{34,96}})));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{40,58},{60,78}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{60,30},{80,50}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{0,-30},{20,-10}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{22,-50},{42,-30}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{44,-70},{64,-50}})));
              equation
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{61,68},{90,68},{90,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{35,86},{94,86},{94,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{81,40},{86,40},{86,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{21,-20},{58,-20},{58,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{43,-40},{64,-40},{64,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{65,-60},{70.2,-60},{70.2,-4.44089e-16}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-26,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepUp/YD.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html><ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>Y-D transformer</li>
</ul>
</html>"));
              end YD;

              model YY
                "IEEE 4 node test feeder model with unbalanced load and Y - Y connection (step up)"
                extends
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.BaseClasses.IEEE4(
                  final line1_use_Z_y=true,
                  final line2_use_Z_y=true,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node1,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node2,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node3,
                  redeclare
                    ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye
                    node4,
                  final VLL_side1=12.47e3,
                  final VLL_side2=24.9e3,
                  final VARbase=6000e3,
                  final V2_ref={7161,7120,7128},
                  final V3_ref={13839,13663,13655},
                  final V4_ref={13815,13614,13615},
                  final Theta2_ref=Modelica.Constants.pi/180.0*{-0.1,-120.3,
                      119.3},
                  final Theta3_ref=Modelica.Constants.pi/180.0*{-2.1,-123.3,
                      115.1},
                  final Theta4_ref=Modelica.Constants.pi/180.0*{-2.2,-123.4,
                      114.9},
                  loadRL(use_pf_in=true));
                Modelica.Blocks.Sources.Constant load2(k=-1800e3)
                  annotation (Placement(transformation(extent={{30,58},{50,78}})));
                Modelica.Blocks.Sources.Constant load3(k=-2375e3)
                  annotation (Placement(transformation(extent={{4,74},{24,94}})));
                Modelica.Blocks.Sources.Constant load1(k=-1275e3)
                  annotation (Placement(transformation(extent={{56,30},{76,50}})));
                Modelica.Blocks.Sources.Constant pf1(k=0.85)
                  annotation (Placement(transformation(extent={{-6,-28},{14,-8}})));
                Modelica.Blocks.Sources.Constant pf2(k=0.9)
                  annotation (Placement(transformation(extent={{12,-54},{32,-34}})));
                Modelica.Blocks.Sources.Constant pf3(k=0.95)
                  annotation (Placement(transformation(extent={{34,-78},{54,-58}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Conversion.ACACTransformer
                  transformer(
                  VHigh=VLL_side1,
                  VLow=VLL_side2,
                  XoverR=6,
                  Zperc=sqrt(0.01^2 + 0.06^2),
                  VABase=VARbase,
                  conv1(V1(start={6.9E3,-250})),
                  conv2(V1(start={-3.8E3,-5.7E3}))) annotation (Placement(
                      transformation(extent={{-28,0},{-8,20}})));
              equation
                connect(load2.y, loadRL.Pow2) annotation (Line(
                    points={{51,68},{86,68},{86,10},{76,10}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load3.y, loadRL.Pow3) annotation (Line(
                    points={{25,84},{88,84},{88,2},{76,2}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(load1.y, loadRL.Pow1) annotation (Line(
                    points={{77,40},{84,40},{84,18},{76,18}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf1.y, loadRL.pf_in_1) annotation (Line(
                    points={{15,-18},{58,-18},{58,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf2.y, loadRL.pf_in_2) annotation (Line(
                    points={{33,-44},{64,-44},{64,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(pf3.y, loadRL.pf_in_3) annotation (Line(
                    points={{55,-68},{70.2,-68},{70.2,0}},
                    color={0,0,127},
                    smooth=Smooth.None));
                connect(line1.terminal_p, transformer.terminal_n) annotation (Line(
                    points={{-48,10},{-28,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(transformer.terminal_p, line2.terminal_n) annotation (Line(
                    points={{-8,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node1.term, line1.terminal_n) annotation (Line(
                    points={{-74,29},{-74,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node2.term, transformer.terminal_n) annotation (Line(
                    points={{-42,29},{-42,10},{-28,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node3.term, line2.terminal_n) annotation (Line(
                    points={{6,29},{6,10},{12,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(node4.term, loadRL.terminal) annotation (Line(
                    points={{38,29},{38,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation (experiment(StopTime=1.0, Tolerance=1e-6),
                __Dymola_Commands(file=
                        "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4NodesFeeder/UnbalancedStepUp/YY.mos"
                      "Simulate and plot"),
               Documentation(revisions="<html>
<ul>
<li>
November 28, 2016, by Michael Wetter:<br/>
Set start values.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Moved to Examples IEEE package Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder.UnbalancedStepUp.YY
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
IEEE 4 nodes validation test case with the following characteristics
</p>
<ul>
<li>balanced load,
  <ul>
  <li>power consumption on phases <i>P<sub>1</sub> = 2375 kW</i>,
  <i>P<sub>2</sub> = 1800 kW</i>, and <i>P<sub>3</sub> = 1275 kW</i></li>
  <li>power factor on phases <i>cos&phi;<sub>1</sub> = 0.85</i>,
  <i>cos&phi;<sub>2</sub> = 0.9</i>, and <i>cos&phi;<sub>3</sub> = 0.95</i></li>
  </ul>
</li>
<li>voltage step-up transformer (<i>V<sub>Pri</sub>=12.47 kV</i>,
<i>V<sub>Sec</sub> = 24.9kV</i>),</li>
<li>Y-Y transformer</li>
</ul>
</html>"));
              end YY;
            annotation (Documentation(revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",             info="<html>
<p>
This package contains examples for the IEEE 4 nodes test validation
whith unbalanced load and step up in the voltage of the transformers.
</p>
</html>"));
            end UnbalancedStepUp;

            package BaseClasses "This package contains the base classes used by the IEEE 4 nodes test feeder"
            extends Modelica.Icons.BasesPackage;

              partial model IEEE4 "Base model of the IEEE 4 nodes test feeder"
                extends Modelica.Icons.Example;
                parameter Modelica.Units.SI.Voltage VLL_side1=12.47e3
                  "Voltage line to line side 1";
                parameter Modelica.Units.SI.Voltage VLL_side2=4.16e3
                  "Voltage line to line side 2";

                parameter Modelica.Units.SI.ApparentPower VARbase=6000e3
                  "Base VA power of the transformer";

                parameter Boolean line1_use_Z_y = true
                  "Choose between Zy or Zd impedance matrix for line 1";
                parameter Boolean line2_use_Z_y = true
                  "Choose between Zy or Zd impedance matrix for line 2";

                parameter Modelica.Units.SI.Voltage V2_ref[3]={7107,7140,7121}
                  "Reference RMS voltage node 2 - IEEE results";
                parameter Modelica.Units.SI.Voltage V3_ref[3]={2247,2269,2256}
                  "Reference RMS voltage node 3 - IEEE results";
                parameter Modelica.Units.SI.Voltage V4_ref[3]={1918,2061,1981}
                  "Reference RMS voltage node 4 - IEEE results";
                parameter Modelica.Units.SI.Angle Theta2_ref[3](each displayUnit="deg") = {-0.3,
                  -120.3,119.6} "Reference voltage phase angle node 2 - IEEE results";
                parameter Modelica.Units.SI.Angle Theta3_ref[3](each displayUnit="deg") = {-3.7,
                  -123.5,116.4} "Reference voltage phase angle node 3 - IEEE results";
                parameter Modelica.Units.SI.Angle Theta4_ref[3](each displayUnit="deg") = {-9.1,
                  -128.3,110.9} "Reference voltage phase angle node 4 - IEEE results";
                Modelica.Units.SI.Voltage err_V2[3]=node2.V - V2_ref
                  "Error on voltage at node 2";
                Modelica.Units.SI.Voltage err_V3[3]=node3.V - V3_ref
                  "Error on voltage at node 3";
                Modelica.Units.SI.Voltage err_V4[3]=node4.V - V4_ref
                  "Error on voltage at node 4";
                Modelica.Units.SI.Angle err_Theta2[3](each displayUnit="deg") = node2.theta
                   - Theta2_ref "Error on voltage at node 2";
                Modelica.Units.SI.Angle err_Theta3[3](each displayUnit="deg") = node3.theta
                   - Theta3_ref "Error on voltage at node 3";
                Modelica.Units.SI.Angle err_Theta4[3](each displayUnit="deg") = node4.theta
                   - Theta4_ref "Error on voltage at node 4";
                Real err_V2_percent[3] = 100*{err_V2[i]/V2_ref[i] for i in 1:3}
                  "Error in RMS voltage at node 2 -- percent";
                Real err_V3_percent[3] = 100*{err_V3[i]/V3_ref[i] for i in 1:3}
                  "Error in RMS voltage at node 3 -- percent";
                Real err_V4_percent[3] = 100*{err_V4[i]/V4_ref[i] for i in 1:3}
                  "Error in RMS voltage at node 4 -- percent";
                Real err_Theta2_percent[3] = 100*{err_Theta2[i]/Theta2_ref[i] for i in 1:3}
                  "Error in voltage phase angle at node 2 -- percent";
                Real err_Theta3_percent[3] = 100*{err_Theta3[i]/Theta3_ref[i] for i in 1:3}
                  "Error in voltage phase angle at node 3 -- percent";
                Real err_Theta4_percent[3] = 100*{err_Theta4[i]/Theta4_ref[i] for i in 1:3}
                  "Error in voltage phase angle at node 4 -- percent";
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.FixedVoltage
                  source(f=60, V=VLL_side1) "Voltage source" annotation (
                    Placement(transformation(extent={{-98,0},{-78,20}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortMatrixRL
                  line1(
                  Z11=L1*(if line1_use_Z_y then Z11_y else Z11_d),
                  Z12=L1*(if line1_use_Z_y then Z12_y else Z12_d),
                  Z13=L1*(if line1_use_Z_y then Z13_y else Z13_d),
                  Z22=L1*(if line1_use_Z_y then Z22_y else Z22_d),
                  Z23=L1*(if line1_use_Z_y then Z23_y else Z23_d),
                  Z33=L1*(if line1_use_Z_y then Z33_y else Z33_d),
                  V_nominal=VLL_side1) "Line at primary side" annotation (
                    Placement(transformation(extent={{-68,0},{-48,20}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Lines.TwoPortMatrixRL
                  line2(
                  Z11=L2*(if line2_use_Z_y then Z11_y else Z11_d),
                  Z12=L2*(if line2_use_Z_y then Z12_y else Z12_d),
                  Z13=L2*(if line2_use_Z_y then Z13_y else Z13_d),
                  Z22=L2*(if line2_use_Z_y then Z22_y else Z22_d),
                  Z23=L2*(if line2_use_Z_y then Z23_y else Z23_d),
                  Z33=L2*(if line2_use_Z_y then Z33_y else Z33_d),
                  V_nominal=VLL_side2) "Line at secondary side" annotation (
                    Placement(transformation(extent={{12,0},{32,20}})));
                ProsNet.Electrical.AC.ThreePhasesUnbalanced.Loads.Inductive loadRL(
                  pf=0.9,
                  V_nominal=VLL_side2,
                  mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
                  use_pf_in=true) "Load" annotation (Placement(transformation(
                        extent={{54,0},{74,20}})));
                replaceable
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe
                  node1(perUnit=false, V_nominal=VLL_side1) "Probe at source"
                  annotation (Placement(transformation(extent={{-84,28},{-64,48}})));
                replaceable
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe
                  node2(perUnit=false, V_nominal=VLL_side1)
                  "Probe at the primary side of the transformer" annotation (
                    Placement(transformation(extent={{-52,28},{-32,48}})));
                replaceable
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe
                  node3(perUnit=false, V_nominal=VLL_side2)
                  "Probe at the secondary side of the transformer" annotation (
                    Placement(transformation(extent={{-4,28},{16,48}})));
                replaceable
                  ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.BaseClasses.GeneralizedProbe
                  node4(perUnit=false, V_nominal=VLL_side2) "Probe at the load"
                  annotation (Placement(transformation(extent={{28,28},{48,48}})));

              protected
                parameter Real L1 = 2000*(1.0/5280.0) "Length line 1 in miles";
                parameter Real L2 = 2500*(1.0/5280.0) "Length line 2 in miles";

                parameter Modelica.Units.SI.Impedance Z11_d[2]={0.4013,1.4133}
                  "Element [1,1] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z12_d[2]={0.0953,0.8515}
                  "Element [1,2] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z13_d[2]={0.0953,0.7266}
                  "Element [1,3] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z22_d[2]={0.4013,1.4133}
                  "Element [2,2] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z23_d[2]={0.0953,0.7802}
                  "Element [2,3] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z33_d[2]={0.4013,1.4133}
                  "Element [3,3] of impedance matrix";

                parameter Modelica.Units.SI.Impedance Z11_y[2]={0.4576,1.078}
                  "Element [1,1] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z12_y[2]={0.1559,0.5017}
                  "Element [1,2] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z13_y[2]={0.1535,0.3849}
                  "Element [1,3] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z22_y[2]={0.4666,1.0482}
                  "Element [2,2] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z23_y[2]={0.158,0.4236}
                  "Element [2,3] of impedance matrix";
                parameter Modelica.Units.SI.Impedance Z33_y[2]={0.4615,1.0651}
                  "Element [3,3] of impedance matrix";
              equation
                connect(source.terminal, line1.terminal_n) annotation (Line(
                    points={{-78,10},{-68,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                connect(line2.terminal_p, loadRL.terminal) annotation (Line(
                    points={{32,10},{54,10}},
                    color={0,120,120},
                    smooth=Smooth.None));
                annotation ( Documentation(revisions="<html>
<ul>
<li>
October 1, 2015, by Michael Wetter:<br/>
Removed <code>loadRL.P_nominal</code> as the power is an input and
<code>P_nominal</code> is disabled in this configuration.
</li>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",               info="<html>
<p>
This is a partial model that is extended by all the other validation test cases.
This model defined replaceable probes and transformer so they can be
easily changed when implementing the different tests.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4nodesFeeder/IEEE_4nodes_schema.png\"/>
</p>

<p>
More information can be found in each model that extends this
one.
</p>

<h4>Reference results</h4>
<p>
The reference results for the tests are saved as parameter of the model and compared to
the simulated ones. The error between the results (herein called <i>X<sub>model</sub></i>)
 and the references (herein called  <i>X<sub>ref</sub></i>) are computed in both
absolute and relative way. Note that  <i>X<sub>model</sub></i> and  <i>X<sub>ref</sub></i>
can be either voltage amplitudes or phase angles.
</p>
<p align=\"center\" style=\"font-style:italic;\">
Err<sub>abs</sub> = X<sub>model</sub> - X<sub>ref</sub>
</p>
<p align=\"center\" style=\"font-style:italic;\">
Err<sub>%</sub> = Err<sub>abs</sub> / X<sub>ref</sub>
</p>

<p>The variables that store the results of the comparison are listed in the
table below</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
  <th>Variable</th>
  <th>Description</th>
  <th>Unit</th>
</tr>
<tr>
  <td><code>err_V2[3]</code></td>
  <td>Error between simulated voltage at node 2 and reference results</td>
  <td>[V]</td>
</tr>
<tr>
  <td><code>err_V3[3]</code></td>
  <td>Error between simulated voltage at node 3 and reference results</td>
  <td>[V]</td>
</tr>
<tr>
  <td><code>err_V4[3]</code></td>
  <td>Error between simulated voltage at node 4 and reference results</td>
  <td>[V]</td>
</tr>
<tr>
  <td><code>err_Theta2[3]</code></td>
  <td>Error between simulated phase angle at node 2 and reference phase angle</td>
  <td>[rad], displayed as [deg]</td>
</tr>
<tr>
  <td><code>err_Theta3[3]</code></td>
  <td>Error between simulated phase angle at node 2 and reference phase angle</td>
  <td>[rad], displayed as [deg]</td>
</tr>
<tr>
  <td><code>err_Theta4[3]</code></td>
  <td>Error between simulated phase angle at node 2 and reference phase angle</td>
  <td>[rad], displayed as [deg]</td>
</tr>
<tr>
  <td><code>err_V2_percent[3]</code></td>
  <td>Relative error between simulated voltage at node 2 and reference results</td>
  <td>[%]</td>
</tr>
<tr>
  <td><code>err_V3_percent[3]</code></td>
  <td>Relative error between simulated voltage at node 3 and reference results</td>
  <td>[%]</td>
</tr>
<tr>
  <td><code>err_V4_percent[3]</code></td>
  <td>Relative error between simulated voltage at node 4 and reference results</td>
  <td>[%]</td>
</tr>
<tr>
  <td><code>err_Theta2_percent[3]</code></td>
  <td>Relative error between simulated phase angle at node 2 and reference phase angle</td>
  <td>[%]</td>
</tr>
<tr>
  <td><code>err_Theta3_percent[3]</code></td>
  <td>Relative error between simulated phase angle at node 2 and reference phase angle</td>
  <td>[%]</td>
</tr>
<tr>
  <td><code>err_Theta4_percent[3]</code></td>
  <td>Relative error between simulated phase angle at node 2 and reference phase angle</td>
  <td>[%]</td>
</tr>
</table>

</html>"));
              end IEEE4;
            annotation (Documentation(info="<html>
<p>
This package contains base classes used by the models that are part of the package
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Validation.IEEETests.Test4NodesFeeder</a>.
</p>
</html>",             revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
            end BaseClasses;
          annotation (Documentation(info="<html>
<p>
This package contains examples that shows the validation of the models
against the IEEE four-nodes test feeder validation procedure <a href=\"#\"></a>.
The tests that are part of the validation certify the capability to represent
transformers of various configurations, full three-phase lines, and unbalanced loads.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Validation/IEEETests/Test4nodesFeeder/IEEE_4nodes_schema.png\"/>
</p>
<p>
The figure shows the structure of the four-nodes network. The voltage
source is connected to the load through two lines and a transformer. The validation procedure
consists of mutliple tests in which the type of the load and the type of the transformer vary.
The test cases that have been successfully implemented using the models of the
<a href=\"modelica://Buildings.Electrical\">Buildings.Electrical</a>
package.
</p>
<p>
Each example in this package is part of the validation tests.
The examples have been grouped into sub-packages depending on the characteristics
of the validation test. The table below summarizes the examples that are part of this
package.
</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
  <th>Transformer</th>
  <th>Load</th>
</tr>
<tr>
  <td>Gr Y - Gr Y Step Up</td>
  <td>Balanced</td>
</tr>
<tr>
  <td>Gr Y - D Step Up</td>
  <td>Balanced</td>
</tr>
<tr>
  <td>D - D Step Up</td>
  <td>Balanced</td>
</tr>
<tr>
  <td>Gr Y - Gr Y Step Down</td>
  <td>Balanced</td>
</tr>
<tr>
  <td>Gr Y - D Step Down</td>
  <td>Balanced</td>
</tr>
<tr>
  <td>D - D Step Down</td>
  <td>Balanced</td>
</tr>
<tr>
  <td>Gr Y - Gr Y Step Up</td>
  <td>Unbalanced</td>
</tr>
<tr>
  <td>Gr Y - D Step Up</td>
  <td>Unbalanced</td>
</tr>
<tr>
  <td>D - D Step Up</td>
  <td>Unbalanced</td>
</tr>
<tr>
  <td>Gr Y - Gr Y Step Down</td>
  <td>Unbalanced</td>
</tr>
<tr>
  <td>Gr Y - D Step Down</td>
  <td>Unbalanced</td>
</tr>
<tr>
  <td>D - D Step Down</td>
  <td>Unbalanced</td>
</tr>
</table>

<p>
For example Gr Y - D Step Up indicates that the transformer has a grounded Y connection at the primary
side, and a D connection at the secondary side. Step up indicates that the voltage at the secondary
side is higher than the primary side.
Each test listed in the table produces results that differ from the reference IEEE values by
less than 0.05%, which is the threshold defined by IEEE to determine whether results should be accepted or not.
</p>

<h4>References</h4>
<p>
<a name=\"kersting2001radial\"/>
Kersting, William H.<br/>
<a href=\"http://ewh.ieee.org/soc/pes/dsacom/testfeeders/\">
Radial distribution test feeders</a><br/>
<i>Power Engineering Society Winter Meeting (2) p. 908-912, 2001. IEEE</i><br/>
</p>

</html>",           revisions="<html>
<ul>
<li>
October 8, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
          end Test4NodesFeeder;
        annotation (Documentation(info="<html>
<p>
This package contains examples based on IEEE tests.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end IEEETests;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the validation of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced\">
Buildings.Electrical.AC.ThreePhasesUnbalanced</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
      end Validation;

      package Interfaces "Package with interfaces for three-phase unbalanced AC models"
        extends Modelica.Icons.InterfacesPackage;

        model Adapter3to3
          "Adapter from 3 single phase connectors to a connector with 3 phases"
          extends Modelica.Blocks.Icons.Block;

          ProsNet.Electrical.Interfaces.Terminal terminals[3](redeclare final
              package PhaseSystem = PhaseSystems.OnePhase)
            "Generalized terminal" annotation (Placement(transformation(extent=
                    {{-92,-6},{-108,10}}), iconTransformation(extent={{-106,8},
                    {-90,-8}})));

          Interfaces.Terminal_p terminal "Connector with 3 lines"
           annotation (Placement(transformation(extent={{90,-10},{110,10}}),
                                  iconTransformation(extent={{90,-10},{110,10}})));
        equation
          for i in 1:3 loop
            terminal.phase[i].v     = terminals[i].v;
            terminal.phase[i].i     = -terminals[i].i;
            Connections.branch(terminal.phase[i].theta, terminals[i].theta);
            terminal.phase[i].theta = terminals[i].theta;
          end for;

          annotation (
          defaultComponentName="ada",
          Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                Line(points={{-64,0},{66,0}}, color={28,108,200})}),    Documentation(info="<html>
<p>
Adapter that connect 3 single phase connectors with a connector that has 3 phases.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 25, 2016, by Michael Wetter:<br/>
First implementation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
</ul>
</html>"));
        end Adapter3to3;

        model Connection3to3Ground_n
          "Adapter between Terminal4 (3 phases and ground) and Terminal3 N"

          Terminal_n terminal4 "Connector for side with neutral" annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n ground4
            "Connector for neutral" annotation (Placement(transformation(extent
                  ={{-109,-70},{-89,-50}}), iconTransformation(extent={{-109,-70},
                    {-89,-50}})));
          Terminal_n terminal3 "Connector without neutral" annotation (Placement(transformation(extent={{90,-10},{110,
                    10}}), iconTransformation(extent={{90,-10},{110,10}})));
        equation

          // Connection branches required to propagate the reference angle
          Connections.branch(terminal4.phase[1].theta, ground4.theta);
          terminal4.phase[1].theta = ground4.theta;
          for i in 1:3 loop
            Connections.branch(terminal3.phase[i].theta, terminal4.phase[i].theta);
            terminal3.phase[i].theta = terminal4.phase[i].theta;
          end for;

          // KVL and KCL
          terminal3.phase[1].v[:] = terminal4.phase[1].v[:] - ground4.v[:];
          terminal3.phase[2].v[:] = terminal4.phase[2].v[:] - ground4.v[:];
          terminal3.phase[3].v[:] = terminal4.phase[3].v[:] - ground4.v[:];

          terminal4.phase[1].i[:] + terminal4.phase[2].i[:] = -terminal4.phase[3].i[:] - ground4.i[:];
          terminal4.phase[1].i[:] = - terminal3.phase[1].i[:];
          terminal4.phase[2].i[:] = - terminal3.phase[2].i[:];
          terminal4.phase[3].i[:] = - terminal3.phase[3].i[:];

          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                                                     Polygon(
                  points={{-80,110},{-80,70},{0,70},{0,110},{-80,110}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,50},{-80,10},{0,10},{0,50},{-80,50}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-10},{-80,-50},{0,-50},{0,-10},{-80,-10}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-70},{-80,-110},{0,-110},{0,-70},{-80,-70}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{0,-40},{0,-80},{80,-80},{80,-40},{0,-40}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{0,20},{0,-20},{80,-20},{80,20},{0,20}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{0,80},{0,40},{80,40},{80,80},{0,80}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
<ul>
<li>
February 25, 2016, by Michael Wetter:<br/>
First implementation based on previous
<code>Buildings.Electrical.AC.ThreePhasesUnbalanced.InterfacesConnection3to4_p</code>
which did not conform to the Modelica Language Definition.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Adapter between electric connectors type n for AC three-phase unbalanced systems.
This adapter connects a connector without neutral cable to a connector without
neutral cable.
</p>
</html>"));
        end Connection3to3Ground_n;

        model Connection3to3Ground_p
          "Adapter between Terminal4 (3 phases and ground) and Terminal3 P"

          Terminal_p terminal4 "Connector with neutral" annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_p ground4
            "Connector for neutral" annotation (Placement(transformation(extent
                  ={{-114,-70},{-94,-50}}), iconTransformation(extent={{-114,-70},
                    {-94,-50}})));
          Terminal_p terminal3 "Connector without neutral" annotation (Placement(transformation(extent={{90,-10},{110,
                    10}}), iconTransformation(extent={{90,-10},{110,10}})));
        equation

          // Connection branches required to propagate the reference angle
          Connections.branch(terminal4.phase[1].theta, ground4.theta);
          terminal4.phase[1].theta = ground4.theta;
          for i in 1:3 loop
            Connections.branch(terminal3.phase[i].theta, terminal4.phase[i].theta);
            terminal3.phase[i].theta = terminal4.phase[i].theta;
          end for;

          // KVL and KCL
          terminal3.phase[1].v[:] = terminal4.phase[1].v[:] - ground4.v[:];
          terminal3.phase[2].v[:] = terminal4.phase[2].v[:] - ground4.v[:];
          terminal3.phase[3].v[:] = terminal4.phase[3].v[:] - ground4.v[:];

          terminal4.phase[1].i[:] + terminal4.phase[2].i[:] = -terminal4.phase[3].i[:] - ground4.i[:];
          terminal4.phase[1].i[:] = - terminal3.phase[1].i[:];
          terminal4.phase[2].i[:] = - terminal3.phase[2].i[:];
          terminal4.phase[3].i[:] = - terminal3.phase[3].i[:];

          annotation ( Icon(graphics={               Polygon(
                  points={{-80,110},{-80,70},{0,70},{0,110},{-80,110}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,50},{-80,10},{0,10},{0,50},{-80,50}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-10},{-80,-50},{0,-50},{0,-10},{-80,-10}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-70},{-80,-110},{0,-110},{0,-70},{-80,-70}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                      points={{0,80},{0,40},{80,40},{80,80},{0,80}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid),Polygon(
                      points={{0,20},{0,-20},{80,-20},{80,20},{0,20}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid),Polygon(
                      points={{0,-40},{0,-80},{80,-80},{80,-40},{0,-40}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
<ul>
<li>
February 25, 2016, by Michael Wetter:<br/>
First implementation based on previous
<code>Buildings.Electrical.AC.ThreePhasesUnbalanced.InterfacesConnection3to4_p</code>
which did not conform to the Modelica Language Definition.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Adapter between electric connectors type p for AC three-phase unbalanced systems.
This adapter connects a connector without neutral cable to a connector without
neutral cable.
</p>
</html>"));
        end Connection3to3Ground_p;

        model Connection3to4_n "Adapter between Terminal4 and Terminal3 N"

          Terminal4_n terminal4 "Connector with neutral" annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          Terminal_n terminal3 "Connector without neutral" annotation (Placement(transformation(extent={{90,-10},{110,
                    10}}), iconTransformation(extent={{90,-10},{110,10}})));
        equation

          // Connection branches required to propagate the reference angle
          Connections.branch(terminal4.phase[1].theta, terminal4.phase[4].theta);
          terminal4.phase[1].theta = terminal4.phase[4].theta;
          for i in 1:3 loop
            Connections.branch(terminal3.phase[i].theta, terminal4.phase[i].theta);
            terminal3.phase[i].theta = terminal4.phase[i].theta;
          end for;

          // KVL and KCL
          terminal3.phase[1].v[:] = terminal4.phase[1].v[:] - terminal4.phase[4].v[:];
          terminal3.phase[2].v[:] = terminal4.phase[2].v[:] - terminal4.phase[4].v[:];
          terminal3.phase[3].v[:] = terminal4.phase[3].v[:] - terminal4.phase[4].v[:];

          terminal4.phase[1].i[:] + terminal4.phase[2].i[:] = -terminal4.phase[3].i[:] - terminal4.phase[4].i[:];
          terminal4.phase[1].i[:] = - terminal3.phase[1].i[:];
          terminal4.phase[2].i[:] = - terminal3.phase[2].i[:];
          terminal4.phase[3].i[:] = - terminal3.phase[3].i[:];

          annotation ( Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                                                     Polygon(
                  points={{-80,110},{-80,70},{0,70},{0,110},{-80,110}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,50},{-80,10},{0,10},{0,50},{-80,50}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-10},{-80,-50},{0,-50},{0,-10},{-80,-10}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-70},{-80,-110},{0,-110},{0,-70},{-80,-70}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{0,-40},{0,-80},{80,-80},{80,-40},{0,-40}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{0,20},{0,-20},{80,-20},{80,20},{0,20}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{0,80},{0,40},{80,40},{80,80},{0,80}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Adapter between electric connectors type n for AC three-phase unbalanced systems.
This adapter connects a connector without neutral cable with a one that has it
</p>
</html>"));
        end Connection3to4_n;

        model Connection3to4_p "Adapter between Terminal4 and Terminal3 P"

          Terminal4_p terminal4 "Connector with neutral" annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          Terminal_p terminal3 "Connector without neutral" annotation (Placement(transformation(extent={{90,-10},{110,
                    10}}), iconTransformation(extent={{90,-10},{110,10}})));
        equation

          // Connection branches required to propagate the reference angle
          Connections.branch(terminal4.phase[1].theta, terminal4.phase[4].theta);
          terminal4.phase[1].theta = terminal4.phase[4].theta;
          for i in 1:3 loop
            Connections.branch(terminal3.phase[i].theta, terminal4.phase[i].theta);
            terminal3.phase[i].theta = terminal4.phase[i].theta;
          end for;

          // KVL and KCL
          terminal3.phase[1].v[:] = terminal4.phase[1].v[:] - terminal4.phase[4].v[:];
          terminal3.phase[2].v[:] = terminal4.phase[2].v[:] - terminal4.phase[4].v[:];
          terminal3.phase[3].v[:] = terminal4.phase[3].v[:] - terminal4.phase[4].v[:];

          terminal4.phase[1].i[:] + terminal4.phase[2].i[:] = -terminal4.phase[3].i[:] - terminal4.phase[4].i[:];
          terminal4.phase[1].i[:] = - terminal3.phase[1].i[:];
          terminal4.phase[2].i[:] = - terminal3.phase[2].i[:];
          terminal4.phase[3].i[:] = - terminal3.phase[3].i[:];

          annotation ( Icon(graphics={               Polygon(
                  points={{-80,110},{-80,70},{0,70},{0,110},{-80,110}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,50},{-80,10},{0,10},{0,50},{-80,50}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-10},{-80,-50},{0,-50},{0,-10},{-80,-10}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-80,-70},{-80,-110},{0,-110},{0,-70},{-80,-70}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                      points={{0,80},{0,40},{80,40},{80,80},{0,80}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid),Polygon(
                      points={{0,20},{0,-20},{80,-20},{80,20},{0,20}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid),Polygon(
                      points={{0,-40},{0,-80},{80,-80},{80,-40},{0,-40}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid)}),
            Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Adapter between electric connectors type p for AC three-phase unbalanced systems.
This adapter connects two connectors without and without a neutral cable.
</p>
</html>"));
        end Connection3to4_p;

        connector Terminal4_n
          "Terminal N for AC three-phase unbalanced systems (neutral cable)"
          ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n phase[4];
          annotation (Icon(graphics={                Polygon(
                  points={{-100,110},{-100,70},{100,70},{100,110},{-100,110}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,-10},{-100,-50},{100,-50},{100,-10},{-100,-10}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,50},{-100,10},{100,10},{100,50},{-100,50}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,-70},{-100,-110},{100,-110},{100,-70},{-100,-70}},
                  lineColor={127,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}), Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>Electric connector type n for AC three-phase unbalanced systems
with neutral cable connection.</p>
</html>"));
        end Terminal4_n;

        connector Terminal4_p
          "Terminal P for AC three-phase unbalanced systems (neutral cable)"
          ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_p phase[4]
            "Terminal with 3 phases and neutral cable";
          annotation (Icon(graphics={                Polygon(
                  points={{-100,110},{-100,70},{100,70},{100,110},{-100,110}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,50},{-100,10},{100,10},{100,50},{-100,50}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,-10},{-100,-50},{100,-50},{100,-10},{-100,-10}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,-70},{-100,-110},{100,-110},{100,-70},{-100,-70}},
                  lineColor={127,0,127},
                  fillColor={127,0,127},
                  fillPattern=FillPattern.Solid)}), Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>Electric connector type p for AC three-phase unbalanced systems
with neutral cable connection.</p>
</html>"));
        end Terminal4_p;

        connector Terminal_n
          "Terminal N for AC three-phase unbalanced systems (no neutral cable)"
          ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_n phase[3];
          annotation (Icon(graphics={                Polygon(
                  points={{-100,100},{-100,60},{100,60},{100,100},{-100,100}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,-60},{-100,-100},{100,-100},{100,-60},{-100,-60}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),    Polygon(
                  points={{-100,20},{-100,-20},{100,-20},{100,20},{-100,20}},
                  lineColor={0,120,120},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}), Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>",         info="<html>
<p>Electric connector type n for AC three-phase unbalanced systems.</p>
</html>"));
        end Terminal_n;

        connector Terminal_p
          "Terminal P for AC three-phase unbalanced systems (no neutral cable)"
          ProsNet.Electrical.AC.OnePhase.Interfaces.Terminal_p phase[3];
          annotation (Icon(graphics={                Polygon(
                  points={{-100,100},{-100,60},{100,60},{100,100},{-100,100}},
                  lineColor={0,120,120},
                  fillColor={0,120,120},
                  fillPattern=FillPattern.Solid),    Polygon(
                      points={{-100,-100},{100,-100},{100,-60},{-100,-60},{-100,-100}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid),Polygon(
                      points={{-100,-20},{100,-20},{100,20},{-100,20},{-100,-20}},
                      lineColor={0,120,120},
                      fillColor={0,120,120},
                      fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>Electric connector type p for AC three-phase unbalanced systems.</p>
</html>",         revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Terminal_p;

        partial model TwoPort
          "Partial model interface for a two port component without neutral cable"

          Terminal_p terminal_p "Electric terminal side p"
            annotation (Placement(transformation(extent={{90,-10},{110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
          Terminal_n terminal_n "Electric terminal side n"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Interface model for an AC three-phase unbalanced component with two ports
and without neutral cable.
</p>
</html>"));
        end TwoPort;

        partial model TwoPort_N
          "Partial model interface for a two port component with neutral cable"

          Terminal4_p terminal_p "Electric terminal side p"
            annotation (Placement(transformation(extent={{90,-10},{110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
          Terminal4_n terminal_n "Electric terminal side n"
            annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
October 3, 2014, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>",         info="<html>
<p>
Interface model for an AC three-phase unbalanced component with two ports
and with neutral cable.
</p>
</html>"));
        end TwoPort_N;

        model WyeToDelta "This model represent a connection between wye to delta"

          Terminal_n wye "Terminal Y" annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Terminal_n delta "Terminal D" annotation (Placement(transformation(extent={{90,-10},{110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
        equation

          for i in 1:3 loop
            Connections.branch(wye.phase[i].theta, delta.phase[i].theta);
            wye.phase[i].theta = delta.phase[i].theta;
          end for;

          delta.phase[1].v[:] = wye.phase[1].v[:] - wye.phase[2].v[:];
          delta.phase[2].v[:] = wye.phase[2].v[:] - wye.phase[3].v[:];
          delta.phase[3].v[:] = wye.phase[3].v[:] - wye.phase[1].v[:];

          -wye.phase[1].i[:] + delta.phase[3].i[:] = delta.phase[1].i[:];
          -wye.phase[2].i[:] + delta.phase[1].i[:] = delta.phase[2].i[:];
          -wye.phase[3].i[:] + delta.phase[2].i[:] = delta.phase[3].i[:];

          annotation (
          defaultComponentName="y2d",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Line(
                  points={{-40,-26},{0,34},{40,-26},{-40,-26}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5)}),
            Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 5, 2014, by Marco Bonvini:<br/>
Added model.
</li>
</ul>
</html>",         info="<html>
<p>
Adapter from Wye (Y) to Delta (D) connector.
A three-phase unbalanced connector has three AC single phase
connectors. Each AC single phase connector contains the phase voltage,
which is measured between the phase and the neutral.
This model converts the phase voltage to the line voltage, measured between
the phases.
</p>
<p>
The image below show how the phasors are computed when converting from Y to D.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/Interfaces/YtoD.png\"/>
</p>
</html>"));
        end WyeToDelta;

        model WyeToWyeGround
          "This model represent a connection between wye to wye grounded"

          Terminal_n wye "Terminal Y" annotation (Placement(transformation(extent={{-110,-10},{-90,10}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Terminal_n wyeg "Terminal Y with ground connection" annotation (Placement(transformation(extent={{90,-10},{110,10}}),
                iconTransformation(extent={{90,-10},{110,10}})));
          Connection3to3Ground_n connection3to4
            "Adapter between Termina3 and Terminal4"
            annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
          ProsNet.Electrical.AC.OnePhase.Basics.Ground ground
            "Ground reference" annotation (Placement(transformation(extent={{-30,
                    -40},{-10,-20}})));
        equation
          connect(wye, connection3to4.terminal3)
            annotation (Line(points={{-100,0},{-60,0}},         color={0,120,120}));
          connect(connection3to4.terminal4, wyeg) annotation (Line(points={{-40,0},{28,0},
                  {100,0}},           color={0,120,120}));
          connect(connection3to4.ground4, ground.terminal) annotation (Line(points={{-40.6,
                  -6},{-20,-6},{-20,-20}}, color={0,120,120}));
          annotation (
          defaultComponentName="y2yg",
         Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Line(
                  points={{0,40},{0,0},{-30,-30}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,0},{30,-30}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.5),
                Line(
                  points={{0,0},{0,-40}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.25),
                Line(
                  points={{-8,-40},{8,-40}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.25),
                Line(
                  points={{-6,-42},{6,-42}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.25),
                Line(
                  points={{-4,-44},{4,-44}},
                  color={0,120,120},
                  smooth=Smooth.None,
                  thickness=0.25)}),
            Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Replaced <code>connection3to4</code> with new model.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
June 5, 2014, by Marco Bonvini:<br/>
Added model.
</li>
</ul>
</html>",         info="<html>
<p>
Adapter from wye (Y) to wye grounded (Yg) connector.
A three-phase unbalanced connector has three AC single phase
connectors. Each AC single phase connector contains a the phase voltage,
which is measured
between the phase and the neutral. This model assures that the voltage of the neutral
cable is equal to zero.
</p>
</html>"));
        end WyeToWyeGround;

        package Examples "Package with example models"
        extends Modelica.Icons.ExamplesPackage;

          model WyeToDelta "Test for Y to D connection"
            extends Modelica.Icons.Example;

            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Interfaces.WyeToDelta wyeToDelta
              "Conversion of the voltages from Y to D" annotation (Placement(
                  transformation(extent={{-10,-10},{10,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sources.FixedVoltage V1(f=60, V=
                  480) "Voltage source" annotation (Placement(transformation(
                    extent={{-60,-10},{-40,10}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probe_Y(perUnit=
                  false, V_nominal=480)
              "Probe that measures the voltage and the angles on each phase"
              annotation (Placement(transformation(extent={{-30,10},{-10,30}})));
            ProsNet.Electrical.AC.ThreePhasesUnbalanced.Sensors.ProbeWye probeD(perUnit=
                  false, V_nominal=480)
              "Probe that measures the voltage and the angles on each phase"
              annotation (Placement(transformation(extent={{10,10},{30,30}})));
          equation
            connect(V1.terminal, wyeToDelta.wye) annotation (Line(
                points={{-40,0},{-10,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(probe_Y.term, wyeToDelta.wye) annotation (Line(
                points={{-20,11},{-20,0},{-10,0}},
                color={0,120,120},
                smooth=Smooth.None));
            connect(probeD.term, wyeToDelta.delta) annotation (Line(
                points={{20,11},{20,0},{10,0}},
                color={0,120,120},
                smooth=Smooth.None));
            annotation (experiment(StopTime=1.0, Tolerance=1e-6),
            __Dymola_Commands(file=
                    "modelica://Buildings/Resources/Scripts/Dymola/Electrical/AC/ThreePhasesUnbalanced/Interfaces/Examples/WyeToDelta.mos"
                  "Simulate and plot"),
           Documentation(revisions="<html>
<ul>
<li>
October 9, 2014, by Marco Bonvini:<br/>
Revised example and documentation.
</li>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Added info section.
</li>
</ul>
</html>",           info="<html>
<p>
This simple example shows how to use a Y to D adapter.
</p>
<p>
The probe <code>probe_Y</code> mesaures the phase voltages before they
are converted into D. Their RMS value is equal to <i>480/sqrt(3)</i> V.
</p>
<p>
The probe <code>probe_D</code> measures the phase
voltages after the conversion to D. Their RMS value is equal to <i>480</i> V,
the line voltage provided by the voltage source.
</p>
</html>"));
          end WyeToDelta;
        annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced.Interfaces\">
Buildings.Electrical.AC.ThreePhasesUnbalanced.Interfaces</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Examples;
      annotation (Documentation(info="<html>
<p>
This package contains connectors that are used by the models in the
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesUnbalanced\">Buildings.Electrical.AC.ThreePhasesUnbalanced</a> package.
The connectors extends the basic connectors
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">Buildings.Electrical.Interfaces.Terminal</a>
and define a new graphical icon in order to be distinguished by connectors of other electrical systems (e.g. DC systems).
</p>
</html>",       revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
      end Interfaces;
    annotation (Documentation(info="<html>
<p>
Package with models for alternate current (AC) three phase unbalanced systems.<br/>
The models in this package use the models of the package
<a href=\"modelica://Buildings.Electrical.AC.OnePhase\">
Buildings.Electrical.AC.OnePhase</a> to fully describe the three-phase.
</p>
<p>
The models that are part of this package assume by default <i>480</i> V
as the nominal RMS phase to phase voltage. This default can be changed.
</p>

<h4>Conventions</h4>

<p>
In this package the voltage phasors are measured using the convention shown below.
The phase to phase RMS voltages are by default <i>480</i> V,
which is equal to <code>sqrt(3)</code> times the
phase to neutral voltage <i>V</i>, which is <i>277.13</i> V.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/AC/ThreePhasesUnbalanced/PhaseConvention.png\"/>
</p>

<p>
In this package the voltage phasors are measured using the convention shown above.
The phase to phase RMS voltage equal to 480 V, is equal to <code>sqrt(3)</code> times the
phase to neutral voltage <i>V</i> that is equal to 277.13 V.
</p>

</html>",     revisions="<html>
<ul>
<li>
August 25, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
    end ThreePhasesUnbalanced;

    package Interfaces "Package that contains some useful interfaces"
    extends Modelica.Icons.InterfacesPackage;

      connector PowerOutput
        "Connector with real power, reactive power and power factor"
        output Modelica.Units.SI.Power real "Real power";
        output Modelica.Units.SI.ReactivePower apparent "Apparent power";
        output Modelica.Units.SI.Angle phi "Phase shift";
        output Real cosPhi "Power factor";

        annotation (Icon(graphics={ Polygon(
                points={{-100,100},{100,0},{-100,-100},{-100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}), Diagram(graphics={
                                     Polygon(
                points={{-100,50},{0,0},{-100,-50},{-100,50}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{30,110},{30,60}},
                textColor={0,0,127},
                textString="%name")}),
          Documentation(info="<html>
This connector contains multiple quantities that can be used to monitor
the power consumption of a generic AC systems.
</html>",       revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>"));
      end PowerOutput;
    annotation (Documentation(info="<html>
<p>
This package contains interfaces that are used by the models in the
<a href=\"modelica://Buildings.Electrical.AC\">Buildings.Electrical.AC</a> package.
</p>
</html>"));
    end Interfaces;
    annotation (Icon(graphics={ Line(points={{-92,-10},{-80.7,24.2},{-73.5,43.1},{
                -67.1,56.4},{-61.4,64.6},{-55.8,69.1},{-50.2,69.8},{-44.6,66.6},{-38.9,
                59.7},{-33.3,49.4},{-26.9,34.1},{-18.83,11.2},{-1.9,-40.8},{5.3,-60.2},
                {11.7,-74.2},{17.3,-83.1},{23,-88.4},{28.6,-90},{34.2,-87.6},{39.9,
                -81.5},{45.5,-71.9},{51.9,-57.2},{60,-34.8},{68,-10}}, color={0,0,
                0})}), Documentation(info="<html>
<p>
Package with models for alternating current (AC) systems.
</p>
</html>",   revisions="<html>
<ul>
<li>
August 27, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>"));
  end AC;

  package DC "Package for analog direct current (DC) electrical circuits"
    extends Modelica.Icons.Package;

    package Conversion "Package with models for DC/DC conversion"
      extends Modelica.Icons.Package;

      model DCDCConverter "DC DC converter"
        extends ProsNet.Electrical.Interfaces.PartialConversion(
          redeclare package PhaseSystem_p = PhaseSystems.TwoConductor,
          redeclare package PhaseSystem_n = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_n terminal_n,
          redeclare Interfaces.Terminal_p terminal_p);
        parameter Modelica.Units.SI.Voltage VHigh
          "DC voltage on side 1 of the transformer (primary side)";
        parameter Modelica.Units.SI.Voltage VLow
          "DC voltage on side 2 of the transformer (secondary side)";
        parameter Modelica.Units.SI.Efficiency eta(max=1) "Converter efficiency";
        parameter Boolean ground_1 = true "Connect side 1 of converter to ground" annotation(Evaluate=true, Dialog(tab = "Ground", group="side 1"));
        parameter Boolean ground_2 = true "Connect side 2 of converter to ground" annotation(Evaluate=true, Dialog(tab = "Ground", group="side 2"));
        Modelica.Units.SI.Power LossPower "Loss power";
      protected
        parameter Real conversionFactor = VLow/VHigh
          "Ratio of high versus low voltage";
        Modelica.Units.SI.Current i1;
        Modelica.Units.SI.Current i2;
        Modelica.Units.SI.Voltage v1;
        Modelica.Units.SI.Voltage v2;
        Modelica.Units.SI.Power P_p "Power at terminal p";
        Modelica.Units.SI.Power P_n "Power at terminal n";
      equation
        Connections.potentialRoot(terminal_n.theta);
        Connections.potentialRoot(terminal_p.theta);

        if not ground_1 then
          i1 = 0;
        else
          v1 = 0;
        end if;
        if not ground_2 then
          i2 = 0;
        else
          v2 = 0;
        end if;

        P_p = PhaseSystem_p.activePower(terminal_p.v, terminal_p.i);
        P_n = PhaseSystem_n.activePower(terminal_n.v, terminal_n.i);

        v1 = terminal_n.v[2];
        v2 = terminal_p.v[2];
        sum(terminal_n.i) + i1 = 0;
        sum(terminal_p.i) + i2 = 0;

        // Voltage relation
        v_p = v_n*conversionFactor;

        // OLD equations that take into account the power at the secondary
        // power balance
        // LossPower = (1-eta) * abs(P_p);
        // P_n + P_p - LossPower = 0;

        // Symmetric and linear version
        LossPower = P_p + P_n;
        if i_n >=0 then
          i_p = i_n/conversionFactor/(eta - 2);
        else
          i_n = conversionFactor*i_p/(eta - 2);
        end if;

        annotation ( Icon(coordinateSystem(preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}),
                                            graphics={
              Line(
                points={{2,100},{2,60},{82,60},{2,60},{82,-60},{2,-60},{2,60},{2,-100}},
                color={0,0,255},
                smooth=Smooth.None),
              Text(
                extent={{30,54},{90,14}},
                textColor={0,0,255},
                textString="DC"),
              Line(
                points={{-2,100},{-2,60},{-82,60},{-2,60},{-82,-60},{-2,-60},{-2,60},
                    {-2,-100}},
                color={85,170,255},
                smooth=Smooth.None),
              Text(
                extent={{-88,54},{-28,14}},
                textColor={85,170,255},
                textString="DC"),
              Text(
                extent={{-100,92},{100,60}},
                textColor={0,0,0},
                textString="%name"),
              Text(
                extent={{-120,-60},{-2,-90}},
                textColor={0,0,0},
                textString="%VHigh"),
              Text(
                extent={{-100,-100},{100,-132}},
                textColor={0,0,255},
                textString="%eta"),
              Text(
                extent={{-132,80},{-72,40}},
                textColor={85,170,255},
                textString="1"),
              Text(
                extent={{70,80},{130,40}},
                textColor={0,0,255},
                textString="2"),
              Line(visible = (ground_1 == true),
                points={{-120,-100},{-80,-100}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_1 == true),
                points={{-112,-106},{-88,-106}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_1 == true),
                points={{-106,-112},{-92,-112}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_1 == true),
                points={{-100,-100},{-100,-12}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_2 == true),
                points={{100,-100},{100,-12}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_2 == true),
                points={{80,-100},{120,-100}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_2 == true),
                points={{88,-106},{112,-106}},
                color={0,0,255},
                smooth=Smooth.None),
              Line(visible = (ground_2 == true),
                points={{94,-112},{108,-112}},
                color={0,0,255},
                smooth=Smooth.None),
              Text(
                extent={{2,-60},{120,-90}},
                textColor={0,0,0},
                textString="%VLow")}),
          Documentation(info="<html>
<p>
This is a DC/DC converter, based on a power balance between the two DC sides.
The parameter <i>conversionFactor</i> defines the ratio between the two averaged DC voltages.
The loss of the converter is proportional to the power transmitted at the second DC side.
The parameter <code>eta</code> is the efficiency of the transfer.
The loss is computed as
<p align=\"center\" style=\"font-style:italic;\">
P<sub>loss</sub> = (1-&eta;) P<sub>DC</sub>,
</p>
<p>
where <i>P<sub>DC</sub></i> is the power transmitted. This model is symmetric and the power
can be transmitted in both directions. The loss is computed depending on the direction
of the power flow.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 19, 2015, by Michael Wetter:<br/>
Removed redeclaration of phase system in <code>Terminal_n</code> and
<code>Terminal_p</code> as it is already declared to the be the same
phase system, and it is not declared to be replaceable.
This avoids a translation error in OpenModelica.
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised model and documentation. Changed parameter sof the model,
now the user specify <code>VHigh</code> and <code>VLow</code>
instead of <code>conversionFactor</code>.
</li>
<li>
January 28, 2012, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DCDCConverter;

      package Examples "Package with example models"
        extends Modelica.Icons.ExamplesPackage;

        model DCDCConverter "Test model DC to DC converter"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Loads.Conductor resistor(
            mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
            P_nominal=-2000,
            V_nominal=60) "Resistive load"
            annotation (Placement(transformation(extent={{38,30},{58,50}})));
          ProsNet.Electrical.DC.Sources.ConstantVoltage sou(V=120)
            "Voltage source"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
          ProsNet.Electrical.DC.Conversion.DCDCConverter conDCDC(
            VHigh=120,
            VLow=60,
            eta=0.9,
            i_n(start=0)) "DC/DC transformer"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          ProsNet.Electrical.DC.Loads.Conductor conductor(
            mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            V_nominal=60,
            P_nominal=10e3) "Variable resistive load"
            annotation (Placement(transformation(extent={{38,-30},{58,-10}})));
          Modelica.Blocks.Sources.Ramp varLoad_P(
            duration=0.5,
            startTime=0.3,
            offset=-1000,
            height=10000)
            annotation (Placement(transformation(extent={{90,-30},{70,-10}})));
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor sen "Power sensor"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        equation
          connect(varLoad_P.y, conductor.Pow) annotation (Line(
              points={{69,-20},{58,-20}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(conDCDC.terminal_p, resistor.terminal) annotation (Line(
              points={{4.44089e-16,0},{10,0},{10,40},{38,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(conDCDC.terminal_p, conductor.terminal) annotation (Line(
              points={{4.44089e-16,0},{10,0},{10,-20},{38,-20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.terminal, sen.terminal_n) annotation (Line(
              points={{-70,0},{-60,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, conDCDC.terminal_n) annotation (Line(
              points={{-40,0},{-20,0}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (experiment(StopTime=1.0,Tolerance=1e-06),
            Documentation(info="<html>
<p>
This model illustrates the use of a model that converts between DC voltages.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 30, 2019, by Michael Wetter:<br/>
Added start value.
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),  __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Conversion/Examples/DCDCConverter.mos"
                "Simulate and plot"),
            Icon(coordinateSystem(extent={{-140,-100},{100,140}})));
        end DCDCConverter;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.DC.Conversion\">
Buildings.Electrical.DC.Conversion</a>.
</p>
</html>"));
      end Examples;
    annotation (Documentation(info="<html>
<p>
This package contains models for DC/DC conversion.
AC/DC converters can be found in the respective AC package.
</p>
</html>"));
    end Conversion;

    package Lines "Package with models for DC electrical lines"
      extends Modelica.Icons.Package;

      model Line "Model of a DC electrical line"
        extends ProsNet.Electrical.Transmission.BaseClasses.PartialLine(
          redeclare package PhaseSystem_p = PhaseSystems.TwoConductor,
          redeclare package PhaseSystem_n = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_n terminal_n,
          redeclare Interfaces.Terminal_p terminal_p,
          final modelMode=Types.Load.FixedZ_steady_state,
          commercialCable=
              ProsNet.Electrical.Transmission.Functions.selectCable_low(
              P_nominal, V_nominal));

        TwoPortRCLine lineRC(
          final useHeatPort=true,
          final R=R,
          final V_nominal=V_nominal,
          final T_ref=T_ref,
          final M=M,
          final C=C,
          final use_C=use_C)
          annotation (Placement(transformation(extent={{-10,10},{10,-10}})));
      equation
        connect(terminal_n, lineRC.terminal_n) annotation (Line(
            points={{-100,0},{-10,0}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(lineRC.terminal_p, terminal_p) annotation (Line(
            points={{10,0},{100,0}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(cableTemp.port, lineRC.heatPort) annotation (Line(
            points={{-40,22},{0,22},{0,10}},
            color={191,0,0},
            smooth=Smooth.None));
        annotation ( Icon(graphics={
              Ellipse(
                extent={{-70,10},{-50,-10}},
                lineColor={0,0,0},
                fillColor={96,107,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-60,10},{60,-10}},
                fillColor={96,107,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Ellipse(
                extent={{50,10},{70,-10}},
                lineColor={0,0,0},
                fillColor={255,128,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-70,0},{-90,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-60,10},{60,10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-60,-10},{60,-10}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{96,0},{60,0}},
                color={0,0,0},
                smooth=Smooth.None)}),
          Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Michael Wetter:<br/>
Removed redeclaration of phase system in <code>Terminal_n</code> and
<code>Terminal_p</code> as it is already declared to the be the same
phase system, and it is not declared to be replaceable.
This avoids a translation error in OpenModelica.
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",       info="<html>
<p>
This model represents a DC cable. The model is based on
<a href=\"modelica://Buildings.Electrical.DC.Lines.TwoPortRCLine\">
Buildings.Electrical.DC.Lines.TwoPortRCLine</a>
and provides functionalities to parametrize the values of <i>R</i> and <i>C</i> either
using commercial cables or using default values.
</p>
</html>"));
      end Line;

      model TwoPortRCLine "Model of a two port DC resistance and capacity (T-model)"
        extends ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortRLC(
          redeclare package PhaseSystem_p = PhaseSystems.TwoConductor,
          redeclare package PhaseSystem_n = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_n terminal_n,
          redeclare Interfaces.Terminal_p terminal_p,
          final L=0);
        parameter Boolean use_C = false
          "Set to true to add a capacitance in the center of the line"
          annotation(Dialog(tab="Model", group="Assumptions"));
        parameter Modelica.Units.SI.Voltage Vc_start=V_nominal
          "Initial value of the voltage of the capacitance in the middle of the line";
        Modelica.Units.SI.Voltage Vc(start=Vc_start, stateSelect=StateSelect.prefer)
          "Voltage of the capacitor";
      initial equation
        if C>0 and use_C then
          Vc = Vc_start;
        end if;
      equation
        terminal_p.v[1] - (Vc+terminal_p.v[2]) = terminal_p.i[1]*R_actual/2;
        terminal_n.v[1] - (Vc+terminal_p.v[2]) = terminal_n.i[1]*R_actual/2;

        if C>0 and use_C then
          C*der(Vc) = terminal_p.i[1] + terminal_n.i[1];
        else
          Vc = 0.5*(terminal_p.v[1] - terminal_p.v[2] + terminal_n.v[1] - terminal_n.v[2]);
        end if;

        terminal_p.v[2] = terminal_n.v[2];
        terminal_p.i[2] + terminal_n.i[2] = 0;

        // Joule losses
        LossPower = R_actual/2*terminal_p.i[1]^2 + R_actual/2*terminal_n.i[1]^2;

        annotation (Diagram(graphics={
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255})}), Icon(
              coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                        graphics={
                Text(
                  extent={{-144,97},{156,57}},
                  textColor={0,0,0},
                textString="%name"),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255}),
              Rectangle(
                extent={{-70,32},{70,-28}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This model represents a series of two resistances and a capacitance that connect two DC interfaces.
This model can be used to represent a cable in a DC grid.
</p>
<p>
The model represents the lumped resistances and capacity (T-model) as shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Lines/twoPortRC.png\"/>
</p>
<p>
As can be seen in the figure, the resistance <i>R</i> is split in two halves
and the capacitance is located in the center.
The capacitance in the center is optional and can be selected using the
boolean flag <code>use_C = true</code>. The model is either dynamic or static depending on the
presence of the capacitive effect.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 19, 2015, by Michael Wetter:<br/>
Removed redeclaration of phase system in <code>Terminal_n</code> and
<code>Terminal_p</code> as it is already declared to the be the same
phase system, and it is not declared to be replaceable.
This avoids a translation error in OpenModelica.
</li>
<li>
March 10, 2015, by Marco Bonvini:<br/>
Added initial equation and parameter <code>Vc_start</code>.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortRCLine;

      model TwoPortResistance "Model of a two port DC resistance"
        extends
          ProsNet.Electrical.Transmission.BaseClasses.PartialTwoPortResistance(
          redeclare package PhaseSystem_p = PhaseSystems.TwoConductor,
          redeclare package PhaseSystem_n = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_n terminal_n,
          redeclare Interfaces.Terminal_p terminal_p);
      equation
        // Voltage drop on the resistance lumped on connection between terminals
        // p.v[1] and n.v[1]
        terminal_p.v[1] - terminal_n.v[1] = terminal_p.i[1]*R_actual;
        terminal_p.v[2] = terminal_n.v[2];

        // Joule losses
        LossPower = R_actual*terminal_p.i[1]^2;

        annotation (Diagram(graphics={
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255})}), Icon(
              coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                        graphics={
                Text(
                  extent={{-144,97},{156,57}},
                  textColor={0,0,0},
                textString="%name"),
                Text(
                  extent={{-142,-30},{144,-62}},
                  textColor={0,0,0},
                textString="R=%R"),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255}),
              Rectangle(
                extent={{-70,30},{70,-30}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This model represents a resistance that connect two DC interfaces. This model can be used
to represent a cable in a DC grid.
</p>
<p>
The model represents the lumped resistance as shown in the figure below.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Lines/twoPortR.png\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
March 19, 2015, by Michael Wetter:<br/>
Removed redeclaration of phase system in <code>Terminal_n</code> and
<code>Terminal_p</code> as it is already declared to the be the same
phase system, and it is not declared to be replaceable.
This avoids a translation error in OpenModelica.
</li>
<li>
January 14, 2015, by Marco Bonvini:<br/>
Added equation that represents Joule losses
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortResistance;

      package Examples "Package with example models"
      extends Modelica.Icons.ExamplesPackage;

        model DCLine "Example model to test the DC lines"
          extends Modelica.Icons.Example;
          Line line(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=100) "Transmission line"
            annotation (Placement(transformation(extent={{0,0},{20,20}})));
          Sources.ConstantVoltage E(V=50) "Voltage source"
            annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          Line line1(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=100) "Transmission line"
            annotation (Placement(transformation(extent={{0,-20},{20,0}})));
          Line line2(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=100) "Transmission line"
            annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-90,-20},{-70,0}})));
          Loads.Conductor load1(mode=Types.Load.VariableZ_y_input,
            V_nominal=50,
            linearized=false,
            P_nominal=-50) "Variable load"
            annotation (Placement(transformation(extent={{40,0},{60,20}})));
          Loads.Conductor load2(
            V_nominal=50,
            linearized=false,
            P_nominal=-150) "Load"
            annotation (Placement(transformation(extent={{40,-20},{60,0}})));
          Loads.Conductor load3(
            V_nominal=50,
            linearized=false,
            P_nominal=-200) "Load"
            annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
          Modelica.Blocks.Sources.Ramp varLoad(
            height=0.8,
            duration=0.5,
            offset=0.2,
            startTime=0.3) "Load consumption profile"
            annotation (Placement(transformation(extent={{96,0},{76,20}})));
        equation
          connect(E.terminal, line.terminal_n) annotation (Line(
              points={{-60,10},{-4.44089e-16,10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(E.terminal, line1.terminal_n) annotation (Line(
              points={{-60,10},{-30,10},{-30,-10},{0,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(E.terminal, line2.terminal_n) annotation (Line(
              points={{-60,10},{-30,10},{-30,-30},{0,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(load1.terminal, line.terminal_p) annotation (Line(
              points={{40,10},{20,10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line1.terminal_p, load2.terminal) annotation (Line(
              points={{20,-10},{40,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line2.terminal_p, load3.terminal) annotation (Line(
              points={{20,-30},{40,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad.y, load1.y) annotation (Line(
              points={{75,10},{60,10}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(E.n, ground.p) annotation (Line(
              points={{-80,10},{-80,0}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (experiment(StopTime=1.0,Tolerance=1e-06),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Lines/Examples/DCLine.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
This model is a simple test case that show how to use a line model
and parametrize it using a commercial cable.
</p>
</html>"));
        end DCLine;

        model DCLines
          "Example model to test the possible combinations between line and load models"
          extends Modelica.Icons.Example;
          parameter Boolean linearLoads = false
            "Flag that selects between linearized or nonlinear load models";
          parameter Real L = 10 "Length of each cable";
          Modelica.Units.SI.Power Sloads=load1.S[1] + load2.S[1] + load3.S[1] + load4.S[
              1] + load5.S[1] + load6.S[1] + load7.S[1] + load8.S[1] + load9.S[1] +
              load10.S[1] "Sum of the power consumed by the loads";
          Line line(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L,
            terminal_n(v(each start=0))) "Transmission line"
            annotation (Placement(transformation(extent={{-2,70},{18,90}})));
          Sources.ConstantVoltage E(V=50) "Voltage source"
            annotation (Placement(transformation(extent={{-90,70},{-70,90}})));
          Line line1(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{-32,70},{-12,90}})));

          Line line2(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{-34,30},{-14,50}})));

          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-100,50},{-80,70}})));
          Loads.Conductor load1(mode=Types.Load.VariableZ_y_input,
            V_nominal=50,
            linearized=linearLoads,
            P_nominal=-150) "Load"
            annotation (Placement(transformation(extent={{30,70},{50,90}})));
          Loads.Conductor load2(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-120) "Load"
            annotation (Placement(transformation(extent={{30,50},{50,70}})));
          Loads.Conductor load3(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-200) "Load"
            annotation (Placement(transformation(extent={{30,30},{50,50}})));
          Modelica.Blocks.Sources.Trapezoid
                                       varLoad1(
            offset=0.4,
            amplitude=0.6,
            rising=600,
            width=1000,
            falling=800,
            period=3600,
            startTime=1800) "Power consumption profile"
            annotation (Placement(transformation(extent={{86,30},{66,50}})));
          Loads.Conductor load4(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-120) "Load"
            annotation (Placement(transformation(extent={{30,12},{50,32}})));
          Line line3(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,30},{22,50}})));

          Line line4(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{0,50},{20,70}})));

          Line line5(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,12},{22,32}})));

          Line line0(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{-64,70},{-44,90}})));

          Modelica.Blocks.Sources.Trapezoid
                                       varLoad2(
            startTime=1800,
            amplitude=0.8,
            rising=400,
            width=1300,
            falling=900,
            period=4000,
            offset=0.1) "Power consumption profile"
            annotation (Placement(transformation(extent={{86,70},{66,90}})));
          Line line6(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{-34,-10},{-14,10}})));

          Loads.Conductor load5(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-200) "Load"
            annotation (Placement(transformation(extent={{30,-10},{50,10}})));
          Modelica.Blocks.Sources.Trapezoid
                                       varLoad3(
            amplitude=0.7,
            rising=660,
            width=900,
            falling=300,
            period=3700,
            offset=0.3,
            startTime=200) "Power consumption profile"
            annotation (Placement(transformation(extent={{86,-10},{66,10}})));
          Loads.Conductor load6(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-120) "Load"
            annotation (Placement(transformation(extent={{30,-28},{50,-8}})));
          Line line7(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,-10},{22,10}})));

          Line line8(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,-28},{22,-8}})));

          Line line9(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{-34,-50},{-14,-30}})));

          Loads.Conductor load7(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-200) "Load"
            annotation (Placement(transformation(extent={{30,-50},{50,-30}})));
          Modelica.Blocks.Sources.Trapezoid
                                       varLoad4(
            rising=600,
            width=1000,
            falling=800,
            period=3600,
            amplitude=0.1,
            offset=0.8,
            startTime=3300) "Power consumption profile"
            annotation (Placement(transformation(extent={{86,-50},{66,-30}})));
          Loads.Conductor load8(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-120) "Load"
            annotation (Placement(transformation(extent={{30,-68},{50,-48}})));
          Line line10(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,-50},{22,-30}})));

          Line line11(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,-68},{22,-48}})));

          Line line12(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{-34,-90},{-14,-70}})));

          Loads.Conductor load9(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-200) "Load"
            annotation (Placement(transformation(extent={{30,-90},{50,-70}})));
          Modelica.Blocks.Sources.Trapezoid
                                       varLoad5(
            falling=800,
            amplitude=0.5,
            rising=800,
            width=800,
            period=3000,
            offset=0.5,
            startTime=0) "Power consumption profile"
            annotation (Placement(transformation(extent={{86,-90},{66,-70}})));
          Loads.Conductor load10(
            V_nominal=50,
            mode=Types.Load.VariableZ_y_input,
            linearized=linearLoads,
            P_nominal=-120) "Load"
            annotation (Placement(transformation(extent={{30,-108},{50,-88}})));
          Line line13(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=L) "Transmission line"
            annotation (Placement(transformation(extent={{2,-90},{22,-70}})));

          Line line14(
            P_nominal=500,
            V_nominal=50,
            mode=Types.CableMode.commercial,
            commercialCable=Transmission.LowVoltageCables.PvcAl16(),
            l=100) "Transmission line"
            annotation (Placement(transformation(extent={{2,-108},{22,-88}})));

        equation
          connect(load1.terminal, line.terminal_p) annotation (Line(
              points={{30,80},{18,80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line1.terminal_p, line.terminal_n) annotation (Line(
              points={{-12,80},{-2,80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line2.terminal_p, line3.terminal_n) annotation (Line(
              points={{-14,40},{2,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line3.terminal_p, load3.terminal) annotation (Line(
              points={{22,40},{30,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line1.terminal_p, line4.terminal_n) annotation (Line(
              points={{-12,80},{-6,80},{-6,60},{0,60}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line4.terminal_p, load2.terminal) annotation (Line(
              points={{20,60},{30,60}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(load4.terminal, line5.terminal_p) annotation (Line(
              points={{30,22},{22,22}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line5.terminal_n, line3.terminal_n) annotation (Line(
              points={{2,22},{-8,22},{-8,40},{2,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(E.terminal, line0.terminal_n) annotation (Line(
              points={{-70,80},{-64,80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line0.terminal_p, line1.terminal_n) annotation (Line(
              points={{-44,80},{-32,80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad1.y, load3.y) annotation (Line(
              points={{65,40},{50,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(varLoad1.y, load4.y) annotation (Line(
              points={{65,40},{58,40},{58,22},{50,22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(varLoad2.y, load1.y) annotation (Line(
              points={{65,80},{50,80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(varLoad2.y, load2.y) annotation (Line(
              points={{65,80},{58,80},{58,60},{50,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(line6.terminal_p,line7. terminal_n) annotation (Line(
              points={{-14,0},{2,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line7.terminal_p,load5. terminal) annotation (Line(
              points={{22,0},{30,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(load6.terminal,line8. terminal_p) annotation (Line(
              points={{30,-18},{22,-18}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line8.terminal_n,line7. terminal_n) annotation (Line(
              points={{2,-18},{-8,-18},{-8,0},{2,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad3.y,load5. y) annotation (Line(
              points={{65,0},{50,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(varLoad3.y,load6. y) annotation (Line(
              points={{65,0},{58,0},{58,-18},{50,-18}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(line9.terminal_p, line10.terminal_n)
                                                      annotation (Line(
              points={{-14,-40},{2,-40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line10.terminal_p, load7.terminal)
                                                    annotation (Line(
              points={{22,-40},{30,-40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(load8.terminal, line11.terminal_p)
                                                    annotation (Line(
              points={{30,-58},{22,-58}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line11.terminal_n, line10.terminal_n)
                                                      annotation (Line(
              points={{2,-58},{-8,-58},{-8,-40},{2,-40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad4.y,load7. y) annotation (Line(
              points={{65,-40},{50,-40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(varLoad4.y,load8. y) annotation (Line(
              points={{65,-40},{58,-40},{58,-58},{50,-58}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(line12.terminal_p, line13.terminal_n)
                                                      annotation (Line(
              points={{-14,-80},{2,-80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line13.terminal_p, load9.terminal)
                                                    annotation (Line(
              points={{22,-80},{30,-80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(load10.terminal, line14.terminal_p)
                                                    annotation (Line(
              points={{30,-98},{22,-98}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line14.terminal_n, line13.terminal_n)
                                                      annotation (Line(
              points={{2,-98},{-8,-98},{-8,-80},{2,-80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad5.y,load9. y) annotation (Line(
              points={{65,-80},{50,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(varLoad5.y, load10.y)
                                       annotation (Line(
              points={{65,-80},{58,-80},{58,-98},{50,-98}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(line2.terminal_n, line4.terminal_n) annotation (Line(
              points={{-34,40},{-34,60},{0,60}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line6.terminal_n, line3.terminal_n) annotation (Line(
              points={{-34,0},{-34,22},{-8,22},{-8,40},{2,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line9.terminal_n, line7.terminal_n) annotation (Line(
              points={{-34,-40},{-34,-18},{-8,-18},{-8,0},{2,0},{2,5.55112e-16}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(line12.terminal_n, line10.terminal_n) annotation (Line(
              points={{-34,-80},{-34,-58},{-8,-58},{-8,-40},{2,-40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(E.n, ground.p) annotation (Line(
              points={{-90,80},{-90,70}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (experiment(StopTime=4000,Tolerance=1e-06),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Lines/Examples/DCLines.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
This model shows a DC grid with 10 loads and 16 cables.
Each cable is of length <i>l = 10</i> meters, a parameter that can be modified.
Each load can be either be a full nonlinear model, or be replaced by the
linearized version. The parameter <code>linearLoads = false</code>
can be used to switch between linear and nonlinear implementation.
</p>
<p>
This model can be used to test how the linearized loads are affected by the voltage drop
caused by the lines. The longer the distance between the load and the source,
the bigger is the voltage drop and thus the error introduced by the linearization.
</p>
</html>"));
        end DCLines;

        model DCLinesLinearized
          "Example model to test the possible combinations between line and load models"
          extends ProsNet.Electrical.DC.Lines.Examples.DCLines(linearLoads=true);

          annotation (Documentation(info="<html>
<p>
This model is the linearized version of the model
<a href=\"modelica://Buildings.Electrical.DC.Lines.Examples.DCLines\">
Buildings.Electrical.DC.Lines.Examples.DCLines</a> and
can be used to test how the linearized loads are affected by the voltage drop
caused by the lines. The longer the distance between the load and the source,
the bigger is the voltage drop and thus the error introduced by the linearization.
</p>
</html>"),
        experiment(Tolerance=1e-06, StopTime=4000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Lines/Examples/DCLinesLinearized.mos"
                "Simulate and plot"));

        end DCLinesLinearized;

        model RCModel "Example model to test for the DC RC two port model"
          extends Modelica.Icons.Example;

          TwoPortRCLine RC_ss(
            C=1,
            V_nominal=50,
            R=8) "Line resistance"
                 annotation (Placement(transformation(extent={{-30,10},{-10,30}})));
          Sources.ConstantVoltage constantVoltage(V=50) "Voltage source"
            annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-72,-16},{-52,4}})));
          Loads.Resistor sc_ss(V_nominal=50, R=0) "Short circuit load"
            annotation (Placement(transformation(extent={{30,10},{50,30}})));
          Sensors.GeneralizedSensor sen_ss "Sensor"
            annotation (Placement(transformation(extent={{0,10},{20,30}})));
          TwoPortRCLine RC_dyn(
            C=1,
            V_nominal=50,
            use_C=true,
            R=8) "Line resistance"
                 annotation (Placement(transformation(extent={{-28,-20},{-8,0}})));
          Loads.Resistor sc_dyn(V_nominal=50, R=0) "Load"
            annotation (Placement(transformation(extent={{32,-20},{52,0}})));
          Sensors.GeneralizedSensor sen_dyn "Sensor"
            annotation (Placement(transformation(extent={{2,-20},{22,0}})));
        equation
          connect(ground.p, constantVoltage.n) annotation (Line(
              points={{-62,4},{-62,20},{-60,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(constantVoltage.terminal, RC_ss.terminal_n) annotation (Line(
              points={{-40,20},{-30,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(RC_ss.terminal_p, sen_ss.terminal_n) annotation (Line(
              points={{-10,20},{0,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen_ss.terminal_p, sc_ss.terminal) annotation (Line(
              points={{20,20},{30,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(RC_dyn.terminal_p, sen_dyn.terminal_n) annotation (Line(
              points={{-8,-10},{2,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen_dyn.terminal_p, sc_dyn.terminal) annotation (Line(
              points={{22,-10},{32,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(constantVoltage.terminal, RC_dyn.terminal_n) annotation (Line(
              points={{-40,20},{-34,20},{-34,-10},{-28,-10}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (
            __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Lines/Examples/RCModel.mos"
                "Simulate and plot"),
                experiment(StopTime=15.0,Tolerance=1e-06),
            Documentation(info="<html>
<p>
This model shows how to use a two port resistance-capacitance model.
The example also shows a comparison between the dynamic and steady state version model
that can be selected by changing the boolean flag <code>use_C</code>.
</p>
<p>
In this example the RC connects an ideal constant voltage source with
a short circuit. The steady state current value passing through the RC
model depends just on the value of <i>R</i>.
</p>
<p>
The RC model implement a T-model to represent the electric connection between the
two connectors (see <a href=\"modelica://Buildings.Electrical.DC.Lines.TwoPortRCLine\">
Buildings.Electrical.DC.Lines.TwoPortRCLine</a> for more details).
</p>
<p>
The capacitance <i>C</i> see an equivalent Thevenin's resistance that is equal to
<i>R<sub>EQ</sub> = 0.5 R</i> and thus the time constant associated to the capacitance is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&tau; = R<sub>EQ</sub> C = 0.5 R C = 2 seconds,
</p>
<p>
thus the duration of transient period is about 10 seconds.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added model, documentation and results for regression test.
</li>
</ul>
</html>"));
        end RCModel;

        model Resistance "Example model to test for the DC resistance two port model"
          extends Modelica.Icons.Example;

          TwoPortResistance lineR(R=10) "Line resistance"
            annotation (Placement(transformation(extent={{-30,10},{-10,30}})));
          Sources.ConstantVoltage constantVoltage(V=50) "Voltage source"
            annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-72,-16},{-52,4}})));
          Loads.Resistor short_circuit(V_nominal=50, R=0) "Short circuit load"
            annotation (Placement(transformation(extent={{30,10},{50,30}})));
          Sensors.GeneralizedSensor sen "Power sensor"
            annotation (Placement(transformation(extent={{0,10},{20,30}})));
        equation
          connect(ground.p, constantVoltage.n) annotation (Line(
              points={{-62,4},{-62,20},{-60,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(constantVoltage.terminal, lineR.terminal_n) annotation (Line(
              points={{-40,20},{-30,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lineR.terminal_p, sen.terminal_n) annotation (Line(
              points={{-10,20},{0,20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, short_circuit.terminal) annotation (Line(
              points={{20,20},{30,20}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation ( Documentation(info="<html>
<p>
This model shows how to use a two port resistance.
In this example the resistance connects an ideal constant voltage source with
a short circuit. The current flowing through the circuit depends just
on the value of the two port resistance.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added model, documentation and results for regression test.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-06, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Lines/Examples/Resistance.mos"
                "Simulate and plot"));
        end Resistance;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.DC.Lines\">
Buildings.Electrical.DC.Lines</a>.
</p>
</html>"));
      end Examples;
    annotation (Icon(graphics={
          Ellipse(
            extent={{40,8},{16,-28}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Line(
            points={{28,8},{-54,8},{-64,8},{-72,-10},{-64,-28},{-52,-28},{28,-28}},
            color={0,0,0},
            smooth=Smooth.Bezier),
          Line(
            points={{-70,-10},{-88,-10}},
            color={0,0,0},
            smooth=Smooth.None),
          Line(
            points={{54,-10},{28,-10}},
            color={0,0,0},
            smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package contains models for lines for DC circuits.
</p>
</html>"));
    end Lines;

    package Loads "Package with models for DC electrical loads"
      extends Modelica.Icons.VariantsPackage;

      model Conductor "Model of a generic DC load"
          extends ProsNet.Electrical.Interfaces.ResistiveLoad(redeclare package
            PhaseSystem = PhaseSystems.TwoConductor, redeclare
            Interfaces.Terminal_n terminal);
      protected
        Modelica.Units.SI.Voltage absDV
          "Absolute value of the voltage difference between the two conductors (used by the linearized model)";
      equation

        absDV = abs(terminal.v[1]-terminal.v[2]);

        if linearized then

          // Linearized version of the model
          if absDV <= (8/9)*V_nominal then
            terminal.i[1] + P*(2/(0.8*V_nominal) - (terminal.v[1]-terminal.v[2])/(0.8*V_nominal)^2) = 0;
          elseif absDV >= (12/11)*V_nominal then
            terminal.i[1] + P*(2/(1.2*V_nominal) - (terminal.v[1]-terminal.v[2])/(1.2*V_nominal)^2) = 0;
          else
            terminal.i[1] + P*(2/V_nominal - (terminal.v[1]-terminal.v[2])/V_nominal^2) = 0;
          end if;

        else
          // Full nonlinear version of the model
          // PhaseSystem.activePower(terminal.v, terminal.i) + P = 0;
          if initMode == ProsNet.Electrical.Types.InitMode.zero_current then
            i[1] = - homotopy(actual= P/(v[1] - v[2]),  simplified= 0);
          else
            i[1] = - homotopy(actual= P/(v[1] - v[2]),  simplified= P*(2/V_nominal - (v[1]-v[2])/V_nominal^2));
          end if;

        end if;

        // Since the connector is a two conductor, the sum of the currents at the terminal
        // is null
        sum(i) = 0;
        annotation (
          Documentation(info="<html>
<p>
Model of a generic DC load. The load can be either constant or variable depending on the value of the
parameter <code>mode</code>.
See the model <a href=\"modelica://Buildings.Electrical.Interfaces.Load\">Buildings.Electrical.Interfaces.Load</a>
for more information.
</p>

<p>
The model computes the current drawn from the load as
</p>
<p align=\"center\" style=\"font-style:italic;\">
P = V i,
</p>
<p>
where <i>P</i> is the power, <i>V</i> is the voltage and <i>i</i> is the current.<br/>
If the component consumes power, then <i>P &lt; 0</i>.
If it feeds power into the electrical grid, then <i>P &gt; 0</i>.
</p>

<h4>Linearization</h4>
<p>
Consider the simple DC circuit shown in the figure below
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Loads/simpleLoad.png\"/>
</p>
<p>
where <i>V<sub>S</sub></i> is a constant voltage source, and <i>R</i> is the line resistance.
The load has a voltage <i>V</i> across its electrical pins and a current <i>i</i> is flowing through it.
If the power consumption drawn by the load is prescribed by the variable <i>P<sub>LOAD</sub></i>,
 the equation that describes the circuit is
</p>
<p align=\"center\" style=\"font-style:italic;\">
V<sub>S</sub> - R i - P<sub>LOAD</sub>/i = 0
</p>
<p>
The unknown variable <i>i</i> appears in a nonlinear equation. This means that in order to compute the current
that is drawn by the load, a nonlinear equation has to be solved. If the number of loads increases (as typically
happens in real case examples) the number of nonlinear equations to be solved increases too, and the resulting system
of nonlinear equations can slow down the simulation. It is possible to avoid such a problem by introducing a linearized
model.
</p>

<p>
The first step to linearize the load model is to define its nominal voltage conditions <i>V<sub>nom</sub></i>,
around which the equations will be linearized.<br/>
The constitutive equation of the load can be linearized around the nominal voltage condition <i>V<sub>nom</sub></i> as
</p>

<p align=\"center\" style=\"font-style:italic;\">
i = P<sub>LOAD</sub>/V = P<sub>LOAD</sub>/V<sub>nom</sub> +
(V - V<sub>nom</sub>)[&part; (P<sub>LOAD</sub>/V)/ &part;V ]<sub>V = V<sub>nom</sub></sub>
+ &#8338;((V - V<sub>nom</sub>)<sup>2</sup>),
</p>

<p>
which leads to the linearized formulation
</p>

<p align=\"center\" style=\"font-style:italic;\">
i &#8771; P<sub>LOAD</sub> (2/V<sub>nom</sub> - V/V<sub>nom</sub><sup>2</sup>).
</p>

<p>
The linearized formulation approximates the load power consumption (or production),
with the approximation error being proportional to <i>(V - V<sub>nom</sub>)<sup>2</sup></i>.
A further approximation has been introduced to improve the
approximation of the linearized model even if the voltage is far from the nominal condition.
This piecewise linearized approximation instead of approximating the model just in the neighborhood of the nominal
voltage <i>V<sub>nom</sub></i> introduces two new points where the model is approximated.
The points are at <i>0.8 V<sub>nom</sub></i> and <i>1.2 V<sub>nom</sub></i>.
</p>

<table summary=\"equations\" border = \"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collape;\">
<tr><th>Equation</th><th>Condition</th></tr>
<tr>
<td>i &#8771; P<sub>LOAD</sub> (2/(0.8 V<sub>nom</sub>) - V/(0.8 V<sub>nom</sub><sup>2</sup>))</td>
<td>V &lt; 8/9&sdot; V<sub>nom</sub></td>
</tr>

<tr>
<td>i &#8771; P<sub>LOAD</sub> (2/(1.2  V<sub>nom</sub>) - V/(1.2 V<sub>nom</sub><sup>2</sup>))</td>
<td>V &ge; 12/11&sdot; V<sub>nom</sub></td>
</tr>

<tr>
<td>i &#8771; P<sub>LOAD</sub> (2/V<sub>nom</sub> - V/V<sub>nom</sub><sup>2</sup>)</td>
<td>Otherwise</td>
</tr>
</table>

</html>",       revisions="<html>
<ul>
<li>May 14, 2015, by Marco Bonvini:<br/>
Changed parent class to <a href=\"modelica://Buildings.Electrical.Interfaces.ResistiveLoad\">
Buildings.Electrical.Interfaces.ResistiveLoad</a> in order
to help openmodelica parsing the model. This fixes issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/415\">#415</a>.
</li>
<li>June 17, 2014, by Marco Bonvini:<br/>
Adde parameter <code>initMode</code> that can be used to
select the assumption to be used during initialization phase
by the homotopy operator.
</li>
<li>
February 1, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
<li>
January 2014, by Marco Bonvini:<br/>
Added linearized version of the model.
</li>
<li>
May 28, 2014, by Marco Bonvini:<br/>
Added and revised documentation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
                Rectangle(
                  extent={{-70,30},{70,-30}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Text(
                  extent={{-152,87},{148,47}},
                  textColor={0,0,0},
                textString="%name"),
                Text(
                  extent={{-144,-38},{142,-70}},
                  textColor={0,0,0},
                  textString="G=%G")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
                Line(points={{-96,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{96,0}}, color={0,0,255}),
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255})}));
      end Conductor;

      model Resistor "Ideal linear electrical resistor"
        extends ProsNet.Electrical.Interfaces.ResistiveLoad(
          redeclare package PhaseSystem = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_n terminal,
          final mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
          final P_nominal=V_nominal^2/max(R, Modelica.Constants.small));
        extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort(T = T_ref);
        parameter Modelica.Units.SI.Resistance R(start=1)
          "Resistance at temperature T_ref";
        parameter Modelica.Units.SI.Temperature T_ref=300.15 "Reference temperature";
        parameter Modelica.Units.SI.LinearTemperatureCoefficient alpha=0
          "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))";
        Modelica.Units.SI.Resistance R_actual
          "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))";
      equation
        assert((1 + alpha*(T_heatPort - T_ref)) >= Modelica.Constants.eps, "Temperature outside of scope of model");
        R_actual = R*(1 + alpha*(T_heatPort - T_ref));
        PhaseSystem.systemVoltage(v) = R_actual*PhaseSystem.systemCurrent(i);
        LossPower = PhaseSystem.activePower(v,i);
        sum(i) = 0;
        annotation (
          Documentation(info="<html>
<p>
Model of a linear DC resistor that can vary with respect to temperature.
</p>
<p>
The model implements the Ohm's law
</p>
<p align=\"center\" style=\"font-style:italic;\">
V = R(T) i.
</p>
<p>
The resistance <i>R(T)</i> varies depending on the temperature <i>T</i> as
</p>
<p align=\"center\" style=\"font-style:italic;\">
R(T) = R (1 + &alpha; (T - T<sub>ref</sub>)),
</p>
<p>
where the resistance <i>R</i> is the reference value of the resistance, <i>&alpha;</i> is the
linear temperature coefficient, and <i>T<sub>ref</sub></i> is the reference temperature.
The temperature <i>T</i> is the temperature of the heat port if <code>useHeatPort = true</code>.
</p>
</html>",
       revisions="<html>
<ul>
<li>November 3, 2015, by Michael Wetter:<br/>
Set default value for <code>P_nominal</code> to avoid an error when translating
the model in Dymola's pedantic mode.
</li>
<li>May 14, 2015, by Marco Bonvini:<br/>
Changed parent class to <a href=\"modelica://Buildings.Electrical.Interfaces.ResistiveLoad\">
Buildings.Electrical.Interfaces.ResistiveLoad</a> in order
to help openmodelica parsing the model. This fixes issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/415\">#415</a>.
</li>
<li>
February 1, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
<li>
May 28, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
                Rectangle(
                  extent={{-70,30},{70,-30}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Text(
                  extent={{-144,-40},{142,-72}},
                  textColor={0,0,0},
                textString="R=%R"),
                Line(
                  visible=useHeatPort,
                  points={{0,-100},{0,-30}},
                  color={127,0,0},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dot),
                Text(
                  extent={{-152,87},{148,47}},
                  textColor={0,0,0},
                textString="%name")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-96,0},{-70,0}}, color={0,0,255})}));
      end Resistor;

      package Examples "Package with example models"
      extends Modelica.Icons.ExamplesPackage;

        model LinearizedLoad "Example model to check the linearized load model"
          extends Modelica.Icons.Example;
          Real error = (sen_nlin.P - sen_lin.P)*100/sen_nlin.P
            "Percentage of error between the linearized and actual power consumption";
          Real deltaV = LinearLoad.V_nominal - sen_lin.V
            "Voltage distance between nominal condition and actual voltage";
          ProsNet.Electrical.DC.Loads.Conductor NonlinearLoad(
            linearized=false,
            mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            V_nominal=100,
            P_nominal=0) "Nonlinear load model"
            annotation (Placement(transformation(extent={{30,-40},{50,-20}})));
          Sources.ConstantVoltage sou(V=100) "Voltage source"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
          Modelica.Electrical.Analog.Basic.Ground gro "Ground"
            annotation (Placement(transformation(extent={{-100,-32},{-80,-12}})));
          Lines.TwoPortResistance Rline1(R=2) "Line resistance"
            annotation (Placement(transformation(extent={{-50,-40},{-30,-20}})));
          Sensors.GeneralizedSensor sen_nlin "Sensor"
            annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
          ProsNet.Electrical.DC.Loads.Conductor LinearLoad(
            mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            V_nominal=100,
            linearized=true,
            P_nominal=0) "Linearized load model"
            annotation (Placement(transformation(extent={{30,20},{50,40}})));
          Sensors.GeneralizedSensor sen_lin "Sensor"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          Lines.TwoPortResistance Rline2(R=2) "Line resistance"
            annotation (Placement(transformation(extent={{-50,20},{-30,40}})));
          Modelica.Blocks.Sources.Ramp ramp(
            duration=0.5,
            startTime=0.2,
            offset=-50,
            height=-950) "Power consumption"
            annotation (Placement(transformation(extent={{90,-10},{70,10}})));
        equation
          connect(sou.terminal, Rline1.terminal_n)
                                              annotation (Line(
              points={{-70,0},{-60,0},{-60,-30},{-50,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(Rline1.terminal_p, sen_nlin.terminal_n)
                                                  annotation (Line(
              points={{-30,-30},{-10,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen_nlin.terminal_p, NonlinearLoad.terminal)
                                                 annotation (Line(
              points={{10,-30},{30,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(LinearLoad.terminal, sen_lin.terminal_p)
                                                  annotation (Line(
              points={{30,30},{10,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, gro.p) annotation (Line(
              points={{-90,0},{-90,-12}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.terminal, Rline2.terminal_n) annotation (Line(
              points={{-70,0},{-60,0},{-60,30},{-50,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(Rline2.terminal_p, sen_lin.terminal_n)
                                                      annotation (Line(
              points={{-30,30},{-10,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(LinearLoad.Pow, ramp.y) annotation (Line(
              points={{50,30},{60,30},{60,6.66134e-16},{69,6.66134e-16}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(NonlinearLoad.Pow, ramp.y) annotation (Line(
              points={{50,-30},{60,-30},{60,6.66134e-16},{69,6.66134e-16}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (            experiment(StopTime=1.0, Tolerance=1e-06),
                    __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Loads/Examples/LinearizedLoad.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>This example demonstrates the use of a linealized load model <a href=\"modelica://Buildings.Electrical.DC.Loads.Conductor\">Buildings.Electrical.DC.Loads.Conductor</a>. </p>
<p>Both loads are connected to the same DC voltage source through a resistive element that represents a line. The loads consume the same amount of power that is specified by the input ramp signal. </p>
<p>The nonlinear conductor model <code>NonlinearLoad</code> consumes exactly the amount of power specified by the input <code>NonlinearLoad.Pow</code>. </p>
<p>The linearized conductor model <code>LinearizedLoad</code> does not consumes the amount of power specified by the input <code>LinearizedLoad.Pow</code>. The voltage at the load deviates from the nominal value when the power consumption increases. Since the model is approximated in a neighbor of the nominal voltage, moving from that point introduces approximation errors. The plot below shows the error introduced with such an approximation. </p>
<p align=\"center\"><img src=\"modelica://Buildings/Resources/Images/Electrical/DC/Loads/Examples/DCload_approx.png\" alt=\"image\"/> </p>
<p>The linearized load is tested over a voltage variation of about 30 % of the nominal voltage and within this range
the maximum error is 1.23457 % that occurs when the voltage deviation is 11.11 %.</p>
</html>",         revisions="<html>
<ul>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
August 16, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end LinearizedLoad;

        model Resistor "Example model for resistor"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Loads.Resistor res2(R=2, V_nominal=12)
            "Resistor"
            annotation (Placement(transformation(extent={{40,20},{60,40}})));
          Sources.ConstantVoltage sou(V=12) "Voltage source"
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          Modelica.Electrical.Analog.Basic.Ground gro "Ground"
            annotation (Placement(transformation(extent={{-90,-2},{-70,18}})));
          Lines.TwoPortResistance res(R=2) "Line resistance"
            annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
          Sensors.GeneralizedSensor sen "Sensor"
            annotation (Placement(transformation(extent={{0,20},{20,40}})));
          ProsNet.Electrical.DC.Loads.Resistor res1(R=2, V_nominal=12)
            "Resistor"
            annotation (Placement(transformation(extent={{40,50},{60,70}})));
          Sensors.GeneralizedSensor sen1 "Sensor"
            annotation (Placement(transformation(extent={{0,50},{20,70}})));
        equation
          connect(sou.terminal, res.terminal_n)
                                              annotation (Line(
              points={{-60,30},{-40,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(res.terminal_p, sen.terminal_n) annotation (Line(
              points={{-20,30},{0,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p,res2. terminal) annotation (Line(
              points={{20,30},{40,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(res1.terminal, sen1.terminal_p) annotation (Line(
              points={{40,60},{20,60}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen1.terminal_n, res.terminal_n) annotation (Line(
              points={{0,60},{-40,60},{-40,30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, gro.p) annotation (Line(
              points={{-80,30},{-80,18}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (            experiment(StopTime=1.0, Tolerance=1e-06),
                    __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Loads/Examples/Resistor.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
This example demonstrates the use of the resistor model.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 16, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Resistor;

        model VariableLoad "Example using variable loads models"
          extends Modelica.Icons.Example;
          Conductor loa1(
            V_nominal=12,
            linearized=false,
            P_nominal=-50) "Load"
            annotation (Placement(transformation(extent={{40,40},{60,60}})));
          Sources.ConstantVoltage sou(V=12) "Voltage source"
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          Modelica.Electrical.Analog.Basic.Ground gro "Ground"
            annotation (Placement(transformation(extent={{-90,-2},{-70,18}})));
          Conductor loa2(              mode=Types.Load.VariableZ_y_input,
            V_nominal=12,
            P_nominal=-50) "Load"
            annotation (Placement(transformation(extent={{0,0},{20,20}})));
          Modelica.Blocks.Sources.Ramp varLoad_y(
            height=0.8,
            duration=0.5,
            startTime=0.3,
            offset=0) "Power signal"
            annotation (Placement(transformation(extent={{60,0},{40,20}})));
          Conductor loa3(
            V_nominal=12,
            P_nominal=0,
            mode=ProsNet.Electrical.Types.Load.VariableZ_P_input)   "Load"
            annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          Modelica.Blocks.Sources.Ramp varLoad_P(
            duration=0.5,
            startTime=0.3,
            height=120,
            offset=-20) "Power signal"
            annotation (Placement(transformation(extent={{60,-40},{40,-20}})));
          Lines.TwoPortResistance res(R=0.1) "Line resistance"
            annotation (Placement(transformation(extent={{-32,40},{-12,60}})));
          Sensors.GeneralizedSensor sen "Sensor"
            annotation (Placement(transformation(extent={{0,40},{20,60}})));
        equation
          connect(sou.terminal, loa2.terminal)
                                              annotation (Line(
              points={{-60,30},{-40,30},{-40,10},{-4.44089e-16,10}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad_y.y, loa2.y)  annotation (Line(
              points={{39,10},{20,10}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sou.terminal, loa3.terminal)
                                              annotation (Line(
              points={{-60,30},{-40,30},{-40,-30},{-4.44089e-16,-30}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(varLoad_P.y, loa3.Pow)  annotation (Line(
              points={{39,-30},{20,-30}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sou.terminal, res.terminal_n)
                                              annotation (Line(
              points={{-60,30},{-40,30},{-40,50},{-32,50}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(res.terminal_p, sen.terminal_n) annotation (Line(
              points={{-12,50},{0,50}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, loa1.terminal) annotation (Line(
              points={{20,50},{40,50}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, gro.p) annotation (Line(
              points={{-80,30},{-80,18}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (            experiment(StopTime=1.0, Tolerance=1e-06),
                    __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Loads/Examples/VariableLoad.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
This example shows how to use three different types of load models.
Each load is of type <a href=\"modelica://Buildings.Electrical.DC.Loads.Conductor\">
Buildings.Electrical.DC.Loads.Conductor</a>.
</p>
<p>
The first load <code>loa1</code>consumes a constant amount of power.
The second and the third loads (<code>loa2</code> and <code>loa3</code>) consume a variable amount of power.
The load <code>loa2</code> has a variable input <code>y</code> between 0 and 1 that specifies the portion of
nominal power that is consumed.
The load <code>loa3</code> has a variable input <code>Pow</code> that represents the actual power consumed
(or produced) by the load.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end VariableLoad;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.DC.Loads\">
Buildings.Electrical.DC.Loads</a>.
</p>
</html>"));
      end Examples;
    annotation (Documentation(info="<html>
<p>
This package contains models that represent different types of DC loads.
</p>
</html>"));
    end Loads;

    package Sensors "Package with sensors for DC electrical systems"
    extends Modelica.Icons.SensorsPackage;

      model GeneralizedSensor "Sensor for power, voltage and current"
        extends ProsNet.Electrical.Icons.GeneralizedSensor;
        extends ProsNet.Electrical.Interfaces.PartialTwoPort(
          redeclare package PhaseSystem_p = PhaseSystems.TwoConductor,
          redeclare package PhaseSystem_n = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_n terminal_n,
          redeclare Interfaces.Terminal_p terminal_p);
        Modelica.Blocks.Interfaces.RealOutput V(final quantity="ElectricPotential",
                                                final unit="V") "Voltage"
          annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-50}),   iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,-90})));
        Modelica.Blocks.Interfaces.RealOutput I(final quantity="ElectricCurrent",
                                                final unit="A") "Current"
          annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={60,-50}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={60,-90})));
        Modelica.Blocks.Interfaces.RealOutput P(
          final quantity="Power",
          final unit="W") "Power" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={-60,-50}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={-60,-90})));
      equation
        Connections.branch(terminal_p.theta, terminal_n.theta);
        terminal_p.theta = terminal_n.theta;

        V = ProsNet.Electrical.PhaseSystems.TwoConductor.systemVoltage(
          terminal_n.v);
        I = ProsNet.Electrical.PhaseSystems.TwoConductor.systemCurrent(
          terminal_n.i);
        P = ProsNet.Electrical.PhaseSystems.TwoConductor.activePower(v=
          terminal_n.v, i=terminal_n.i);

        connect(terminal_n, terminal_p) annotation (Line(
            points={{-100,0},{100,0}},
            color={0,0,255},
            smooth=Smooth.None));

        annotation (defaultComponentName="sen",
        Documentation(info="<html>
<p>
Ideal sensor that measures power, voltage and current.
The two components of the power <i>S</i> are the active and reactive power.
As this sensor is configured to measure DC power, the reactive power is always zero.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 12, 2019, by Michael Wetter:<br/>
Removed wrong use of <code>each</code>.
</li>
<li>
March 19, 2015, by Michael Wetter:<br/>
Removed redeclaration of phase system in <code>Terminal_n</code> and
<code>Terminal_p</code> as it is already declared to the be the same
phase system, and it is not declared to be replaceable.
This avoids a translation error in OpenModelica.
</li>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={
              Text(
                extent={{-120,-42},{0,-82}},
                textColor={0,0,0},
                lineThickness=1,
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="P")}));
      end GeneralizedSensor;

      package Examples "Collection of models that illustrate model use and test models"
        extends Modelica.Icons.ExamplesPackage;

        model GeneralizedSensor "Example model for generalized sensor"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor sen "Power sensor"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
          ProsNet.Electrical.DC.Loads.Conductor loa(V_nominal=120, P_nominal=
                120) "Constant load"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          ProsNet.Electrical.DC.Sources.ConstantVoltage sou(V=120)
            "Voltage source"
            annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-60,-32},{-40,-12}})));
        equation
          connect(sen.terminal_p, loa.terminal)
            annotation (Line(points={{10,0},{40,0}},            smooth=Smooth.None));
          connect(sen.terminal_n, sou.terminal)
            annotation (Line(points={{-10,0},{-30,0}},   smooth=Smooth.None));
          connect(sou.n, ground.p) annotation (Line(
              points={{-50,0},{-50,-12}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation ( experiment(StopTime=1.0,Tolerance=1e-06),
          Documentation(
          info="<html>
<p>
This example illustrates the use of the generalized sensor.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Sensors/Examples/GeneralizedSensor.mos"
                "Simulate and plot"));
        end GeneralizedSensor;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.DC.Sensors\">
Buildings.Electrical.DC.Sensors</a>.
</p>
</html>"));
      end Examples;
    annotation (Documentation(info="<html>
<p>
This package contains models for sensors for DC circuits.
</p>
</html>"));
    end Sensors;

    package Sources "Package with models for DC sources"
      extends Modelica.Icons.SourcesPackage;

      model ConstantVoltage "Model of a constant DC voltage source"
        extends ProsNet.Electrical.Interfaces.Source(
          redeclare package PhaseSystem = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_p terminal,
          final potentialReference=true,
          final definiteReference=false);
        parameter Modelica.Units.SI.Voltage V(start=1) "Value of constant voltage";
        Modelica.Electrical.Analog.Interfaces.NegativePin n "Negative pin"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
      equation
        terminal.v[1] = V;
        terminal.v[2] = n.v;
        sum(terminal.i) + n.i = 0;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(points={{-40,0},{40,0}},  color={0,0,0},
                origin={10,0},
                rotation=90),
              Line(points={{0,26},{0,-54}},     color={0,0,0},
                origin={36,0},
                rotation=90),
              Line(points={{0,46},{0,-34}}, color={0,0,0},
                origin={-44,0},
                rotation=90),
              Line(points={{-20,0},{20,0}},
                                          color={0,0,0},
                origin={-10,0},
                rotation=90),
              Text(
                extent={{50,70},{150,20}},
                textColor={0,0,0},
                textString="+"),
              Text(
                extent={{50,-12},{150,-62}},
                textColor={0,0,0},
                textString="-"),
              Text(
                extent={{-150,60},{150,100}},
                textColor={0,0,0},
                textString="V=%V")}),    Documentation(info="<html>
<p>
This model represents a simple DC voltage source with constant voltage.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 3, 2014, by Michael Wetter:<br/>
Set <code>final potentialReference=true</code> and
<code>final definiteReference=false</code> as this
model is for a DC voltage.
</li>
<li>
June 6, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
      end ConstantVoltage;

      model PVSimple "Simple PV model"
        extends ProsNet.Electrical.Interfaces.PartialPV(redeclare package
            PhaseSystem = PhaseSystems.TwoConductor, redeclare
            Interfaces.Terminal_p terminal);
      protected
         Loads.Conductor con(
          mode=Types.Load.VariableZ_P_input,
          V_nominal=V_nominal)
          "Conductor, used to interface power with electrical circuit"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
      equation
        connect(con.terminal, terminal)  annotation (Line(
            points={{-10,0},{-100,0}},
            color={0,0,255},
            smooth=Smooth.None));

        connect(solarPower.y, con.Pow) annotation (Line(
            points={{70,0},{10,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(P, solarPower.y) annotation (Line(points={{110,70},{60,70},{60,0},{70,
                0}}, color={0,0,127}));
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Line(points={{-90,0},{-59,0}}, color={0,0,0}),
              Text(
                extent={{-150,61},{-50,11}},
                textColor={0,0,0},
                textString="+"),
              Text(
                extent={{-150,-12},{-50,-62}},
                textColor={0,0,0},
                textString="-")}),
          Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
January 4, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",     info="<html>
<p>
Model of a simple photovoltaic array.
</p>
<p>
This model computes the power as
</p>

<p align=\"center\" style=\"font-style:italic;\">
P=A &nbsp; f<sub>act</sub> &nbsp; &eta; &nbsp; G
</p>

<p>
where <i>A</i> is the panel area, <i>f<sub>act</sub></i> is the fraction of the aperture area,
<i>&eta;</i> is the panel efficiency and <i>G</i> is the total solar irradiation.
This power is equal to <i>P = v &nbsp; i</i>, where <i>v</i> is the voltage across the panel and
<i>i</i> is the current that flows through the panel.
</p>
<p>
To avoid a large voltage drop the panel electric connector, it is recommended to use this model together
with a model that prescribes the voltage.
See
<a href=\"modelica://Buildings.Electrical.DC.Sources.Examples.PVSimple\">
Buildings.Electrical.DC.Sources.Examples.PVSimple</a>.
</p>
<p>
<b>Note:</b> This model takes as input the total solar irradiation on the panel. This has to be
computed converting the incoming radiation to take tilt and azimuth into account.
</p>
</html>"));
      end PVSimple;

      model PVSimpleOriented "Simple PV model with orientation"
        extends ProsNet.Electrical.Interfaces.PartialPVOriented(
          redeclare package PhaseSystem = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_p terminal,
          redeclare ProsNet.Electrical.DC.Sources.PVSimple panel(V_nominal=
                V_nominal));

        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Line(points={{-90,0},{-59,0}}, color={0,0,0}),
              Text(
                extent={{-150,61},{-50,11}},
                textColor={0,0,0},
                textString="+"),
              Text(
                extent={{-150,-12},{-50,-62}},
                textColor={0,0,0},
                textString="-")}),
          Documentation(revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",
      info="<html>
<p>
Model of a simple photovoltaic array.
</p>
<p>
This model computes the power as
</p>

<p align=\"center\" style=\"font-style:italic;\">
P=A &nbsp; f<sub>act</sub> &nbsp; &eta; &nbsp; G
</p>

<p>
where <i>A</i> is the panel area,
<i>f<sub>act</sub></i> is the fraction of the aperture area,
<i>&eta;</i> is the panel efficiency and
<i>G</i> is the total solar irradiation, which is the sum
of direct and diffuse irradiation.
The model takes into account the location and the orientation of the PV panel,
specified by the surface tilt, latitude and azimuth.
</p>
<p>
This power is equal to <i>P = v &nbsp; i</i>,
where <i>v</i> is the voltage across the panel and
<i>i</i> is the current that flows through the panel.
</p>
<p>
To avoid a large voltage drop the panel electric connector,
it is recommended to use this model together
with a model that prescribes the voltage.
See
<a href=\"modelica://Buildings.Electrical.DC.Sources.Examples.PVSimpleOriented\">
Buildings.Electrical.DC.Sources.Examples.PVSimpleOriented</a>.
</p>
<p>
This model takes as an input the direct and diffuse solar radiation from
the weather data bus.
</p>
</html>"));
      end PVSimpleOriented;

      model VoltageSource "Model of a generoic DC voltage source"
        extends ProsNet.Electrical.Interfaces.VariableVoltageSource(
          V(start=1),
          redeclare package PhaseSystem = PhaseSystems.TwoConductor,
          redeclare Interfaces.Terminal_p terminal,
          final potentialReference=true,
          final definiteReference=false);
        Modelica.Electrical.Analog.Interfaces.NegativePin n "Negative pin"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
      equation
        terminal.v[1] = V_in_internal;
        terminal.v[2] = n.v;
        sum(terminal.i) + n.i = 0;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(points={{-40,0},{40,0}},  color={0,0,0},
                origin={10,0},
                rotation=90),
              Line(points={{0,26},{0,-54}},     color={0,0,0},
                origin={36,0},
                rotation=90),
              Line(points={{0,46},{0,-34}}, color={0,0,0},
                origin={-44,0},
                rotation=90),
              Line(points={{-20,0},{20,0}},
                                          color={0,0,0},
                origin={-10,0},
                rotation=90),
              Text(
                extent={{50,70},{150,20}},
                textColor={0,0,0},
                textString="+"),
              Text(
                extent={{50,-12},{150,-62}},
                textColor={0,0,0},
                textString="-"),
              Text(visible = not use_V_in,
                extent={{-150,60},{150,100}},
                textColor={0,0,0},
                textString="V=%V")}),    Documentation(info="<html>
<p>
This model represents a simple DC voltage source with variable voltage.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 14, 2014, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>"));
      end VoltageSource;

      model WindTurbine
        "Wind turbine with power output based on table as a function of wind speed"
        extends ProsNet.Electrical.Interfaces.PartialWindTurbine(redeclare
            package PhaseSystem = ProsNet.Electrical.PhaseSystems.TwoConductor,
            redeclare ProsNet.Electrical.DC.Interfaces.Terminal_p terminal);
      protected
        Loads.Conductor con(
          mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
          V_nominal=V_nominal)
          "Conductor, used to interface the power with the electrical circuit"
          annotation (Placement(transformation(extent={{60,-10},{80,10}})));
      equation
        connect(con.terminal, terminal) annotation (Line(
            points={{60,6.66134e-16},{-20,6.66134e-16},{-20,0},{-100,0}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(gain.y, con.Pow) annotation (Line(
            points={{23,30},{94,30},{94,6.66134e-16},{80,6.66134e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Text(
                extent={{-150,70},{-50,20}},
                textColor={0,0,0},
                textString="+"),
              Text(
                extent={{-150,-12},{-50,-62}},
                textColor={0,0,0},
                textString="-")}),
          Documentation(info="<html>
<p>
Model of a wind turbine whose power is computed as a function of wind-speed as defined in a table.
</p>
<p>
Input to the model is the local wind speed.
The model requires the specification of a table that maps wind speed in meters per second to generated
power <i>P<sub>t</sub></i> in Watts.
The model has a parameter called <code>scale</code> with a default value of one
that can be used to scale the power generated by the wind turbine.
The generated DC electrical power is
</p>
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>t</sub> scale = v i,
</p>
<p>
where <i>v</i> is the voltage and <i>i</i> is the current.
For example, the following specification (with default <code>scale=1</code>) of a wind turbine
</p>
<pre>
  WindTurbine_Table tur(
    table=[3.5, 0;
           5.5,   100;
           12, 900;
           14, 1000;
           25, 1000]) \"Wind turbine\";
</pre>
<p>
yields the performance shown below. In this example, the cut-in wind speed is <i>3.5</i> meters per second,
and the cut-out wind speed is <i>25</i> meters per second,
as entered by the first and last entry of the wind speed column.
Below and above these wind speeds, the generated power is zero.
</p>
<p align=\"center\">
<img alt=\"alt-image\"  src=\"modelica://Buildings/Resources/Images/Electrical/DC/Sources/WindTurbine_Table.png\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end WindTurbine;

      package Examples "Package with example models"
        extends Modelica.Icons.ExamplesPackage;

        model PVSimple "Example for the PVSimple model with constant load"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Sources.PVSimple pv(A=10, V_nominal=12)
            "PV module" annotation (Placement(transformation(extent={{-10,-10},
                    {10,10}}, origin={50,40})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-92,-40},{-72,-20}})));
          ProsNet.Electrical.DC.Loads.Resistor res(R=0.5, V_nominal=12)
            "Resistance"
            annotation (Placement(transformation(extent={{-2,-10},{18,10}})));
          ProsNet.Electrical.DC.Sources.ConstantVoltage sou(V=12)
            "Voltage source"
            annotation (Placement(transformation(extent={{-82,-10},{-62,10}})));
          Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(til=
                0.34906585039887, azi=-0.78539816339745)
                                   "Diffuse irradiation on tilted surface"
            annotation (Placement(transformation(extent={{-80,90},{-60,110}})));
          Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(til=
                0.34906585039887, azi=-0.78539816339745)
                                   "Direct irradiation on tilted surface"
            annotation (Placement(transformation(extent={{-80,50},{-60,70}})));
          Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
              computeWetBulbTemperature=false,
              filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            annotation (Placement(transformation(extent={{-128,90},{-108,110}})));
          Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
            annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
          ProsNet.Electrical.DC.Lines.TwoPortResistance lin(R=0.05)
            "Transmission line"
            annotation (Placement(transformation(extent={{-38,30},{-18,50}})));
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor sen "Sensor"
            annotation (Placement(transformation(extent={{0,30},{20,50}})));
        equation
          connect(weaDat.weaBus, HDifTil.weaBus) annotation (Line(
              points={{-108,100},{-80,100}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(weaDat.weaBus, HDirTil.weaBus) annotation (Line(
              points={{-108,100},{-94,100},{-94,60},{-80,60}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(HDifTil.H, G.u1) annotation (Line(
              points={{-59,100},{-52,100},{-52,86},{-42,86}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil.H, G.u2) annotation (Line(
              points={{-59,60},{-52,60},{-52,74},{-42,74}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(G.y, pv.G) annotation (Line(
              points={{-19,80},{50,80},{50,52}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sou.terminal, res.terminal) annotation (Line(
              points={{-62,0},{-2,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lin.terminal_n, res.terminal) annotation (Line(
              points={{-38,40},{-50,40},{-50,0},{-2,0},{-2,5.55112e-16}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lin.terminal_p, sen.terminal_n) annotation (Line(
              points={{-18,40},{-4.44089e-16,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, pv.terminal) annotation (Line(
              points={{20,40},{40,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, ground.p) annotation (Line(
              points={{-82,0},{-82,-20}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,
                    -100},{100,140}}),      graphics),
            experiment(StopTime=172800, Tolerance=1e-6),
        Documentation(info="<html>
<p>
This model illustrates the use of the photovoltaic model.
The total solar irradiation is computed based
on a weather data file.
The PV is connected to a circuit that has a constant voltage
source and a resistance.
This voltage source may be a DC grid to which the
circuit is connected.
The power sensor shows how much electrical power is consumed or fed into the voltage source.
In actual systems, the voltage source may be an AC/DC converter.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed assignment of parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
January 4, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Sources/Examples/PVSimple.mos"
                "Simulate and plot"),
            Icon(coordinateSystem(extent={{-140,-100},{100,140}})));
        end PVSimple;

        model PVSimpleOriented
          "Example for the PVSimpleOriented model with constant load"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Sources.PVSimpleOriented pv(
            A=10,
            V_nominal=12,
            til=0.34906585039887,
            azi=-0.78539816339745) "PV module" annotation (Placement(
                transformation(extent={{-10,-10},{10,10}}, origin={50,40})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-92,-40},{-72,-20}})));
          ProsNet.Electrical.DC.Loads.Resistor res(R=0.5, V_nominal=12)
            "Resistance"
            annotation (Placement(transformation(extent={{-2,-10},{18,10}})));
          ProsNet.Electrical.DC.Sources.ConstantVoltage sou(V=12)
            "Voltage source"
            annotation (Placement(transformation(extent={{-82,-10},{-62,10}})));
          Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
              computeWetBulbTemperature=false, filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            annotation (Placement(transformation(extent={{-128,90},{-108,110}})));
          ProsNet.Electrical.DC.Lines.TwoPortResistance lin(R=0.05)
            "Transmission line"
            annotation (Placement(transformation(extent={{-38,30},{-18,50}})));
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor sen "Sensor"
            annotation (Placement(transformation(extent={{0,30},{20,50}})));
        equation
          connect(sou.terminal, res.terminal) annotation (Line(
              points={{-62,0},{-2,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lin.terminal_n, res.terminal) annotation (Line(
              points={{-38,40},{-50,40},{-50,0},{-2,0},{-2,5.55112e-16}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lin.terminal_p, sen.terminal_n) annotation (Line(
              points={{-18,40},{-4.44089e-16,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, pv.terminal) annotation (Line(
              points={{20,40},{40,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, ground.p) annotation (Line(
              points={{-82,0},{-82,-20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(weaDat.weaBus, pv.weaBus) annotation (Line(
              points={{-108,100},{50,100},{50,49}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,
                    -100},{100,140}}),      graphics),
            experiment(StopTime=172800, Tolerance=1e-6),
        Documentation(info="<html>
<p>
This model illustrates the use of the photovoltaic model.
The total solar irradiation is computed internally by the PV
model through a connection to the weather bus.
The PV is connected to a circuit that has a constant voltage
source and a resistance.
This voltage source may be a DC grid to which the
circuit is connected.
The power sensor shows how much electrical power is consumed or fed into the voltage source.
In actual systems, the voltage source may be an AC/DC converter.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed assignment of parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"),  __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Sources/Examples/PVSimpleOriented.mos"
                "Simulate and plot"),
            Icon(coordinateSystem(extent={{-140,-100},{100,140}})));
        end PVSimpleOriented;

        model VoltageSource "Example for the variable voltage source model"
          extends Modelica.Icons.Example;
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-92,-40},{-72,-20}})));
          ProsNet.Electrical.DC.Loads.Resistor res(R=0.5, V_nominal=12)
            "Resistance"
            annotation (Placement(transformation(extent={{26,-10},{46,10}})));
          ProsNet.Electrical.DC.Sources.VoltageSource sou "Voltage source"
            annotation (Placement(transformation(extent={{-82,-10},{-62,10}})));
          ProsNet.Electrical.DC.Lines.TwoPortResistance lin(R=0.5)
            "Transmission line"
            annotation (Placement(transformation(extent={{-52,-10},{-32,10}})));
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor sen "Sensor"
            annotation (Placement(transformation(extent={{-14,-10},{6,10}})));
          Modelica.Blocks.Sources.Sine cosine(
            phase=0,
            f=1,
            offset=12,
            amplitude=3) "Variable voltage signal"
            annotation (Placement(transformation(extent={{-120,-4},{-100,16}})));
        equation
          connect(lin.terminal_p, sen.terminal_n) annotation (Line(
              points={{-32,0},{-14,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, ground.p) annotation (Line(
              points={{-82,0},{-82,-20}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, res.terminal) annotation (Line(
              points={{6,0},{26,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.terminal, lin.terminal_n) annotation (Line(
              points={{-62,0},{-52,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(cosine.y, sou.V_in) annotation (Line(
              points={{-99,6},{-82,6}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,
                    -100},{100,140}}),      graphics),
            experiment(StopTime=1, Tolerance=1e-6),
        Documentation(info="<html>
<p>
This model illustrates the use of the variable voltage source model.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 14, 2012, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>"),  __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Sources/Examples/VoltageSource.mos"
                "Simulate and plot"),
            Icon(coordinateSystem(extent={{-140,-100},{100,140}})));
        end VoltageSource;

        model WindTurbine "Example for the WindTurbine model"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Sources.WindTurbine tur(
            table=[3.5,0; 5.5,100; 12,900; 14,1000; 25,1000],
            h=10,
            V_nominal=12) "Wind turbine" annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}}, origin={50,40})));
          Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
              computeWetBulbTemperature=false, filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            annotation (Placement(transformation(extent={{-62,76},{-42,96}})));
          Buildings.BoundaryConditions.WeatherData.Bus weaBus
            annotation (Placement(transformation(extent={{6,76},{26,96}})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{-90,-20},{-70,0}})));
          ProsNet.Electrical.DC.Loads.Resistor res(R=0.5, V_nominal=12)
            "Resistance"
            annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
          ProsNet.Electrical.DC.Sources.ConstantVoltage sou(V=12)
            "Voltage source"
            annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
          ProsNet.Electrical.DC.Lines.TwoPortResistance lin(R=0.05)
            "Transmission line"
            annotation (Placement(transformation(extent={{-32,30},{-12,50}})));
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor sen "Sensor"
            annotation (Placement(transformation(extent={{-2,30},{18,50}})));
        equation
          connect(weaDat.weaBus,weaBus)  annotation (Line(
              points={{-42,86},{16,86}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(weaBus.winSpe,tur. vWin) annotation (Line(
              points={{16,86},{50,86},{50,52}},
              color={255,204,51},
              thickness=0.5,
              smooth=Smooth.None));
          connect(sou.terminal, res.terminal) annotation (Line(
              points={{-60,20},{-40,20},{-40,0},{-20,0}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lin.terminal_n, res.terminal) annotation (Line(
              points={{-32,40},{-40,40},{-40,0},{-20,0},{-20,5.55112e-16}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(lin.terminal_p, sen.terminal_n) annotation (Line(
              points={{-12,40},{-2,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sen.terminal_p, tur.terminal) annotation (Line(
              points={{18,40},{40,40}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, ground.p) annotation (Line(
              points={{-80,20},{-80,0}},
              color={0,0,255},
              smooth=Smooth.None));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-140,
                    -100},{100,140}}),      graphics),
            experiment(StopTime=172800, Tolerance=1e-6),
        Documentation(info="<html>
<p>
This model illustrates the use of the wind turbine model which is connected to a DC voltage source and a resistance.
This voltage source may be a DC grid to which the
circuit is connected.
Wind data for San Francisco, CA, are used.
The turbine cut-in wind speed is <i>3.5</i> m/s,
and hence it is off in the first day when the wind speed is low.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 29, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"),  __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Sources/Examples/WindTurbine.mos"
                "Simulate and plot"),
            Icon(coordinateSystem(extent={{-140,-100},{100,140}})));
        end WindTurbine;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.DC.Sources\">
Buildings.Electrical.DC.Sources</a>.
</p>
</html>"));
      end Examples;

      package BaseClasses "Package with base classes for DC sources"
        extends Modelica.Icons.BasesPackage;

        block WindCorrection "Block for wind correction"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.Units.SI.Height h "Height over ground";
          parameter Modelica.Units.SI.Height hRef
            "Reference height for wind measurement";
          parameter Real n(min=0) = 0.4 "Height exponent for wind profile calculation";
          Modelica.Blocks.Interfaces.RealOutput vLoc( unit="m/s")
            "Wind velocity at the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput vRef(unit="m/s")
            "Wind velocity at the reference height"
            annotation (Placement(transformation(extent={{-120,-10},{-100,10}}),
                iconTransformation(extent={{-142,-20},{-102,20}})));
        equation
          vLoc=vRef * (h / hRef)^n;
          annotation (
          defaultComponentName = "cor",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
                Text(
                  extent={{-92,48},{-32,-50}},
                  textColor={0,128,255},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  textString="vRef"),
                Polygon(
                  points={{26,0},{6,20},{6,10},{-24,10},{-24,-10},{6,-10},{6,-20},{26,0}},
                  lineColor={0,128,255},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{30,50},{90,-48}},
                  textColor={0,128,0},
                  fillColor={85,170,255},
                  fillPattern=FillPattern.Solid,
                  textString="vLoc")}),Documentation(info="<html>
<p>
This model calculates the wind velocity at the location as a function of the height over ground.
The equation is based on Gash (1991).

The model computes the wind velocity <i>vLoc</i> as
</p>

<p align=\"center\" style=\"font-style:italic;\">
vLoc = vRef * (h / hRef)<sup>n</sup>
</p>

<p>
where <i>vRef</i> is the wind velocity at the reference height, <i>h</i> is the height over ground, <i>hRef</i>
is the reference height, and <i>n</i> is the height exponent for wind calculation.
</p>
<h4>Reference</h4>
<p>
Gasch, R. 1991. Windkraftanlagen. Grundlagen und Entwurf (German). Teubner, Stuttgart.
</p>
</html>",
        revisions="<html>
<ul>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
February 7, 2013, by Michael Wetter:<br/>
Removed <code>final</code> keyword for parameters to allow users to adjust them,
and removed default value for <code>h</code>.
</li>
<li>
February 1, 2013, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
        end WindCorrection;
      annotation (Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Electrical.DC.Sources\">Buildings.Electrical.DC.Sources</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models that represent different types of DC sources.
</p>
</html>"));
    end Sources;

    package Storage "Package with models for DC electrical storage"
      extends Modelica.Icons.Package;

      model Battery "Simple model of a battery"
        parameter Modelica.Units.SI.Efficiency etaCha(max=1) = 0.9
          "Efficiency during charging";
        parameter Modelica.Units.SI.Efficiency etaDis(max=1) = 0.9
          "Efficiency during discharging";
       parameter Real SOC_start(min=0, max=1, unit="1")=0.1 "Initial state of charge";
        parameter Modelica.Units.SI.Energy EMax(min=0, displayUnit="kW.h")
          "Maximum available charge";
        parameter Modelica.Units.SI.Voltage V_nominal
          "Nominal voltage (V_nominal >= 0)";
       Modelica.Blocks.Interfaces.RealInput P(unit="W")
          "Power stored in battery (if positive), or extracted from battery (if negative)"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=270,
              origin={0,108}),
              iconTransformation(extent={{-20,-20},{20,20}},
              rotation=270,
              origin={0,100})));
        Modelica.Blocks.Interfaces.RealOutput SOC(min=0, max=1, unit="1")
          "State of charge"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        ProsNet.Electrical.DC.Interfaces.Terminal_p terminal
          "Generalized terminal"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
      protected
        ProsNet.Electrical.DC.Storage.BaseClasses.Charge cha(
          final EMax=EMax,
          final SOC_start=SOC_start,
          final etaCha=etaCha,
          final etaDis=etaDis) "Charge model"
          annotation (Placement(transformation(extent={{40,50},{60,70}})));
        Loads.Conductor bat(
          final mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
          final V_nominal=V_nominal) "Power exchanged with battery pack"
          annotation (Placement(transformation(extent={{40,-10},{60,10}})));
        Modelica.Blocks.Math.Gain gain(final k=-1)
          annotation (Placement(transformation(extent={{22,10},{42,30}})));

      equation
        connect(cha.SOC, SOC)    annotation (Line(
            points={{61,60},{110,60}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cha.P, P)    annotation (Line(
            points={{38,60},{0,60},{0,108},{8.88178e-16,108}},
            color={0,0,127},
            smooth=Smooth.None));

        connect(bat.terminal, terminal) annotation (Line(
            points={{40,0},{-100,0}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(P, gain.u) annotation (Line(
            points={{8.88178e-16,108},{8.88178e-16,20},{20,20}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gain.y, bat.Pow) annotation (Line(
            points={{43,20},{68,20},{68,8.88178e-16},{60,8.88178e-16}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Polygon(
                points={{-62,40},{-62,-40},{72,-40},{72,40},{-62,40}},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Polygon(
                points={{58,32},{58,-30},{32,-30},{10,32},{58,32}},
                smooth=Smooth.None,
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-34,32},{-12,-30},{-32,-30},{-54,32},{-34,32}},
                smooth=Smooth.None,
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-2,32},{20,-30},{0,-30},{-22,32},{-2,32}},
                smooth=Smooth.None,
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={0,127,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-74,12},{-74,-12},{-62,-12},{-62,12},{-74,12}},
                smooth=Smooth.None,
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Text(
                extent={{-50,68},{-20,100}},
                textColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                textString="P"),
              Line(
                points={{-74,0},{-100,0},{-100,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Text(
                extent={{-150,70},{-50,20}},
                textColor={0,0,0},
                textString="+"),
              Text(
                extent={{-150,-12},{-50,-62}},
                textColor={0,0,0},
                textString="-"),
              Text(
                extent={{44,70},{100,116}},
                textColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                textString="SOC"),
              Text(
                extent={{44,154},{134,112}},
                textColor={0,0,255},
                textString="%name")}),
          Documentation(info="<html>
<p>
Simple model of a battery.
</p>
<p>
This model takes as an input the power that should be stored in the battery (if <i>P &gt; 0</i>)
or that should be extracted from the battery.
The model uses a fictitious conductance
(see <a href=\"modelica://Buildings.Electrical.DC.Loads.Conductor\">Buildings.Electrical.DC.Loads.Conductor</a>) <i>G</i> such that
<i>P = u &nbsp; i</i> and <i>i = u &nbsp; G,</i> where
<i>u</i> is the voltage difference across the pins and
<i>i</i> is the current at the positive pin.
</p>
<p>
The output connector <code>SOC</code> is the state of charge of the battery.
This model does not enforce that the state of charge is between zero and one.
However, each time the state of charge crosses zero or one, a warning will
be written to the simulation log file.
The model also does not limit the current through the battery. The user should
provide a control so that only a reasonable amount of power is exchanged,
and that the state of charge remains between zero and one.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 6, 2021, by Michael Wetter:<br/>
Corrected wrong unit string.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2798\">issue 2798</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Removed binding of <code>P_nominal</code> as
this parameter is disabled and assigned a value
in the <code>initial equation</code> section.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">issue 426</a>.
</li>
<li>
March 19, 2015, by Michael Wetter:<br/>
Removed redeclaration of phase system in <code>Terminal_n</code> and
<code>Terminal_p</code> as it is already declared to the be the same
phase system, and it is not declared to be replaceable.
This avoids a translation error in OpenModelica.
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
<li>
January 8, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Battery;

      package Examples "Package with example models"
        extends Modelica.Icons.ExamplesPackage;

        model Battery "Test model for battery"
          extends Modelica.Icons.Example;
          ProsNet.Electrical.DC.Storage.Battery bat(EMax=40e3*3600, V_nominal=
                12) "Battery" annotation (Placement(transformation(extent={{120,
                    -48},{140,-28}})));
          ProsNet.Electrical.DC.Sources.ConstantVoltage sou(V=12)
            "Voltage source" annotation (Placement(transformation(extent={{-10,
                    -10},{10,10}}, origin={98,-80})));
          Modelica.Electrical.Analog.Basic.Ground ground
            annotation (Placement(transformation(extent={{76,-120},{96,-100}})));
          ProsNet.Electrical.DC.Loads.Conductor loa(
            P_nominal=0,
            mode=ProsNet.Electrical.Types.Load.VariableZ_P_input,
            V_nominal=12) "Electrical load" annotation (Placement(
                transformation(extent={{140,-90},{160,-70}})));
          Modelica.Blocks.Sources.Constant const1(k=-10e3)
            "Power consumption of the load"
            annotation (Placement(transformation(extent={{200,-90},{180,-70}})));
          Modelica.Blocks.Sources.SampleTrigger startCharge(period=24*3600,
              startTime=23*3600)
            annotation (Placement(transformation(extent={{-140,20},{-120,40}})));
          Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqualThreshold(threshold=
               0.99)
            annotation (Placement(transformation(extent={{-140,-10},{-120,10}})));
          Modelica.Blocks.Sources.SampleTrigger startDischarge(period=24*3600,
              startTime=14*3600)
            annotation (Placement(transformation(extent={{-140,-40},{-120,-20}})));
          Modelica.Blocks.Logical.LessEqualThreshold lessEqualThreshold(threshold=
                0.01)
            annotation (Placement(transformation(extent={{-140,-70},{-120,-50}})));
          Modelica.Blocks.Logical.Switch chaSwi "Switch to charge battery"
            annotation (Placement(transformation(extent={{60,-40},{80,-20}})));
          Modelica.Blocks.Logical.Switch disSwi "Switch to discharge battery"
            annotation (Placement(transformation(extent={{60,10},{80,30}})));
          Modelica.Blocks.Sources.Constant PCha(k=1e4) "Charging power"
            annotation (Placement(transformation(extent={{0,-58},{20,-38}})));
          Modelica.Blocks.Sources.Constant POff(k=0) "Off power"
            annotation (Placement(transformation(extent={{0,-10},{20,10}})));
          Modelica.Blocks.Sources.Constant PDis(k=-1e4) "Discharging power"
            annotation (Placement(transformation(extent={{0,18},{20,38}})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{100,0},{120,20}})));
          ProsNet.Electrical.DC.Sensors.GeneralizedSensor powSen "Power sensor"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={120,-60})));
          Modelica.StateGraph.InitialStep off(nIn=1, nOut=1)
                                              "Off state" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                origin={-130,80})));
          Modelica.StateGraph.TransitionWithSignal toOn "Transition to on" annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                origin={-100,80})));
          Modelica.StateGraph.StepWithSignal charge(nIn=1, nOut=1)
                                                    "State to charge battery"
            annotation (Placement(transformation(extent={{-80,70},{-60,90}})));
          Modelica.StateGraph.TransitionWithSignal toHold "Transition to hold"
            annotation (Placement(transformation(extent={{-50,70},{-30,90}})));
          Modelica.StateGraph.Step hold(nIn=1, nOut=1)
                                        "Battery charge is hold"
            annotation (Placement(transformation(extent={{-20,70},{0,90}})));
          Modelica.StateGraph.TransitionWithSignal toDischarge
            "Transition to discharge"
            annotation (Placement(transformation(extent={{10,70},{30,90}})));
          Modelica.StateGraph.StepWithSignal discharge(nIn=1, nOut=1)
                                                       "State to discharge battery"
            annotation (Placement(transformation(extent={{40,70},{60,90}})));
          Modelica.StateGraph.TransitionWithSignal toOff "Transition to off"
            annotation (Placement(transformation(extent={{70,70},{90,90}})));
          inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
            annotation (Placement(transformation(extent={{-200,80},{-180,100}})));
        equation

          connect(POff.y, disSwi.u3) annotation (Line(
              points={{21,0},{40,0},{40,12},{58,12}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(POff.y, chaSwi.u3) annotation (Line(
              points={{21,0},{40,0},{40,-38},{58,-38}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(PDis.y, disSwi.u1) annotation (Line(
              points={{21,28},{58,28}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(PCha.y, chaSwi.u1) annotation (Line(
              points={{21,-48},{30,-48},{30,-22},{58,-22}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(add.y, bat.P) annotation (Line(
              points={{121,10},{130,10},{130,-28}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(bat.SOC, greaterEqualThreshold.u) annotation (Line(
              points={{141,-32},{160,-32},{160,108},{-160,108},{-160,0},{-142,0}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(bat.SOC, lessEqualThreshold.u) annotation (Line(
              points={{141,-32},{160,-32},{160,108},{-160,108},{-160,-60},{-142,-60}},
              color={0,0,127},
              smooth=Smooth.None));

          connect(const1.y, loa.Pow) annotation (Line(
              points={{179,-80},{160,-80}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(loa.terminal, sou.terminal) annotation (Line(
              points={{140,-80},{108,-80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(bat.terminal, powSen.terminal_p) annotation (Line(
              points={{120,-38},{120,-50}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(powSen.terminal_n, sou.terminal) annotation (Line(
              points={{120,-70},{120,-80},{108,-80}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(sou.n, ground.p) annotation (Line(
              points={{88,-80},{86,-80},{86,-100}},
              color={0,0,255},
              smooth=Smooth.None));
          connect(startCharge.y, toOn.condition) annotation (Line(
              points={{-119,30},{-100,30},{-100,68}},
              color={255,0,255},
              pattern=LinePattern.Dash));
          connect(charge.active, chaSwi.u2) annotation (Line(points={{-70,69},{-70,69},{
                  -70,50},{-70,-30},{58,-30}}, color={255,0,255}));
          connect(greaterEqualThreshold.y, toHold.condition) annotation (Line(
              points={{-119,0},{-90,0},{-90,60},{-40,60},{-40,68}},
              color={255,0,255},
              pattern=LinePattern.Dash));
          connect(startDischarge.y, toDischarge.condition) annotation (Line(
              points={{-119,-30},{-80,-30},{-80,54},{20,54},{20,68}},
              color={255,0,255},
              pattern=LinePattern.Dash));
          connect(disSwi.u2, discharge.active) annotation (Line(points={{58,20},{58,20},
                  {50,20},{50,46},{50,69}}, color={255,0,255}));
          connect(discharge.outPort[1], toOff.inPort)
            annotation (Line(points={{60.5,80},{76,80}}, color={0,0,0}));
          connect(lessEqualThreshold.y, toOff.condition) annotation (Line(
              points={{-119,-60},{-60,-60},{-60,48},{80,48},{80,68}},
              color={255,0,255},
              pattern=LinePattern.Dash));
          connect(off.outPort[1], toOn.inPort) annotation (Line(points={{-119.5,80},{-111.75,
                  80},{-104,80}}, color={0,0,0}));
          connect(toOn.outPort, charge.inPort[1])
            annotation (Line(points={{-98.5,80},{-81,80},{-81,80}}, color={0,0,0}));
          connect(charge.outPort[1], toHold.inPort)
            annotation (Line(points={{-59.5,80},{-44,80},{-44,80}}, color={0,0,0}));
          connect(toHold.outPort, hold.inPort[1])
            annotation (Line(points={{-38.5,80},{-21,80},{-21,80}}, color={0,0,0}));
          connect(hold.outPort[1], toDischarge.inPort)
            annotation (Line(points={{0.5,80},{8,80},{16,80}}, color={0,0,0}));
          connect(toDischarge.outPort, discharge.inPort[1])
            annotation (Line(points={{21.5,80},{39,80},{39,80}}, color={0,0,0}));
          connect(toOff.outPort, off.inPort[1]) annotation (Line(points={{81.5,80},{92,80},
                  {92,100},{-150,100},{-150,80},{-141,80}}, color={0,0,0}));
          connect(disSwi.y, add.u1) annotation (Line(points={{81,20},{90,20},{90,16},{98,
                  16}}, color={0,0,127}));
          connect(chaSwi.y, add.u2) annotation (Line(points={{81,-30},{90,-30},{90,4},{98,
                  4}}, color={0,0,127}));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-220,
                    -120},{220,120}})),
            experiment(Tolerance=1e-06, StopTime=432000),
            __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/Electrical/DC/Storage/Examples/Battery.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
This model illustrates use of a battery connected to an DC voltage source
and a constant load.
The battery is charged every night at 23:00 until it is full.
At 14:00, it is discharged until it is empty.
This control is implemented using a finite state machine.
The charging and discharging power is assumed to be controlled to
a constant value of <i>10,000</i> Watts.
</p>
</html>",     revisions="<html>
<ul>
<li>
April 6, 2016, by Michael Wetter:<br/>
Replaced <code>Modelica_StateGraph2</code> with <code>Modelica.StateGraph</code>.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/504\">issue 504</a>.
</li>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Battery;
      annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.DC.Storage\">
Buildings.Electrical.DC.Storage</a>.
</p>
</html>"));
      end Examples;

      package BaseClasses "Base models for battery package"
        extends Modelica.Icons.BasesPackage;

        model Charge "Model to compute the battery charge"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.Units.SI.Efficiency etaCha(max=1) = 0.9
            "Efficiency during charging";
          parameter Modelica.Units.SI.Efficiency etaDis(max=1) = 0.9
            "Efficiency during discharging";
          parameter Real SOC_start(min=0, max=1, unit="1")=0.1
            "Initial state of charge";
          parameter Modelica.Units.SI.Energy EMax(min=0, displayUnit="kW.h")
            "Maximum available charge";
          Modelica.Units.SI.Power PAct "Actual power";
          Modelica.Blocks.Interfaces.RealInput P(final quantity="Power",
                                                 final unit="W") annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}}),iconTransformation(extent={{-140,-20},{
                    -100,20}})));
          Modelica.Blocks.Interfaces.RealOutput SOC(min=0, max=1) "State of charge" annotation (Placement(transformation(
                  extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{120,
                    10}})));

          // etaDisInv avoids use of a divGuarded macro in Dymola in the dynamics section
        protected
          final parameter Real etaDisInv = 1/etaDis "Inverse of etaDis";
          final parameter Real invEMax = 1/EMax "Inverse of EMax";

          Boolean underCharged "Flag, true if battery is undercharged";
          Boolean overCharged "Flag, true if battery is overcharged";
        initial equation
          pre(underCharged) = SOC_start < 0;
          pre(overCharged)  = SOC_start > 1;

          SOC = SOC_start;
        equation
          // Charge balance of battery
          PAct = if P > 0 then etaCha*P else etaDisInv*P;
          der(SOC)=PAct*invEMax;

          // Equations to warn if state of charge exceeds 0 and 1
          underCharged = SOC < 0;
          overCharged = SOC > 1;
          when change(underCharged) or change(overCharged) then
            assert(SOC >= 0, "Warning: Battery is below minimum charge.",
            level=AssertionLevel.warning);
            assert(SOC <= 1, "Warning: Battery is above maximum charge.",
            level=AssertionLevel.warning);
          end when;

          annotation ( Documentation(info="<html>
<p>
This model represents the charge/discharge mechanism of a battery.
</p>
<p>
This model two parameters <i>&eta;<sub>CHA</sub></i> and <i>&eta;<sub>DIS</sub></i> that represent
the efficiency during the charge and discharge of the battery.
</p>
<p>
The model given the power <i>P</i> that should be provide or taken from the battery
and compute the actual power flowing through the battery as
</p>

<table summary=\"equations\" border = \"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collape;\">
<tr><th>Equation</th><th>Condition</th></tr>
<tr>
<td>P<sub>actual</sub> = P &eta;<sub>CHA</sub></td>
<td>P &ge; 0</td>
</tr>
<tr>
<td>P<sub>actual</sub> = P / &eta;<sub>DIS</sub></td>
<td>P &lt; 0</td>
</tr>
</table>

<p>
The actual power is then used to compute the variation of the state of charge <code>SOC</code>.
The state of charge is the state variable of this model and is a real value between 0 and 1.
</p>

<p align=\"center\" style=\"font-style:italic;\">
 d SOC / dt = P<sub>actual</sub>
</p>

<p>
<b>Note:</b>The input power <i>P</i> has to be controlled in order
to avoid the state of charge <code>SOC</code>
exceeding the range between 0 and 1.
</p>

</html>",         revisions="<html>
<ul>
<li>
August 26, 2022, by Jianjun Hu:<br/>
Corrected calculation of power taken from the battery when it is discharged.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3095\">issue 3095</a>.
</li>
<li>
December 6, 2021, by Michael Wetter:<br/>
Corrected wrong unit string.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/2798\">issue 2798</a>.
</li>
<li>
June 2, 2014, by Marco Bonvini:<br/>
Revised documentation.
</li>
</ul>
</html>"));
        end Charge;
      annotation (Documentation(info="<html><p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Electrical.DC.Storage\">Buildings.Electrical.DC.Storage</a>.
</p>
</html>"));
      end BaseClasses;

      model BatteryControl "Controller for battery"

        Modelica.Blocks.Interfaces.RealInput SOC "State of charge" annotation (
            Placement(transformation(extent={{-200,-20},{-160,20}}),
              iconTransformation(extent={{-200,-20},{-160,20}})));
        Modelica.Blocks.Interfaces.RealOutput y
          "Power charged or discharged from battery" annotation (Placement(
              transformation(extent={{160,-10},{180,10}}), iconTransformation(
                extent={{160,-10},{180,10}})));
        Modelica.Blocks.Logical.LessThreshold lessThreshold(threshold=0.5)
          annotation (Placement(transformation(extent={{-120,-60},{-100,-40}})));
        Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqualThreshold(threshold=
             0.99)
          annotation (Placement(transformation(extent={{-120,-100},{-100,-80}})));
        Modelica.Blocks.Sources.BooleanExpression isDay(y=mod(time, 86400) > 7*3600
               and mod(time, 86400) <= 19*3600) "Outputs true if it is day time"
          annotation (Placement(transformation(extent={{-152,30},{-132,50}})));
        Modelica.Blocks.Logical.Not not1
          annotation (Placement(transformation(extent={{-120,-20},{-100,0}})));
        Modelica.Blocks.Logical.And and1
          annotation (Placement(transformation(extent={{-80,-54},{-60,-34}})));
        Modelica.Blocks.Logical.And and2
          annotation (Placement(transformation(extent={{-80,18},{-60,38}})));
        Modelica.Blocks.Logical.GreaterThreshold greaterThreshold(threshold=0.8)
          annotation (Placement(transformation(extent={{-120,10},{-100,30}})));
        Modelica.Blocks.Logical.LessEqualThreshold lessEqualThreshold(threshold=
              0.01)
          annotation (Placement(transformation(extent={{-120,-130},{-100,-110}})));
        Modelica.Blocks.Math.MultiSwitch multiSwitch1(
          nu=2,
          expr={200e3,-400e3})
          annotation (Placement(transformation(extent={{104,-10},{120,10}})));
        Modelica.StateGraph.InitialStep off(nIn=1, nOut=1)
                                            "Off state"
          annotation (Placement(transformation(extent={{-50,80},{-30,100}})));
        inner Modelica.StateGraph.StateGraphRoot stateGraphRoot
          annotation (Placement(transformation(extent={{-120,120},{-100,140}})));
        Modelica.StateGraph.Alternative alternative(nBranches=2)
          "Splitter for alternative branches"
          annotation (Placement(transformation(extent={{-14,40},{114,140}})));
        Modelica.StateGraph.TransitionWithSignal t1(enableTimer=true, waitTime=1)
          "Transition to charge"
          annotation (Placement(transformation(extent={{10,110},{30,130}})));
        Modelica.StateGraph.TransitionWithSignal t2(enableTimer=true, waitTime=1)
          "Transition to discharge"
          annotation (Placement(transformation(extent={{10,50},{30,70}})));
        Modelica.StateGraph.StepWithSignal charge(nIn=1, nOut=1)
                                                  "Charge battery"
          annotation (Placement(transformation(extent={{40,110},{60,130}})));
        Modelica.StateGraph.StepWithSignal discharge(nIn=1, nOut=1)
                                                     "Discharge battery"
          annotation (Placement(transformation(extent={{40,50},{60,70}})));
        Modelica.StateGraph.TransitionWithSignal t3 "Transition to off"
          annotation (Placement(transformation(extent={{70,110},{90,130}})));
        Modelica.StateGraph.TransitionWithSignal t4 "Transition to off"
          annotation (Placement(transformation(extent={{70,50},{90,70}})));
      equation

        connect(lessThreshold.u, SOC) annotation (Line(
            points={{-122,-50},{-140,-50},{-140,0},{-180,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(greaterEqualThreshold.u, SOC) annotation (Line(
            points={{-122,-90},{-140,-90},{-140,0},{-180,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(not1.u, isDay.y) annotation (Line(
            points={{-122,-10},{-126,-10},{-126,40},{-131,40}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(and1.u1, not1.y) annotation (Line(
            points={{-82,-44},{-92,-44},{-92,-10},{-99,-10}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(lessThreshold.y, and1.u2) annotation (Line(
            points={{-99,-50},{-90,-50},{-90,-52},{-82,-52}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(isDay.y, and2.u1) annotation (Line(
            points={{-131,40},{-92,40},{-92,28},{-82,28}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(greaterThreshold.u, SOC) annotation (Line(
            points={{-122,20},{-140,20},{-140,0},{-180,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(greaterThreshold.y, and2.u2) annotation (Line(
            points={{-99,20},{-82,20}},
            color={255,0,255},
            smooth=Smooth.None));
        connect(lessEqualThreshold.u, SOC) annotation (Line(
            points={{-122,-120},{-140,-120},{-140,0},{-180,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(multiSwitch1.y, y) annotation (Line(
            points={{120.4,0},{170,0}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(off.outPort[1], alternative.inPort)
          annotation (Line(points={{-29.5,90},{-22,90},{-15.92,90}},
                                                              color={0,0,0}));
        connect(t1.outPort, charge.inPort[1])
          annotation (Line(points={{21.5,120},{39,120}}, color={0,0,0}));
        connect(t2.outPort, discharge.inPort[1])
          annotation (Line(points={{21.5,60},{26,60},{39,60}},
                                                       color={0,0,0}));
        connect(charge.outPort[1], t3.inPort)
          annotation (Line(points={{60.5,120},{76,120}}, color={0,0,0}));
        connect(discharge.outPort[1], t4.inPort)
          annotation (Line(points={{60.5,60},{68,60},{76,60}}, color={0,0,0}));
        connect(alternative.outPort, off.inPort[1]) annotation (Line(points={{115.28,
                90},{130,90},{130,150},{-60,150},{-60,90},{-51,90}},color={0,0,0}));
        connect(and1.y, t1.condition) annotation (Line(points={{-59,-44},{10,-44},{10,
                90},{20,90},{20,108}},               color={255,0,255}));
        connect(and2.y, t2.condition) annotation (Line(points={{-59,28},{-36,28},{-20,
                28},{20,28},{20,48}},          color={255,0,255}));
        connect(greaterEqualThreshold.y, t3.condition) annotation (Line(points={{-99,-90},
                {-99,-90},{70,-90},{70,92},{80,92},{80,108}},   color={255,0,255}));
        connect(lessEqualThreshold.y, t4.condition)
          annotation (Line(points={{-99,-120},{80,-120},{80,48}},
                                                                color={255,0,255}));
        connect(t1.inPort, alternative.split[1])
          annotation (Line(points={{16,120},{8,120},{8,77.5},{-0.56,77.5}},
                                                          color={0,0,0}));
        connect(t2.inPort, alternative.split[2])
          annotation (Line(points={{16,60},{8,60},{8,102.5},{-0.56,102.5}},
                                                        color={0,0,0}));
        connect(t3.outPort, alternative.join[1])
          annotation (Line(points={{81.5,120},{92,120},{92,77.5},{100.56,77.5}},
                                                             color={0,0,0}));
        connect(t4.outPort, alternative.join[2])
          annotation (Line(points={{81.5,60},{92,60},{92,102.5},{100.56,102.5}},
                                                           color={0,0,0}));
        connect(charge.active, multiSwitch1.u[1]) annotation (Line(
            points={{50,109},{50,92},{64,92},{64,-0.75},{104,-0.75}},
            color={255,0,255},
            pattern=LinePattern.Dash));
        connect(discharge.active, multiSwitch1.u[2]) annotation (Line(
            points={{50,49},{50,49},{50,-4},{104,-4},{104,0.75}},
            color={255,0,255},
            pattern=LinePattern.Dash));
        annotation ( Documentation(info="<html>
<p>
Block for a battery controller. The battery is charged during night if its charge is below
a threshold. It remains charging until it is full.
During day, it discharges provided that its charge is above a threshold. It remains
discharging until it is empty.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 17, 2016, by Michael Wetter:<br/>
Removed output of instance <code>off</code> to avoid
an overdetermined system of equations during initialization.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/578\">issue 578</a>.
</li>
<li>
April 6, 2016, by Michael Wetter:<br/>
Replaced <code>Modelica_StateGraph2</code> with <code>Modelica.StateGraph</code>.
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/504\">issue 504</a>.
</li>
<li>
January 11, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-160,-160},{160,160}}),
                          graphics={     Rectangle(
                extent={{-160,-160},{160,162}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-78,64},{-12,20}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-80,42},{-104,54},{-104,32},{-80,42}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-104,44},{-136,44}},
                color={0,0,0},
                smooth=Smooth.None),            Text(
                extent={{-150,204},{150,164}},
                textString="%name",
                textColor={0,0,255}),
              Rectangle(
                extent={{36,62},{102,18}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{14,42},{-12,42}},
                color={0,0,0},
                smooth=Smooth.None),
              Rectangle(
                extent={{34,-6},{100,-50}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{10,-26},{-50,-26}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-50,20},{-50,-26}},
                color={0,0,0},
                smooth=Smooth.None),
              Polygon(
                points={{36,42},{12,54},{12,32},{36,42}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{34,-28},{10,-16},{10,-38},{34,-28}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(extent={{-160,-160},{160,160}})));
      end BatteryControl;
    annotation (Documentation(info="<html><p>
This package contains models that represent different energy storages for DC power.
</p>
</html>"));
    end Storage;

    package Interfaces "Package with interfaces for DC electrical systems"
      extends Modelica.Icons.InterfacesPackage;

      connector Terminal_n "Terminal n for DC electrical systems"
        extends ProsNet.Electrical.Interfaces.Terminal(redeclare package
            PhaseSystem = ProsNet.Electrical.PhaseSystems.TwoConductor);
        annotation (Icon(graphics={  Polygon(
                points={{-120,0},{0,-120},{120,0},{0,120},{-120,0}},
                lineColor={0,0,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>Electric connector for DC electrical systems.</p>
</html>"));
      end Terminal_n;

      connector Terminal_p "Terminal p for DC electrical systems"
        extends ProsNet.Electrical.Interfaces.Terminal(redeclare package
            PhaseSystem = ProsNet.Electrical.PhaseSystems.TwoConductor);
        annotation (Icon(graphics={  Polygon(
                points={{-120,0},{0,-120},{120,0},{0,120},{-120,0}},
                lineColor={0,0,255},
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>Electric connector for DC electrical systems.</p>
</html>"));
      end Terminal_p;
    annotation (Documentation(info="<html>
<p>
This package contains connectors that are used by the models in the
<a href=\"modelica://Buildings.Electrical.DC\">Buildings.Electrical.DC</a> package.
The connectors extends the basic connectors
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">Buildings.Electrical.Interfaces.Terminal</a>
and define a new graphical icon in order to be distinguished by connectors of other electrical systems (e.g. AC systems).
</p>
</html>"));
    end Interfaces;
    annotation (Documentation(info="<html>
<p>
Package with models for direct current (DC) systems.<br/>
The models contained in this package use the phase system <a href=\"modelica://Buildings.Electrical.PhaseSystems.TwoConductor\">Buildings.Electrical.PhaseSystems.TwoConductor</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
May 28, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"),   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
            {100,100}}), graphics={
        Line(
          points={{-82,20},{58,20}},
          color={0,0,0},
          smooth=Smooth.None),
        Line(
          points={{-82,-18},{-52,-18},{-42,-18}},
          color={0,0,0},
          smooth=Smooth.None),
        Line(
          points={{-22,-18},{-2,-18},{-2,-18}},
          color={0,0,0},
          smooth=Smooth.None),
        Line(
          points={{18,-18},{48,-18},{58,-18}},
          color={0,0,0},
          smooth=Smooth.None)}));
  end DC;

  package Icons "This package contains icons used by the electric models"
    extends Modelica.Icons.IconsPackage;

    partial class GeneralizedProbe
      "Icon representing a generalized probe that measures voltage, and phase angle"
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-40,30},{40,-30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              origin={1.77636e-15,-40},
              rotation=90),
            Ellipse(
              extent={{-60,60},{60,-60}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-0.48,33.6},{18,28},{18,59.2},{-0.48,33.6}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-37.6,15.7},{-54,22}},     color={0,0,0}),
            Line(points={{-22.9,34.8},{-32,50}},     color={0,0,0}),
            Line(points={{0,60},{0,42}}, color={0,0,0}),
            Line(points={{22.9,34.8},{32,50}},     color={0,0,0}),
            Line(points={{37.6,15.7},{54,24}},     color={0,0,0}),
            Line(points={{0,2},{9.02,30.6}}, color={0,0,0}),
            Ellipse(
              extent={{-5,7},{5,-3}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
                                  Text(
              extent={{-140,110},{140,70}},
              textColor={0,0,0},
              textString="%name")}),    Documentation(info="<html>
<p>
This is the icon for a probe that measure voltage magnitude and phase.
</p>
</html>",     revisions="<html>
<ul>
<li>
June 6, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
    end GeneralizedProbe;

    partial class GeneralizedSensor
      "Icon representing a generalized sensor that measures voltage, current and power"
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-70,28},{70,-30}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-60,60},{60,-60}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-92,0},{-70,0}},
              color={0,0,0},
              smooth=Smooth.None),
            Polygon(
              points={{-0.48,33.6},{18,28},{18,59.2},{-0.48,33.6}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(points={{-37.6,15.7},{-54,22}},     color={0,0,0}),
            Line(points={{-22.9,34.8},{-32,50}},     color={0,0,0}),
            Line(points={{0,60},{0,42}}, color={0,0,0}),
            Line(points={{22.9,34.8},{32,50}},     color={0,0,0}),
            Line(points={{37.6,15.7},{54,24}},     color={0,0,0}),
            Line(points={{0,2},{9.02,30.6}}, color={0,0,0}),
            Ellipse(
              extent={{-5,7},{5,-3}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Line(
              points={{70,0},{92,0}},
              color={0,0,0},
              smooth=Smooth.None),
            Text(
              extent={{-60,-42},{60,-82}},
              textColor={0,0,0},
              lineThickness=1,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              textString="V"),
            Text(
              extent={{0,-40},{120,-80}},
              textColor={0,0,0},
              lineThickness=1,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              textString="I"),    Text(
              extent={{-140,110},{140,70}},
              textColor={0,0,0},
              textString="%name")}),    Documentation(info="<html>
<p>
This is the icon for ideal sensors that measure power, voltage and current.
</p>
</html>",     revisions="<html>
<ul>
<li>
July 24, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end GeneralizedSensor;

    partial model RefAngleConversion
      "Icon that represents if the angle symble should be displayed or not"
      annotation (Icon(graphics={
            Line(visible = ground_2 == true,
              points={{80,-40},{120,-40}},
              color={0,120,120},
              smooth=Smooth.None,
              thickness=0.5),
            Line(visible = ground_2 == true,
              points={{80,-40},{106,-14}},
              color={0,120,120},
              smooth=Smooth.None,
              thickness=0.5),
            Line(visible = ground_2 == true,
              points={{102,-16},{114,-24},{118,-42}},
              color={0,120,120},
              smooth=Smooth.Bezier),
            Line(visible = ground_1 == true,
              points={{-102,-16},{-114,-24},{-118,-42}},
              color={0,120,120},
              smooth=Smooth.Bezier),
            Line(visible = ground_1 == true,
              points={{-80,-40},{-106,-14}},
              color={0,120,120},
              smooth=Smooth.None,
              thickness=0.5),
            Line(visible = ground_1 == true,
              points={{-80,-40},{-120,-40}},
              color={0,120,120},
              smooth=Smooth.None,
              thickness=0.5)}), Documentation(info="<html>
<p>
This is the icon that conditionally draws the angle symbol for a
conversion model (e.g., a transformer).
</p>
</html>",     revisions="<html>
<ul>
<li>
October 3, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
    end RefAngleConversion;
  annotation (Documentation(revisions="<html>
<ul>
<li>
Aug 28, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",   info="<html>
<p>
Package that contains icons.
</p>
</html>"));
  end Icons;

  package PhaseSystems "Phase systems used in power connectors"
    extends Modelica.Icons.Package;
    import      Modelica.Units.SI;
    import Modelica.Constants.pi;

    package DirectCurrent "DC system"
      extends PartialPhaseSystem(phaseSystemName="DirectCurrent", n=1, m=0);

      redeclare function extends j "Direct current has no complex component"
      algorithm
        y := zeros(n);
        annotation(Inline=true);
      end j;

     redeclare function extends rotate
      "Rotate a vector of an angle theta (anti-counterclock)"
     algorithm
        y[n] := x[n];
        annotation(Inline=true);
     end rotate;

     redeclare function extends thetaRel
      "Return absolute angle of rotating system as offset to thetaRef"
     algorithm
        thetaRel := 0;
        annotation(Inline=true);
     end thetaRel;

     redeclare function extends thetaRef
      "Return absolute angle of rotating reference system"
     algorithm
        thetaRef := 0;
        annotation(Inline=true);
     end thetaRef;

     redeclare function extends phase "Return phase"
     algorithm
        phase := 0;
        annotation(Inline=true);
     end phase;

      redeclare replaceable function extends phaseVoltages
      "Return phase to neutral voltages"
      algorithm
        v := {V};
        annotation(Inline=true);
      end phaseVoltages;

      redeclare function extends phaseCurrents "Return phase currents"
      algorithm
        i := {I};
        annotation(Inline=true);
      end phaseCurrents;

      redeclare function extends phasePowers "Return phase powers"
      algorithm
        p := {P};
        annotation(Inline=true);
      end phasePowers;

      redeclare function extends phasePowers_vi "Return phase powers"
      algorithm
        p := {v*i};
        annotation(Inline=true);
      end phasePowers_vi;

      redeclare replaceable function extends systemVoltage
      "Return system voltage as function of phase voltages"
      algorithm
        V := v[1];
        annotation(Inline=true);
      end systemVoltage;

      redeclare function extends systemCurrent
      "Return system current as function of phase currents"
      algorithm
        I := i[1];
        annotation(Inline=true);
      end systemCurrent;

      redeclare function extends activePower
      "Return total power as function of phase powers"
      algorithm
        P := v*i;
        annotation(Inline=true);
      end activePower;

      annotation (Icon(graphics={Line(
              points={{-70,-10},{50,-10}},
              color={95,95,95},
              smooth=Smooth.None)}),
    Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the DC models.
</p>
</html>"));
    end DirectCurrent;

    package OnePhase "Single phase two connectors AC system"
      extends PartialPhaseSystem(phaseSystemName="OnePhase", n=2, m=1);

      redeclare function extends j "Return vector rotated by 90 degrees"
      algorithm
        y := {-x[2], x[1]};
        annotation(Inline=true);
      end j;

      redeclare function extends rotate
      "Rotate a vector of an angle theta (anti-counterclock)"
      algorithm
        y[1] := cos(theta)*x[1] - sin(theta)*x[2];
        y[2] := sin(theta)*x[1] + cos(theta)*x[2];
        annotation(Inline=true);
      end rotate;

      redeclare function extends product
      "Multiply two complex numbers represented by vectors x[2] and y[2]"
      algorithm
        z := {x[1]*y[1] - x[2]*y[2], x[1]*y[2] + x[2]*y[1]};
        annotation(Inline=true);
      end product;

      redeclare function extends divide
      "Divide two complex numbers represented by vectors x[2] and y[2]"
      algorithm
        z := {x[1]*y[1] + x[2]*y[2], x[2]*y[1] - x[1]*y[2]}/(y[1]^2 + y[2]^2);
        annotation(Inline=true);
      end divide;

      redeclare function extends thetaRel
      "Return absolute angle of rotating system as offset to thetaRef"
      algorithm
        thetaRel := 0;
        annotation(Inline=true);
      end thetaRel;

      redeclare function extends thetaRef
      "Return absolute angle of rotating reference system"
      algorithm
        thetaRef := theta[1];
        annotation(Inline=true);
      end thetaRef;

      redeclare function extends phase "Return phase"
      algorithm
        phase := atan2(x[2], x[1]);
        annotation(Inline=true);
      end phase;

      redeclare function extends phaseVoltages "Return phase to neutral voltages"
      algorithm
        v := {V*cos(phi), V*sin(phi)};
        annotation(Inline=true);
      end phaseVoltages;

      redeclare function extends phaseCurrents "Return phase currents"
      algorithm
        i := {I*cos(phi), I*sin(phi)};
        annotation(Inline=true);
      end phaseCurrents;

      redeclare function extends phasePowers "Return phase powers"
      algorithm
        p := {P, P*tan(phi)};
        annotation(Inline=true);
      end phasePowers;

      redeclare function extends phasePowers_vi "Return phase powers"
      algorithm
        p := {v[1]*i[1] + v[2]*i[2], v[2]*i[1] - v[1]*i[2]};
        annotation(Inline=true);
      end phasePowers_vi;

      redeclare function extends systemVoltage
      "Return system voltage as function of phase voltages"
      algorithm
        V := Modelica.Fluid.Utilities.regRoot(v*v, delta = 1e-5);
        annotation(Inline=true);
      end systemVoltage;

      redeclare function extends systemCurrent
      "Return system current as function of phase currents"
      algorithm
        I := Modelica.Fluid.Utilities.regRoot(i*i, delta = 1e-5);
        annotation(Inline=true);
      end systemCurrent;

      redeclare function extends activePower
      "Return total power as function of phase powers"
      algorithm
        // P = v[1]*i[1] + v[2]*i[2]
        P := v*i;
        annotation(Inline=true);
      end activePower;

      annotation (Icon(graphics={
            Line(
              points={{-70,-10},{-58,10},{-38,30},{-22,10},{-10,-10},{2,-30},{22,-50},
                  {40,-30},{50,-10}},
              color={95,95,95},
              smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the AC single phase models.
</p>
</html>"));
    end OnePhase;

    package PartialPhaseSystem "Base package of all phase systems"
      extends Modelica.Icons.Package;
      constant String phaseSystemName = "UnspecifiedPhaseSystem"
        "Name of the phase system represented by the package";
      constant Integer n "Number of independent voltage and current components";
      constant Integer m "Number of reference angles";

      type Current = Real(unit = "A", quantity = "Current." + phaseSystemName)
        "Current for connector" annotation (Documentation(info="<html>
This type defines the current for a specific connector that extends
<a href=\"modelica://Buildings.Electrical.PhaseSystems.PartialPhaseSystem\">
Buildings.Electrical.PhaseSystems.PartialPhaseSystem</a>.
</html>"));

      type Voltage = Real(unit = "V", quantity = "Voltage." + phaseSystemName)
        "Voltage for connector" annotation (Documentation(info="<html>
This type defines the voltage for a specific connector that extends
<a href=\"modelica://Buildings.Electrical.PhaseSystems.PartialPhaseSystem\">
Buildings.Electrical.PhaseSystems.PartialPhaseSystem</a>.
</html>"));

      type ReferenceAngle "Reference angle for connector"
        extends Modelica.Units.SI.Angle;

        function equalityConstraint "Assert that angles are equal"
          extends Modelica.Icons.Function;
          input ReferenceAngle theta1[:];
          input ReferenceAngle theta2[:];
          output Real residue[0];
        algorithm
          for i in 1:size(theta1, 1) loop
            assert(abs(theta1[i] - theta2[i]) < Modelica.Constants.eps,
              "Angles theta1 and theta2 are not equal over the connection.");
          end for;
        end equalityConstraint;
        annotation (Documentation(info="<html>
This type defines the voltage angle (used by the phasorial approach) for a specific connector that extends
<a href=\"modelica://Buildings.Electrical.PhaseSystems.PartialPhaseSystem\">
Buildings.Electrical.PhaseSystems.PartialPhaseSystem</a>.
</html>"));
      end ReferenceAngle;

      replaceable partial function j "Return vector rotated by 90 degrees"
        extends Modelica.Icons.Function;
        input Real x[n];
        output Real y[n];
      end j;

      replaceable partial function jj "Vectorized version of j"
        extends Modelica.Icons.Function;
        input Real[:,:] xx "array of voltage or current vectors";
        output Real[size(xx,1),size(xx,2)] yy "array of rotated vectors";
      algorithm
        //yy := {j(xx[:,k]) for k in 1:size(xx,2)};
        // Note: Dymola 2013 fails to expand
        for k in 1:size(xx,2) loop
          yy[:,k] := j(xx[:,k]);
        end for;
      end jj;

      replaceable partial function rotate
        "Rotate a vector of an angle theta (anti-counterclock)"
        extends Modelica.Icons.Function;
        input Real x[n];
        input Modelica.Units.SI.Angle theta;
        output Real y[n];
      end rotate;

      replaceable partial function product "Multiply two vectors"
          extends Modelica.Icons.Function;
          input Real x[n];
          input Real y[n];
          output Real z[n];
      end product;

      replaceable partial function divide "Divide two vectors"
          extends Modelica.Icons.Function;
          input Real x[n];
          input Real y[n];
          output Real z[n];
      end divide;

      replaceable partial function thetaRel
        "Return absolute angle of rotating system as offset to thetaRef"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Angle theta[m];
        output Modelica.Units.SI.Angle thetaRel;
      end thetaRel;

      replaceable partial function thetaRef
        "Return absolute angle of rotating reference system"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Angle theta[m];
        output Modelica.Units.SI.Angle thetaRef;
      end thetaRef;

      replaceable partial function phase "Return phase"
        extends Modelica.Icons.Function;
        input Real x[n];
        output Modelica.Units.SI.Angle phase;
      end phase;

      replaceable partial function phaseVoltages "Return phase to neutral voltages"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Voltage V "system voltage";
        input Modelica.Units.SI.Angle phi=0 "phase angle";
        output Modelica.Units.SI.Voltage v[n] "phase to neutral voltages";
      end phaseVoltages;

      replaceable partial function phaseCurrents "Return phase currents"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Current I "system current";
        input Modelica.Units.SI.Angle phi=0 "phase angle";
        output Modelica.Units.SI.Current i[n] "phase currents";
      end phaseCurrents;

      replaceable partial function phasePowers "Return phase powers"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.ActivePower P "active system power";
        input Modelica.Units.SI.Angle phi=0 "phase angle";
        output Modelica.Units.SI.Power p[n] "phase powers";
      end phasePowers;

      replaceable partial function phasePowers_vi "Return phase powers"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Voltage v[n] "phase voltages";
        input Modelica.Units.SI.Current i[n] "phase currents";
        output Modelica.Units.SI.Power p[n] "phase powers";
      end phasePowers_vi;

      replaceable partial function systemVoltage
        "Return system voltage as function of phase voltages"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Voltage v[n];
        output Modelica.Units.SI.Voltage V;
      end systemVoltage;

      replaceable partial function systemCurrent
        "Return system current as function of phase currents"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Current i[n];
        output Modelica.Units.SI.Current I;
      end systemCurrent;

      replaceable partial function activePower
        "Return total power as function of phase powers"
        extends Modelica.Icons.Function;
        input Modelica.Units.SI.Voltage v[n] "phase voltages";
        input Modelica.Units.SI.Current i[n] "phase currents";
        output Modelica.Units.SI.ActivePower P "active system power";
      end activePower;

    annotation (Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the different phase systems.
</p>
</html>"));
    end PartialPhaseSystem;

    package ThreePhase_d "AC system covering only resistive loads with three symmetric phases"
      extends DirectCurrent(phaseSystemName="ThreePhase_d");

      redeclare function phaseVoltages "Return phase to neutral voltages"
        extends Modelica.Icons.Function;
        input SI.Voltage V "system voltage";
        input SI.Angle phi = 0 "phase angle";
        output SI.Voltage v[n] "phase to neutral voltages";
      algorithm
        v := {V}/sqrt(3);
      end phaseVoltages;

      redeclare function systemVoltage
      "Return system voltage as function of phase voltages"
        extends Modelica.Icons.Function;
        input SI.Voltage v[n];
        output SI.Voltage V;
      algorithm
        V := sqrt(3)*v[1];
      end systemVoltage;

      annotation (Icon(graphics={
            Line(
              points={{-70,-10},{-58,10},{-38,30},{-22,10},{-10,-10},{2,-30},{22,
                  -50},{40,-30},{50,-10}},
              color={95,95,95},
              smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the AC three-phase balanced and purely resistive models.
</p>
</html>"));
    end ThreePhase_d;

    package ThreePhase_dq "AC system, symmetrically loaded three-phase"
      extends PartialPhaseSystem(phaseSystemName="ThreePhase_dq", n=2, m=1);

      redeclare function extends j "Return vector rotated by 90 degrees"
      algorithm
        y := {-x[2], x[1]};
        annotation(Inline=true);
      end j;

      redeclare function extends thetaRel
      "Return absolute angle of rotating system as offset to thetaRef"
      algorithm
        thetaRel := 0;
        annotation(Inline=true);
      end thetaRel;

      redeclare function extends thetaRef
      "Return absolute angle of rotating reference system"
      algorithm
        thetaRef := theta[1];
        annotation(Inline=true);
      end thetaRef;

      redeclare function extends phase "Return phase"
      algorithm
        phase := atan2(x[2], x[1]);
        annotation(Inline=true);
      end phase;

      redeclare function extends phaseVoltages "Return phase to neutral voltages"
      algorithm
        v := {V*cos(phi), V*sin(phi)}/sqrt(3);
        annotation(Inline=true);
      end phaseVoltages;

      redeclare function extends phaseCurrents "Return phase currents"
      algorithm
        i := {I*cos(phi), I*sin(phi)};
        annotation(Inline=true);
      end phaseCurrents;

      redeclare function extends phasePowers "Return phase powers"
      algorithm
        p := {P, P*tan(phi)};
        annotation(Inline=true);
      end phasePowers;

      redeclare function extends phasePowers_vi "Return phase powers"
      algorithm
        p := {v*i, -j(v)*i};
        annotation(Inline=true);
      end phasePowers_vi;

      redeclare function extends systemVoltage
      "Return system voltage as function of phase voltages"
      algorithm
        V := Modelica.Fluid.Utilities.regRoot(3*v*v, delta = 1e-5);
        annotation(Inline=true);
      end systemVoltage;

      redeclare function extends systemCurrent
      "Return system current as function of phase currents"
      algorithm
        I := Modelica.Fluid.Utilities.regRoot(i*i, delta = 1e-5);
        annotation(Inline=true);
      end systemCurrent;

      redeclare function extends activePower
      "Return total power as function of phase powers"
      algorithm
        P := v[1]*i[1];
        annotation(Inline=true);
      end activePower;

      annotation (Icon(graphics={
            Line(
              points={{-70,12},{-58,32},{-38,52},{-22,32},{-10,12},{2,-8},{22,-28},
                  {40,-8},{50,12}},
              color={95,95,95},
              smooth=Smooth.Bezier),
            Line(
              points={{-70,-70},{50,-70}},
              color={95,95,95},
              smooth=Smooth.None),
            Line(
              points={{-70,-46},{50,-46}},
              color={95,95,95},
              smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the AC three-phase balanced models using the DQ representation.
</p>
</html>"));
    end ThreePhase_dq;

    package ThreePhase_dq0 "AC system in dqo representation"
      extends PartialPhaseSystem(phaseSystemName="ThreePhase_dqo", n=3, m=2);

      redeclare function extends j
      "Rotation(pi/2) of vector around {0,0,1} and projection on North plane"
      algorithm
        y := cat(1, {-x[2], x[1]}, zeros(size(x,1)-2));
        annotation(Inline=true);
      end j;

      redeclare function extends rotate
      "Rotate a vector of an angle theta (anti-counterclock)"
      algorithm
        y[1] := cos(theta)*x[1] - sin(theta)*x[2];
        y[2] := sin(theta)*x[1] + cos(theta)*x[2];
        y[3] := x[3];
        annotation(Inline=true);
      end rotate;

      redeclare function jj "Vectorized version of j"
      extends Modelica.Icons.Function;
        input Real[:,:] xx "array of voltage or current vectors";
        output Real[size(xx,1),size(xx,2)] yy "array of rotated vectors";
      algorithm
        yy := cat(1, {-xx[2,:], xx[1,:]}, zeros(size(xx,1)-2, size(xx,2)));
        annotation(Inline=true);
      end jj;

      redeclare function extends thetaRel
      "Return absolute angle of rotating system as offset to thetaRef"
      algorithm
        thetaRel := theta[1];
        annotation(Inline=true);
      end thetaRel;

      redeclare function extends thetaRef
      "Return absolute angle of rotating reference system"
      algorithm
        thetaRef := theta[2];
        annotation(Inline=true);
      end thetaRef;

      redeclare function extends phase "Return phase"
      algorithm
        phase := atan2(x[2], x[1]);
        annotation(Inline=true);
      end phase;

      redeclare function extends phaseVoltages "Return phase to neutral voltages"
      protected
        Voltage neutral_v = 0;
      algorithm
        v := {V*cos(phi), V*sin(phi), sqrt(3)*neutral_v}/sqrt(3);
        annotation(Inline=true);
      end phaseVoltages;

      redeclare function extends phaseCurrents "Return phase currents"
      algorithm
        i := {I*cos(phi), I*sin(phi), 0};
        annotation(Inline=true);
      end phaseCurrents;

      redeclare function extends phasePowers "Return phase powers"
      algorithm
        p := {P, P*tan(phi), 0};
        annotation(Inline=true);
      end phasePowers;

      redeclare function extends phasePowers_vi "Return phase powers"
      algorithm
        p := {v[1:2]*i[1:2], -j(v[1:2])*i[1:2], v[3]*i[3]};
        annotation(Inline=true);
      end phasePowers_vi;

      redeclare function extends systemVoltage
      "Return system voltage as function of phase voltages"
      algorithm
        V := Modelica.Fluid.Utilities.regRoot(v*v, delta = 1e-5);
        annotation(Inline=true);
      end systemVoltage;

      redeclare function extends systemCurrent
      "Return system current as function of phase currents"
      algorithm
        I := Modelica.Fluid.Utilities.regRoot(i*i, delta = 1e-5);
        annotation(Inline=true);
      end systemCurrent;

      redeclare function extends activePower
      "Return total power as function of phase powers"
      algorithm
        P := v[1]*i[1];
        annotation(Inline=true);
      end activePower;

      annotation (Icon(graphics={
            Line(
              points={{-70,28},{-58,48},{-38,68},{-22,48},{-10,28},{2,8},{22,-12},
                  {40,8},{50,28}},
              color={95,95,95},
              smooth=Smooth.Bezier),
            Line(
              points={{-70,-54},{50,-54}},
              color={95,95,95},
              smooth=Smooth.None),
            Line(
              points={{-70,-78},{50,-78}},
              color={95,95,95},
              smooth=Smooth.None),
            Line(
              points={{-70,-28},{50,-28}},
              color={95,95,95},
              smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the AC three-phase balanced models using the DQ0 representation.
</p>
</html>"));
    end ThreePhase_dq0;

    package TwoConductor "Two conductors for DC components"
      extends PartialPhaseSystem(phaseSystemName="TwoConductor", n=2, m=0);

      redeclare function extends j "Direct current has no complex component"
      algorithm
        y := zeros(n);
        annotation(Inline=true);
      end j;

      redeclare function extends rotate
      "Rotate a vector of an angle theta (anti-counterclock)"
      algorithm
        y[n] := x[n];
        annotation(Inline=true);
      end rotate;

      redeclare function extends thetaRel
      "Return absolute angle of rotating system as offset to thetaRef"
      algorithm
        thetaRel := 0;
        annotation(Inline=true);
      end thetaRel;

      redeclare function extends thetaRef
      "Return absolute angle of rotating reference system"
      algorithm
        thetaRef := 0;
        annotation(Inline=true);
      end thetaRef;

      redeclare function extends phase "Return phase"
      algorithm
        phase := 0;
        annotation(Inline=true);
      end phase;

      redeclare replaceable function extends phaseVoltages
      "Return phase to neutral voltages"
      algorithm
        v := 0.5*{V, -V};
        annotation(Inline=true);
      end phaseVoltages;

      redeclare function extends phaseCurrents "Return phase currents"
      algorithm
        i := {I, -I};
        annotation(Inline=true);
      end phaseCurrents;

      redeclare function extends phasePowers "Return phase powers"
      algorithm
        p := {P, 0};
        annotation(Inline=true);
      end phasePowers;

      redeclare function extends phasePowers_vi "Return phase powers"
      algorithm
        p := v.*i;
        annotation(Inline=true);
      end phasePowers_vi;

      redeclare replaceable function extends systemVoltage
      "Return system voltage as function of phase voltages"
      algorithm
        V := v[1] - v[2];
        annotation(Inline=true);
      end systemVoltage;

      redeclare function extends systemCurrent
      "Return system current as function of phase currents"
      algorithm
        I := (i[1] - i[2])/2;
        annotation(Inline=true);
      end systemCurrent;

      redeclare function extends activePower
      "Return total power as function of phase powers"
      algorithm
        P := v*i;
        annotation(Inline=true);
      end activePower;

      annotation (Icon(graphics={Line(
              points={{-70,-28},{50,-28}},
              color={95,95,95},
              smooth=Smooth.None),
                                 Line(
              points={{-70,6},{50,6}},
              color={95,95,95},
              smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package declares the functions that are used to implement
the DC models with double conductors.
</p>
</html>"));
    end TwoConductor;
    annotation (Icon(graphics={Line(
            points={{-70,-52},{50,-52}},
            color={95,95,95},
            smooth=Smooth.None), Line(
            points={{-70,8},{-58,28},{-38,48},{-22,28},{-10,8},{2,-12},{22,-32},{
                40,-12},{50,8}},
            color={95,95,95},
            smooth=Smooth.Bezier)}),
  preferredView="info",
  Documentation(info="<html>
<p>
This package contains a list of packages that represent different type of electric systems.
Each package inherits from <a href=\"modelica://Buildings.Electrical.PhaseSystems.PartialPhaseSystem\">
Buildings.Electrical.PhaseSystems.PartialPhaseSystem</a>.
</p>
<p>
The packages represent various types of electrical systems. The basic idea behind this
approach is to use the same connector for different electrical domains.
Each connector has a replaceable package that inherits from
<a href=\"modelica://Buildings.Electrical.PhaseSystems.PartialPhaseSystem\">
Buildings.Electrical.PhaseSystems.PartialPhaseSystem</a>
depending on the type of electrical system.
The electrical systems represented are:
</p>

<ul>
<li>DC systems,</li>
<li>DC systems with two conductors,</li>
<li>one-phase AC systems,</li>
<li>three-phase resistive balanced AC systems,</li>
<li>three-phase balanced AC systems,</li>
<li>three-phase unbalanced AC systems (dq0 representation).</li>
</ul>

<p>
This approach has been used by the following Modelica libraries:
</p>

<ul>
<li><a href=\"http://www.modelon.com/products/modelica-libraries/electric-power-library\">Electric Power Library</a>,
developed by Modelon,</li>
<li><a href=\"https://github.com/modelica/PowerSystems\">Power Systems Library</a>, and
developed by <a href=\"mailto:Ruediger.Franke@de.abb.com\">Rudiger Franke</a> (ABB).</li>
</ul>

<p>
More details about the phase system packages can be found in <a href=\"#RuedigerEtAl2014\">Franke and Wiesmann (2014)</a>.
</p>
<h4>References</h4>
<p>
<a name=\"RuedigerEtAl2014\"/>
Ruediger Franke and Hansjurg Wiesmann.<br/>
<a href=\"https://www.modelica.org/events/modelica2014/proceedings/html/submissions/ECP14096515_FrankeWiesmann.pdf\">
Flexible modeling of electrical power systems - the Modelica PowerSystems library</a>.<br/>
Proc. of the 10th Modelica Conference, Lund, Sweden, March 2014.
</p>
</html>",   revisions="<html>
<ul>
<li>
May 27, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
</ul>
</html>"));
  end PhaseSystems;

  package Transmission "Package with models for transmission lines"
    extends Modelica.Icons.Package;

    package Functions "Package that contains functions to compute cable properties"
      extends Modelica.Icons.Package;

      function R_AC_correction
        "This function computes the correction factor of the DC resistance for AC systems at 60 Hz"
        input String size "Size of the commercial cable (AWG or kcmil)";
        input ProsNet.Electrical.Transmission.Types.Material material
          "Material of the cable";
        output Real correction "Correction factor";
      algorithm
        if material == ProsNet.Electrical.Transmission.Types.Material.Al then
          if size == "1/0" then
            correction := 1.0;
          elseif size == "2/0" then
            correction := 1.001;
          elseif size == "3/0" then
            correction := 1.001;
          elseif size == "4/0" then
            correction := 1.001;
          elseif size == "250" then
            correction := 1.002;
          elseif size == "300" then
            correction := 1.003;
          elseif size == "350" then
            correction := 1.004;
          elseif size == "400" then
            correction := 1.005;
          elseif size == "500" then
            correction := 1.007;
          elseif size == "600" then
            correction := 1.01;
          elseif size == "700" then
            correction := 1.013;
          elseif size == "750" then
            correction := 1.015;
          elseif size == "800" then
            correction := 1.017;
          elseif size == "1000" then
            correction := 1.026;
          elseif size == "1250" then
            correction := 1.04;
          elseif size == "1500" then
            correction := 1.058;
          elseif size == "1750" then
            correction := 1.079;
          elseif size == "2000" then
            correction := 1.1;
          elseif size == "2500" then
            correction := 1.142;
          else
            correction := 1.0;
          end if;

        elseif material == ProsNet.Electrical.Transmission.Types.Material.Cu then
          if size == "1/0" then
            correction := 1.0;
          elseif size == "2/0" then
            correction := 1.001;
          elseif size == "3/0" then
            correction := 1.002;
          elseif size == "4/0" then
            correction := 1.004;
          elseif size == "250" then
            correction := 1.005;
          elseif size == "300" then
            correction := 1.006;
          elseif size == "350" then
            correction := 1.009;
          elseif size == "400" then
            correction := 1.011;
          elseif size == "500" then
            correction := 1.018;
          elseif size == "600" then
            correction := 1.025;
          elseif size == "700" then
            correction := 1.034;
          elseif size == "750" then
            correction := 1.039;
          elseif size == "800" then
            correction := 1.044;
          elseif size == "1000" then
            correction := 1.067;
          elseif size == "1250" then
            correction := 1.102;
          elseif size == "1500" then
            correction := 1.142;
          elseif size == "1750" then
            correction := 1.185;
          elseif size == "2000" then
            correction := 1.233;
          elseif size == "2500" then
            correction := 1.326;
          else
            correction := 1.0;
          end if;
        else
          assert( material <> ProsNet.Electrical.Transmission.Types.Material.Al
               and material <> ProsNet.Electrical.Transmission.Types.Material.Cu,
                  "In function Buildings.Electrical.Transmission.Functions.R_AC_Correction,
    does not support material " + String(material) + ".
    The selected cable has the R_AC_Correction of the Copper.",
                  level=AssertionLevel.warning);

          correction := 1.0;
        end if;
      annotation(Inline = true, Documentation(revisions="<html>
<ul>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added warning instead of print.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This function computes a correction factor for adapting the DC resistance
when working with AC voltages. The correction factor assumes <i>f = 60 Hz</i>.
</p>
<p>
The correction is based on the type of cabel (AWG or kcmil) and the material.
</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
<th>Type (AWG or kcmil)</th>
<th>Material</th>
<th>Correction factor</th>
</tr>
<!-- ************ -->
<tr>
<td>1/0</td><td>Aluminium</td><td>1.0</td>
</tr>
<!-- ************ -->
<tr>
<td>2/0</td><td>Aluminium</td><td>1.001</td>
</tr>
<!-- ************ -->
<tr>
<td>3/0</td><td>Aluminium</td><td>1.001</td>
</tr>
<!-- ************ -->
<tr>
<td>4/0</td><td>Aluminium</td><td>1.001</td>
</tr>
<!-- ************ -->
<tr>
<td>250</td><td>Aluminium</td><td>1.002</td>
</tr>
<!-- ************ -->
<tr>
<td>300</td><td>Aluminium</td><td>1.003</td>
</tr>
<!-- ************ -->
<tr>
<td>350</td><td>Aluminium</td><td>1.004</td>
</tr>
<!-- ************ -->
<tr>
<td>400</td><td>Aluminium</td><td>1.005</td>
</tr>
<!-- ************ -->
<tr>
<td>500</td><td>Aluminium</td><td>1.007</td>
</tr>
<!-- ************ -->
<tr>
<td>600</td><td>Aluminium</td><td>1.010</td>
</tr>
<!-- ************ -->
<tr>
<td>700</td><td>Aluminium</td><td>1.013</td>
</tr>
<!-- ************ -->
<tr>
<td>750</td><td>Aluminium</td><td>1.015</td>
</tr>
<!-- ************ -->
<tr>
<td>800</td><td>Aluminium</td><td>1.017</td>
</tr>
<!-- ************ -->
<tr>
<td>1000</td><td>Aluminium</td><td>1.026</td>
</tr>
<!-- ************ -->
<tr>
<td>1250</td><td>Aluminium</td><td>1.040</td>
</tr>
<!-- ************ -->
<tr>
<td>1500</td><td>Aluminium</td><td>1.058</td>
</tr>
<!-- ************ -->
<tr>
<td>1750</td><td>Aluminium</td><td>1.079</td>
</tr>
<!-- ************ -->
<tr>
<td>2000</td><td>Aluminium</td><td>1.100</td>
</tr>
<!-- ************ -->
<tr>
<td>2500</td><td>Aluminium</td><td>1.142</td>
</tr>
</table>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
<th>Type (AWG or kcmil)</th>
<th>Material</th>
<th>Correction factor</th>
</tr>
<!-- ************ -->
<tr>
<td>1/0</td><td>Copper</td><td>1.0</td>
</tr>
<!-- ************ -->
<tr>
<td>2/0</td><td>Copper</td><td>1.001</td>
</tr>
<!-- ************ -->
<tr>
<td>3/0</td><td>Copper</td><td>1.002</td>
</tr>
<!-- ************ -->
<tr>
<td>4/0</td><td>Copper</td><td>1.004</td>
</tr>
<!-- ************ -->
<tr>
<td>250</td><td>Copper</td><td>1.005</td>
</tr>
<!-- ************ -->
<tr>
<td>300</td><td>Copper</td><td>1.006</td>
</tr>
<!-- ************ -->
<tr>
<td>350</td><td>Copper</td><td>1.009</td>
</tr>
<!-- ************ -->
<tr>
<td>400</td><td>Copper</td><td>1.011</td>
</tr>
<!-- ************ -->
<tr>
<td>500</td><td>Copper</td><td>1.018</td>
</tr>
<!-- ************ -->
<tr>
<td>600</td><td>Copper</td><td>1.025</td>
</tr>
<!-- ************ -->
<tr>
<td>700</td><td>Copper</td><td>1.034</td>
</tr>
<!-- ************ -->
<tr>
<td>750</td><td>Copper</td><td>1.039</td>
</tr>
<!-- ************ -->
<tr>
<td>800</td><td>Copper</td><td>1.044</td>
</tr>
<!-- ************ -->
<tr>
<td>1000</td><td>Copper</td><td>1.067</td>
</tr>
<!-- ************ -->
<tr>
<td>1250</td><td>Copper</td><td>1.102</td>
</tr>
<!-- ************ -->
<tr>
<td>1500</td><td>Copper</td><td>1.142</td>
</tr>
<!-- ************ -->
<tr>
<td>1750</td><td>Copper</td><td>1.185</td>
</tr>
<!-- ************ -->
<tr>
<td>2000</td><td>Copper</td><td>1.233</td>
</tr>
<!-- ************ -->
<tr>
<td>2500</td><td>Copper</td><td>1.326</td>
</tr>
</table>

</html>"));
      end R_AC_correction;

      function computeGMD
        "This function computes the geometric mean distance of a three-phase transmission line"
        input Modelica.Units.SI.Length d1 "Distance between conductors";
        input Modelica.Units.SI.Length d2=d1 "Distance between conductors";
        input Modelica.Units.SI.Length d3=2*d1 "Distance between conductors";
        output Modelica.Units.SI.Length GMD "Geometric Mean Distance";
      algorithm
        GMD := (d1*d2*d3)^(1.0/3.0);
      annotation(Inline = true, Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the Geometric Mean Distance of a cable.
</p>
<p>
The GMD is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
GMD = (d<sub>1</sub> d<sub>2</sub> d<sub>3</sub>)<sup>1/3</sup>,
</p>
<p>
where <i>d<sub>1</sub></i>, <i>d<sub>2</sub></i>, and <i>d<sub>3</sub></i> are
 the distances between the conductors.
</p>
</html>"));
      end computeGMD;

      function computeGMR
        "This function computes the geometric mean radius of a cable with 1 to 4 conductors"
        input Modelica.Units.SI.Length d "Diameter of the conductor";
        input Integer N = 1 "Number of conductors";
        output Modelica.Units.SI.Length GMR "Geometric Mean Radius";
      algorithm
        assert(N > 0 and N < 5,
          "The number of conductors N must be between 1 and 4, received N=" + String(N) + ".");
        if N==1 then
          GMR := 0.5*d*0.7788;
        elseif N==2 then
          GMR := sqrt(d);
        elseif N==3 then
          GMR := (d^2)^(1/3);
        else // N == 4
          GMR := 1.09*(d^3)^(1/4);
        end if;
      annotation(Inline = true, Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the Geometric Mean Radius (GMR) of a cable.
</p>
<p>
The GMR is computed as follow, depending on the number of conductors <i>N</i>
that are part of the cable, and the diamater of the conductor <i>d</i>.
</p>

<table summary=\"equations\" border = \"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collape;\">
<tr><th>Equation</th><th>Condition</th></tr>
<tr>
<td>0.7788 (d/2) </td>
<td>N = 1</td>
</tr>
<!-- ************ -->
<tr>
<td>d<sup>1/2</sup></td>
<td>N = 2</td>
</tr>
<!-- ************ -->
<tr>
<td>d<sup>2/3</sup></td>
<td>N = 3</td>
</tr>
<!-- ************ -->
<tr>
<td>d<sup>2/3</sup></td>
<td>N = 4</td>
</tr>
<!-- ************ -->
</table>

</html>"));
      end computeGMR;

      function selectCable_low "This function is used to automatically select the
    type of cable for low voltages"
        input Modelica.Units.SI.Power P_nominal=0 "Rated power";
        input Modelica.Units.SI.Voltage V_nominal=0 "Rated voltage";
        output ProsNet.Electrical.Transmission.LowVoltageCables.Generic cable "Cable";
      protected
        parameter Real safety_factor = 1.2;
        Modelica.Units.SI.Current I_nominal
          "Nominal current flowing through the line";
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu10 cu10;
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu20 cu20;
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu25 cu25;
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu35 cu35;
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu50 cu50;
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu95 cu95;
        ProsNet.Electrical.Transmission.LowVoltageCables.Cu100 cu100;
      algorithm

        assert( Transmission.Functions.selectVoltageLevel(V_nominal) == ProsNet.Electrical.Types.VoltageLevel.Low,
                "In function Buildings.Electrical.Transmission.Functions.selectCable_low,
  cable autosizing has a nominal Voltage " + String(V_nominal) + " [V].
  The low voltage cables do not support such a voltage level.",
                level=AssertionLevel.error);

        // Check if it's possible to compute the current
        if V_nominal > 0 then
          I_nominal :=safety_factor*P_nominal/V_nominal;
        else
          I_nominal :=0;
        end if;

        // Assumed the material is Copper
        if I_nominal < cu10.Amp then
              cable := cu10;
        elseif I_nominal >= cu10.Amp and I_nominal < cu20.Amp then
              cable := cu20;
        elseif I_nominal >= cu20.Amp and I_nominal < cu25.Amp then
              cable := cu25;
        elseif I_nominal >= cu25.Amp and I_nominal < cu35.Amp then
              cable := cu35;
        elseif I_nominal >= cu35.Amp and I_nominal < cu50.Amp then
              cable := cu50;
        elseif I_nominal >= cu50.Amp and I_nominal < cu95.Amp then
              cable := cu95;
        elseif I_nominal >= cu95.Amp and I_nominal < cu100.Amp then
              cable := cu100;
        else
          assert(I_nominal < cu100.Amp,
      "In function Buildings.Electrical.Transmission.Functions.selectCable_low,
  cable autosizing does not support a current of "       + String(I_nominal) + " [A].
  The selected cable will be undersized.",
        level=AssertionLevel.warning);
              cable := cu100;
        end if;
      annotation(Inline = true, Documentation(revisions="<html>
<ul>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added warning instead of print.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This function selects the default cable for a low voltage
transmission line.
</p>
<p>
The function takes as inputs the nominal voltage <i>V<sub>nominal</sub></i> and the
nominal power <i>P<sub>nominal</sub></i>. It computes the maximum current current that
can flow through the cable as
</p>
<p align=\"center\" style=\"font-style:italic;\">
I<sub>MAX</sub> = S<sub>F</sub> P<sub>nominal</sub> / V<sub>nominal</sub>,
</p>
<p>
where <i>S<sub>F</sub></i> is the safety factor. By default the safety factor is equal to <i>1.2</i>.
</p>
<p>
Using <i>I<sub>MAX</sub></i>, the function selects the smallest cable that has an ampacity
higher than I<sub>MAX</sub>. The cables are selected from
<a href=\"modelica://Buildings.Electrical.Transmission.LowVoltageCables\">
Buildings.Electrical.Transmission.LowVoltageCables</a>.
</p>
</html>"));
      end selectCable_low;

      function selectCable_med "This function is used to automatically select the
    type of cable for medium voltages"
        input Modelica.Units.SI.Power P_nominal=0 "Rated power";
        input Modelica.Units.SI.Voltage V_nominal=0 "Rated voltage";
        output ProsNet.Electrical.Transmission.MediumVoltageCables.Generic cable "Cable";
      protected
        parameter Real safety_factor = 1.2;
        Modelica.Units.SI.Current I_nominal
          "Nominal current flowing through the line";
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_10 Al10;
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_30 Al30;
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_40 Al40;
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_350 Al350;
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_500 Al500;
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_1000 Al1000;
        ProsNet.Electrical.Transmission.MediumVoltageCables.Annealed_Al_1500 Al1500;
      algorithm

        assert( Transmission.Functions.selectVoltageLevel(V_nominal) == ProsNet.Electrical.Types.VoltageLevel.Medium,
                "In function Buildings.Electrical.Transmission.Functions.selectCable_med,
  cable autosizing has a nominal Voltage " + String(V_nominal) + " [V].
  The medium voltage cables do not support such a voltage level.",
                level=AssertionLevel.error);

        // Check if it's possible to compute the current
        if V_nominal > 0 then
          I_nominal :=safety_factor*P_nominal/V_nominal;
        else
          I_nominal :=0;
        end if;

        // Assumed the material is Copper
        if I_nominal < Al10.Amp then
              cable := Al10;
        elseif I_nominal >= Al10.Amp and I_nominal < Al30.Amp then
              cable := Al30;
        elseif I_nominal >= Al30.Amp and I_nominal < Al40.Amp then
              cable := Al40;
        elseif I_nominal >= Al40.Amp and I_nominal < Al350.Amp then
              cable := Al350;
        elseif I_nominal >= Al350.Amp and I_nominal < Al500.Amp then
              cable := Al500;
        elseif I_nominal >= Al500.Amp and I_nominal < Al1000.Amp then
              cable := Al1000;
        elseif I_nominal >= Al1000.Amp and I_nominal < Al1500.Amp then
              cable := Al1500;
        else
          assert(I_nominal < Al1500.Amp,
      "Warning: In function Buildings.Electrical.Transmission.Functions.selectCable_med,
  cable autosizing does not support a current of "       + String(I_nominal) + " [A].
  The selected cable will be undersized.",
        level=AssertionLevel.warning);

              cable := Al10;
        end if;
      annotation(Inline = true, Documentation(revisions="<html>
<ul>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added warning instead of print.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This function selects the default cable for a medium voltage
transmission line.
</p>
<p>
The function takes as inputs the nominal voltage <i>V<sub>nominal</sub></i> and the
nominal power <i>P<sub>nominal</sub></i>. It computes the maximum current current that
can flow through the cable as
</p>
<p align=\"center\" style=\"font-style:italic;\">
I<sub>MAX</sub> = S<sub>F</sub> P<sub>nominal</sub> / V<sub>nominal</sub>,
</p>
<p>
where <i>S<sub>F</sub></i> is the safety factor. By default the safety factor is equal to <i>1.2</i>.
</p>
<p>
Using <i>I<sub>MAX</sub></i>, the function selects the smallest cable that has an ampacity
higher than I<sub>MAX</sub>. The cables are selected from
<a href=\"modelica://Buildings.Electrical.Transmission.MediumVoltageCables\">
Buildings.Electrical.Transmission.MediumVoltageCables</a>.
</p>
</html>"));
      end selectCable_med;

      function selectVoltageLevel
        "This function computes the voltage level (low, medium or high) given the nominal voltage"
        input Modelica.Units.SI.Voltage V "Nominal voltage";
        output ProsNet.Electrical.Types.VoltageLevel level
          "Type of voltage level";
      algorithm
        if V <= 0 then
          assert(V > 0,
           "In function Buildings.Electrical.Transmission.Functions.selectVoltageLevel,
      does not support a voltage of "       + String(V) + " [V].
      The selected voltage level will be assumed to be low.",
            level = AssertionLevel.warning);
          level := ProsNet.Electrical.Types.VoltageLevel.Low;
        elseif V <= 1000 then
          level := ProsNet.Electrical.Types.VoltageLevel.Low;
        elseif V > 1000 and V <= 50000 then
          level := ProsNet.Electrical.Types.VoltageLevel.Medium;
        else
          level := ProsNet.Electrical.Types.VoltageLevel.High;
        end if;
      annotation(Inline = true, Documentation(revisions="<html>
<ul>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added warning instead of print.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the voltage level for a given voltage.
The computation is as follows:
</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
<th>Condition</th>
<th>Voltage Level</th>
</tr>
<!-- ************ -->
<tr>
<td><i>0 &le; V &lt; 1 kV</i></td>
<td>Low voltage</td>
</tr>
<!-- ************ -->
<tr>
<td><i>1 kV &le; V &lt; 50 kV</i></td>
<td>Medium voltage</td>
</tr>
<!-- ************ -->
<tr>
<td><i> V &ge; 50 kV</i></td>
<td>HIgh voltage</td>
</tr>
</table>

</html>"));
      end selectVoltageLevel;

      package Validation
        extends Modelica.Icons.ExamplesPackage;

        model SelectCable_low
          "Validation model for the function that selects the cable"
          extends Modelica.Icons.Example;

          parameter Modelica.Units.SI.Voltage V_nominal=480 "Rated voltage";

          parameter Modelica.Units.SI.Power[:] P_nominal=I_nominal*V_nominal/
              safety_factor "Rated power";
          parameter Modelica.Units.SI.Current[:] I_nominal={65,95,110,130,170,220,230}
               .- 10 "Nominal current";

          parameter Real safety_factor = 1.2 "Safety factor";

          parameter ProsNet.Electrical.Transmission.LowVoltageCables.Generic[:]
            cab=ProsNet.Electrical.Transmission.Functions.selectCable_low(
              P_nominal=P_nominal, V_nominal=V_nominal) "Selected cable";

        annotation (
        experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(
        file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/Transmission/Functions/Validation/SelectCable_low.mos"
        "Simulate and plot"),
        Documentation(info="<html>
<p>
This model validates
<a href=\"modelica://Buildings.Electrical.Transmission.Functions.selectCable_low\">
Buildings.Electrical.Transmission.Functions.selectCable_low</a>
for a different range of currents.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SelectCable_low;

        model SelectCable_med
          "Validation model for the function that selects the cable"
          extends Modelica.Icons.Example;

          parameter Modelica.Units.SI.Voltage V_nominal=25e3 "Rated voltage";

          parameter Modelica.Units.SI.Power[:] P_nominal=I_nominal*V_nominal/
              safety_factor "Rated power";
          parameter Modelica.Units.SI.Current[:] I_nominal={195,250,285,375,450,640,800}
               .- 10 "Nominal current";

          parameter Real safety_factor = 1.2 "Safety factor";

          parameter ProsNet.Electrical.Transmission.MediumVoltageCables.Generic[
            :] cab=ProsNet.Electrical.Transmission.Functions.selectCable_med(
              P_nominal=P_nominal, V_nominal=V_nominal) "Selected cable";

        annotation (
        experiment(Tolerance=1e-6, StopTime=1.0),
          __Dymola_Commands(
        file="modelica://Buildings/Resources/Scripts/Dymola/Electrical/Transmission/Functions/Validation/SelectCable_med.mos"
        "Simulate and plot"),
        Documentation(info="<html>
<p>
This model validates
<a href=\"modelica://Buildings.Electrical.Transmission.Functions.selectCable_med\">
Buildings.Electrical.Transmission.Functions.selectCable_med</a>
for a different range of currents.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 25, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end SelectCable_med;
      annotation (Documentation(info="<html>
<p>
This package contains validation models for the classes in
<a href=\"modelica://Buildings.Electrical.Transmission.Functions\">
Buildings.Electrical.Transmission.Functions</a>.
</p>
<p>
Note that most validation models contain simple input data which may not be realistic,
but for which the correct output can be obtained through an analytic solution.
The examples plot various outputs, which have been verified against these solutions.
These model outputs are stored as reference data and used for continuous validation
whenever models in the library change.
</html>"));
      end Validation;
    annotation (Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",     info="<html>
<p>
This package contains various functions that are used to compute
cable properties and select the default cable during
automatic parametrization.
</p>
</html>"));
    end Functions;

    package Grids "Package that contains different types of grids"
      extends Modelica.Icons.MaterialPropertiesPackage;

      record IEEE_34_AL120 "Grid model inspired to the IEEE 34 Node test feeder"
        extends ProsNet.Electrical.Transmission.Grids.PartialGrid(
          nNodes=34,
          nLinks=33,
          l=[48; 16; 16; 40; 32; 16; 16; 16; 16; 16; 16; 32; 32; 16; 32; 32; 32;
              48; 48; 32; 32; 16; 16; 16; 16; 16; 32; 32; 16; 32; 16; 16; 16],
          fromTo=[[1,2]; [2,3]; [3,4]; [4,5]; [4,6]; [6,7]; [7,8]; [9,26]; [10,
              26]; [11,9]; [12,11]; [13,10]; [14,10]; [15,14]; [16,15]; [17,27];
              [18,27]; [19,31]; [20,31]; [21,32]; [22,32]; [23,20]; [24,23]; [
              25,24]; [26,8]; [27,29]; [28,16]; [29,16]; [30,17]; [31,17]; [32,
              19]; [33,22]; [34,18]],
          redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Generic
            cables={LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl120(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl70(),
              LowVoltageCables.PvcAl70(),LowVoltageCables.PvcAl35(),
              LowVoltageCables.PvcAl35(),LowVoltageCables.PvcAl35(),
              LowVoltageCables.PvcAl35(),LowVoltageCables.PvcAl35(),
              LowVoltageCables.PvcAl35(),LowVoltageCables.PvcAl35(),
              LowVoltageCables.PvcAl120(),LowVoltageCables.PvcAl70(),
              LowVoltageCables.PvcAl70(),LowVoltageCables.PvcAl70(),
              LowVoltageCables.PvcAl70(),LowVoltageCables.PvcAl70(),
              LowVoltageCables.PvcAl35(),LowVoltageCables.PvcAl35(),
              LowVoltageCables.PvcAl70()});

         /*
   LEFT HERE TO CHECK CONSISTENCY

   LenVec={
   0,48,16,16,40,
   32,16,16,16,16,
   16,16,32,32,16,
   32,32,32,48,48,
   32,32,16,16,16,
   16,16,32,32,16,
   32,16,16,16},

    CabTyp={
               ,.PvcAl120(),.PvcAl120(),.PvcAl120(),.PvcAl120(),
    .PvcAl120(),.PvcAl120(),.PvcAl120(),.PvcAl120(),.PvcAl120(),
    .PvcAl120(),.PvcAl120(),.PvcAl120(),.PvcAl120(),.PvcAl120(),
    .PvcAl120(),.PvcAl70(),.PvcAl70(),.PvcAl35(),.PvcAl35(),
    .PvcAl35(),.PvcAl35(),.PvcAl35(),.PvcAl35(),.PvcAl35(),
    .PvcAl120(),.PvcAl70(),.PvcAl70(),.PvcAl70(),.PvcAl70(),
    .PvcAl70(),.PvcAl35(),.PvcAl35(),.PvcAl70()});

   */
        annotation (Documentation(info="<html>
<p> This model represents a grid inspired by the IEEE 34 node test feeder.
In this example, the cable types and lengths have been modified in order to
represent a typical distribution feeder.</p>
<p>The following three type of cables are in the grid: AL120, AL70, and Al35.
</p>
<p><img alt=\"alt-image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/IEEE_34.png\"/></p>
</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added redeclare statement needed to specify the type of cables used in the array.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end IEEE_34_AL120;

      record PartialGrid "Partial model that represents a generalized grid"
        extends Modelica.Icons.MaterialProperty;
        parameter Integer nNodes "Number of nodes of the grid";
        parameter Integer nLinks "Number of links connecting the nodes";
        parameter Integer fromTo[nLinks,2]
          "Indexes [i,1]->[i,2] of the nodes connected by link i";
        parameter Modelica.Units.SI.Length l[nLinks,1](each min=0)
          "Length of the cable";
        replaceable ProsNet.Electrical.Transmission.BaseClasses.BaseCable cables[nLinks]
          "Array that contains the characteristics of each cable";
        annotation (Documentation(info="<html>
<p>
This abstract grid model specifies the topology of the network by
</p>
<ul>
<li>the number of nodes,</li>
<li>the number of links,</li>
<li>the length of links, and</li>
<li>the connection between links and nodes.</li>
</ul>
<p>
The picture below describes the meaning of the
values contained in the matrices.
</p>

<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/partialGrid.png\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Revised model structure. Now the type of the cable is replaceable
so it's possible to use either low voltage or medium voltage cable.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                textColor={0,0,255},
                extent={{-154,104},{146,144}},
                textString="%name")}));
      end PartialGrid;

      record TestGrid2Nodes "Simple model of a grid with 2 nodes and 1 link"
        extends ProsNet.Electrical.Transmission.Grids.PartialGrid(
          nNodes=2,
          nLinks=1,
          fromTo=[[1,2]],
          l=[200],
          redeclare ProsNet.Electrical.Transmission.LowVoltageCables.Generic
            cables={LowVoltageCables.Cu35()});
        annotation (Documentation(info="<html>
<p>
This model represents a simple grid with two nodes and a single link between them.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added redeclare statement needed to specify the type of cables used in the array.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end TestGrid2Nodes;

      record TestGrid2NodesMedium
        "Simple model of a grid with 2 nodes and 1 link for medium voltage"
        extends ProsNet.Electrical.Transmission.Grids.PartialGrid(
          nNodes=2,
          nLinks=1,
          fromTo=[[1,2]],
          l=[200],
          redeclare ProsNet.Electrical.Transmission.MediumVoltageCables.Generic
            cables={MediumVoltageCables.Annealed_Al_30()});
        annotation (Documentation(info="<html>
<p>
This model represents a simple grid with two nodes and a single link between them.
This model differs from
<a href=\"modelica://Buildings.Electrical.Transmission.Grids.TestGrid2Nodes\">
Buildings.Electrical.Transmission.Grids.TestGrid2Nodes</a> because it defines a medium voltage
cable instead of a low voltage cable.
</p>
<p>
The picture below describes the grid topology.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Transmission/Grids/testGrid2Nodes.png\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added redeclare statement needed to specify the type of cables used in the array.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end TestGrid2NodesMedium;
    annotation (Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",     info="<html>
<p>
This package contains different types of grids that can be used to represent
electrical networks. The topology of the network is specified by
</p>
<ul>
<li>the number of nodes,</li>
<li>the number of links,</li>
<li>the length of links, and</li>
<li>the connection between links and nodes.</li>
</ul>
</html>"));
    end Grids;

    package LowVoltageCables "Package of low voltage electricity cables used in distribution grid"
      extends Modelica.Icons.MaterialPropertiesPackage;

      record Cu10 "Cu cable 10 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=65,
          RCha=1.81e-003,
          XCha=0.076e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 10mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 1.810-003 // Characteristic resistance [Ohm/m]
XCha = 0.076e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu10;

      record Cu100 "Cu cable 100 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=230,
          RCha=0.181e-003,
          XCha=0.072e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 100mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.181e-003 // Characteristic resistance [Ohm/m]
XCha = 0.072e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu100;

      record Cu20 "Cu cable 20 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=95,
          RCha=0.905e-003,
          XCha=0.075e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 20mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.905e-003 // Characteristic resistance [Ohm/m]
XCha = 0.075e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu20;

      record Cu25 "Cu cable 25 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=110,
          RCha=0.727e-003,
          XCha=0.075e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 25mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.727e-003 // Characteristic resistance [Ohm/m]
XCha = 0.075e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu25;

      record Cu35 "Cu cable 35 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=130,
          RCha=0.517e-003,
          XCha=0.074e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 35mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.517e-003 // Characteristic resistance [Ohm/m]
XCha = 0.074e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu35;

      record Cu50 "Cu cable 50 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=170,
          RCha=0.362e-003,
          XCha=0.073e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 50mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.362e-003 // Characteristic resistance [Ohm/m]
XCha = 0.073e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu50;

      record Cu95 "Cu cable 95 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Cu,
          M=234.5 + 273.15,
          Amp=220,
          RCha=0.191e-003,
          XCha=0.072e-003);
        annotation (Documentation(info="<html>
<p>
Copper cable with a cross-sectional area of 95mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.191e-003 // Characteristic resistance [Ohm/m]
XCha = 0.072e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Cu95;

      record Generic "Data record for a generic low voltage cable"
        extends Modelica.Icons.MaterialProperty;
        extends ProsNet.Electrical.Transmission.BaseClasses.BaseCable;
        parameter ProsNet.Electrical.Types.CharacteristicResistance RCha(start=0)
          "Characteristic resistance of the cable";
        parameter ProsNet.Electrical.Types.CharacteristicReactance XCha(start=0)
          "Characteristic reactance of the cable";

        redeclare function extends lineResistance
          "Function that computes the resistance of a cable"
         input ProsNet.Electrical.Transmission.LowVoltageCables.Generic cable
            "Record that contains cable properties";
        algorithm
            R :=cable.RCha*l;
            annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the overall resistance of a cable.
</p>

<p>
The low voltage cable is described by a characteristic resistance per unit
length, given this value the overall resistance is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
R = R<sub>CHA</sub> l<sub>CABLE</sub>,
</p>
<p>
where <i>R<sub>CHA</sub></i> is the characteristic resistance per unit length, and
<i>l<sub>CABLE</sub></i> is the length of the cable.
</p>
</html>"));
        end lineResistance;

        redeclare function extends lineInductance
          "Function that computes the resistance of a cable"
         input ProsNet.Electrical.Transmission.LowVoltageCables.Generic cable
            "Record that contains cable properties";
        algorithm
            L := l*(cable.XCha/omega);
            annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the overall inductance of a cable.
</p>
<p>
When the voltage level is low, the cables have a characteristic reactance per unit
length, which is specified at <i>f = 50 Hz</i>.
The overall inductance is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
L = (X<sub>CHA</sub>/&omega;) l<sub>CABLE</sub>,
</p>
<p>
where <i>X<sub>CHA</sub></i> is the characteristic reactance per unit length,
<i>&omega; = 2 &pi; f</i> is the angular velocity, and <i>l<sub>CABLE</sub></i> is
the length of the cable.
</p>
</html>"));
        end lineInductance;

        redeclare function extends lineCapacitance
          "Function that computes the capacitance of a cable"
         input ProsNet.Electrical.Transmission.LowVoltageCables.Generic cable
            "Record that contains cable properties";
        algorithm
            C := 0.0;
            annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the overall capacity of a cable.
</p>
<p>
When the voltage level is low, the cables do not consider the capacitive effect. Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
C = 0.
</p>
</html>"));
        end lineCapacitance;

        annotation (Documentation(info="<html>
<p>
This is a base record for specifying physical properties for low
voltage commercial cables. New cables can be added by extending the
it.
</p>
<p>
For low voltage cables, only the characteristic resistance and reactance are
specified.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Revised structure of the record, not it extends the base records
and add details for the low voltage cables.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Generic;

      record PvcAl120 "Aluminum cable 120mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.269e-003,
          XCha=0.071e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 120mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.269e-003 // Characteristic resistance [Ohm/m]
XCha = 0.071e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl120;

      record PvcAl120_ECM "Aluminum cable 120mm^2"
          extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.278e-003,
          XCha=0.071e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 120mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 0.278e-003 // Characteristic resistance [Ohm/m]
XCha = 0.071e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl120_ECM;

      record PvcAl150 "Aluminum cable 150mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.206e-003,
          XCha=0.070e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 150mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.206e-003 // Characteristic resistance [Ohm/m]
XCha = 0.070e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl150;

      record PvcAl16 "Aluminum cable 16 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=2.105e-003,
          XCha=0.076e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 16mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 2.105e-003 // Characteristic resistance [Ohm/m]
XCha = 0.076e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl16;

      record PvcAl16_ECM "Aluminum cable 16 mm^2"
          extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=2.105e-003,
          XCha=0.076e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 16mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 2.105e-003 // Characteristic resistance [Ohm/m]
XCha = 0.076e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl16_ECM;

      record PvcAl25 "Aluminum cable 25 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=1.292e-003,
          XCha=0.075e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 25mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 1.292e-003 // Characteristic resistance [Ohm/m]
XCha = 0.075e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl25;

      record PvcAl25_ECM "Aluminum cable 25 mm^2"
          extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=1.32e-003,
          XCha=0.075e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 25mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 1.320e-003 // Characteristic resistance [Ohm/m]
XCha = 0.075e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl25_ECM;

      record PvcAl35 "Aluminum cable 35 mm^2"
      extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.923e-003,
          XCha=0.074e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 35mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 0.923e-003 // Characteristic resistance [Ohm/m]
XCha = 0.074e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl35;

      record PvcAl35_ECM "Aluminum cable 35 mm^2"
          extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.956e-003,
          XCha=0.074e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 35mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 0.956e-003 // Characteristic resistance [Ohm/m]
XCha = 0.074e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl35_ECM;

      record PvcAl50 "Aluminum cable 50 mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.641e-003,
          XCha=0.073e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 50mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.641e-003 // Characteristic resistance [Ohm/m]
XCha = 0.073e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl50;

      record PvcAl70 "Aluminum cable 70mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.5071e-003,
          XCha=0.072e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 70mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.5071e-003 // Characteristic resistance [Ohm/m]
XCha = 0.072e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl70;

      record PvcAl70_ECM "Aluminum cable 70mm^2"
          extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.488e-003,
          XCha=0.072e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 70mm^2, ECM type.
This type of cable has the following properties
</p>
<pre>
RCha = 0.488e-003 // Characteristic resistance [Ohm/m]
XCha = 0.072e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl70_ECM;

      record PvcAl75 "Aluminum cable 75mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.431e-003,
          XCha=0.072e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 75mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.431e-003 // Characteristic resistance [Ohm/m]
XCha = 0.072e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl75;

      record PvcAl95 "Aluminum cable 95mm^2"
        extends ProsNet.Electrical.Transmission.LowVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          RCha=0.320e-003,
          XCha=0.072e-003);
        annotation (Documentation(info="<html>
<p>
Aluminium cable with a cross-sectional area of 95mm^2.
This type of cable has the following properties
</p>
<pre>
RCha = 0.320e-003 // Characteristic resistance [Ohm/m]
XCha = 0.072e-003 // Characteristic reactance [Ohm/m]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PvcAl95;
    annotation (Documentation(info="<html>
<p>
This package contains records of physical properties for low
voltage commercial cables. New cables can be added by extending the
base record
<a href=\"modelia://Buildings.Electrical.Transmission.LowVoltageCables.Generic\">
Buildings.Electrical.Transmission.LowVoltageCables.Generic</a>.
</p>
<p>
For low voltage cables, only the characteristic resistance and reactance are
specified. See <a href=\"modelia://Buildings.Electrical.Transmission.Base.BaseCable\">
Buildings.Electrical.Transmission.Base.BaseCable</a> for a comprehensive list of
parameters that can be specified for a cable.
</p>
</html>",     revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
    end LowVoltageCables;

    package MediumVoltageCables "Package of medium voltage electricity cables used in distribution grid"
      extends Modelica.Icons.MaterialPropertiesPackage;

      record Annealed_Al_10 "Annealed Al cable - AWG 1/0"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="1/0",
          Rdc=0.551181e-3,
          T_ref=298.15,
          d=9.195e-3,
          D=26.543e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=195);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional AWG 1/0
(American Wire Gauge).
This type of cable has the following properties
</p>
<pre>
Rdc  = 0.551181e-3 // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 9.195e-3    // Inner diameter [m]
D    = 26.543e-3   // Outer diameter [m]
Amp  = 195         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_10;

      record Annealed_Al_1000 "Annealed Al cable - AWG 1000"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="1000",
          Rdc=5.80709e-5,
          T_ref=298.15,
          d=28.372e-3,
          D=46.101e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=640);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional kcmil 1000
(thousand of Circular Mils).
This type of cable has the following properties
</p>
<pre>
Rdc  = 5.80709e-5  // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 28.372e-3   // Inner diameter [m]
D    = 46.101e-3   // Outer diameter [m]
Amp  = 640         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_1000;

      record Annealed_Al_1500 "Annealed Al cable - AWG 1500"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="1500",
          Rdc=3.87139e-5,
          T_ref=298.15,
          d=34.798e-3,
          D=53.34e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=800);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional kcmil 1500
(thousand of Circular Mils).
This type of cable has the following properties
</p>
<pre>
Rdc  = 3.87139e-5 // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 34.798e-3   // Inner diameter [m]
D    = 53.34e-3   // Outer diameter [m]
Amp  = 800         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_1500;

      record Annealed_Al_30 "Annealed Al cable - AWG 3/0"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="3/0",
          Rdc=0.344488e-3,
          T_ref=298.15,
          d=11.582e-3,
          D=28.956e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=250);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional AWG 2/0
(American Wire Gauge).
This type of cable has the following properties
</p>
<pre>
Rdc  = 0.344488e-3 // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 11.582e-3   // Inner diameter [m]
D    = 28.956e-3   // Outer diameter [m]
Amp  = 250         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_30;

      record Annealed_Al_350 "Annealed Al cable - kcmil 350"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="350",
          Rdc=0.165682e-3,
          T_ref=298.15,
          d=16.789e-3,
          D=34.417e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=375);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional kcmil 350
(thousand of Circular Mils).
This type of cable has the following properties
</p>
<pre>
Rdc  = 0.165682e-3 // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 16.789e-3   // Inner diameter [m]
D    = 34.417e-3   // Outer diameter [m]
Amp  = 375         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_350;

      record Annealed_Al_40 "Annealed Al cable - AWG 4/0"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="4/0",
          Rdc=0.274278e-3,
          T_ref=298.15,
          d=13.005e-3,
          D=30.353e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=285);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional AWG 4/0
(American Wire Gauge).
This type of cable has the following properties
</p>
<pre>
Rdc  = 0.274278e-3 // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 13.005e-3   // Inner diameter [m]
D    = 30.353e-3   // Outer diameter [m]
Amp  = 285         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_40;

      record Annealed_Al_500 "Annealed Al cable - AWG 500"
        extends ProsNet.Electrical.Transmission.MediumVoltageCables.Generic(
          material=Types.Material.Al,
          M=228.1 + 273.15,
          size="500",
          Rdc=0.116142e-3,
          T_ref=298.15,
          d=20.066e-3,
          D=37.592e-3,
          GMR=ProsNet.Electrical.Transmission.Functions.computeGMR(d),
          GMD=ProsNet.Electrical.Transmission.Functions.computeGMD(0.1905),
          Amp=450);
        annotation (Documentation(info="<html>
<p>
Annealed aluminium cable with a cross-sectional kcmil 500
(thousand of Circular Mils).
This type of cable has the following properties
</p>
<pre>
Rdc  = 0.116142e-3 // Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref= 298.15      // Reference temperature of the material [K]
d    = 20.066e-3   // Inner diameter [m]
D    = 37.592e-3   // Outer diameter [m]
Amp  = 450         // Ampacity [A]
</pre>
</html>",       revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Annealed_Al_500;

      record Generic "Data record for a generic medium voltage cable"
        extends Modelica.Icons.MaterialProperty;
        extends ProsNet.Electrical.Transmission.BaseClasses.BaseCable;
        parameter String size(start="")
          "AWG or kcmil code representing the conductor size";
        parameter ProsNet.Electrical.Types.CharacteristicResistance Rdc(start=0)
          "Characteristic DC resistance of the cable @ T_ref";
        parameter Modelica.Units.SI.Length d "Inner diameter";
        parameter Modelica.Units.SI.Length D "Outer diameter";
        parameter Modelica.Units.SI.Length GMR "Geometrical Mean Radius of the cable";
        parameter Modelica.Units.SI.Length GMD
          "Geometrical Mean Diameter of the cable";

        redeclare function extends lineResistance
          "Function that computes the resistance of a cable"
            input ProsNet.Electrical.Transmission.MediumVoltageCables.Generic cable
            "Record that contains cable properties";
        algorithm
          R := l*cable.Rdc*
            ProsNet.Electrical.Transmission.Functions.R_AC_correction(cable.size,
            cable.material);
            annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the overall resistance of a cable.
</p>
<p>
When the voltage level is medium or high, the cables have a DC resistance that needs
to be corrected to account for the effects cause by the AC voltage.
The correction is
</p>
<p align=\"center\" style=\"font-style:italic;\">
R = l<sub>CABLE</sub> R<sub>DC</sub> f<sub>CORR</sub>(s, m),
</p>
<p>
where <i>R<sub>DC</sub> </i> is the characteristic DC resistance per unit length,
<i>l<sub>CABLE</sub></i> is the length of the cable, and
<i>f<sub>CORR</sub>(s, m)</i> is a function that corrects the DC value and depends on the
size of the cable <i>s</i> and its material <i>m</i>. See
<a href=\"modelica://Buildings.Electrical.Transmission.Functions.R_AC_correction\">
Buildings.Electrical.Transmission.Functions.R_AC_correction</a> for more details.
</p>

</html>"));
        end lineResistance;

        redeclare function extends lineInductance
          "Function that computes the resistance of a cable"
          input ProsNet.Electrical.Transmission.MediumVoltageCables.Generic cable
            "Record that contains cable properties";
        algorithm
          L := l*2e-7*log(cable.GMD/cable.GMR);
            annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the overall inductance of a cable.
</p>
<p>
When the voltage level is medium or high, the cables have geometric parameters that can
be used to compute the inductance as
</p>
<p align=\"center\" style=\"font-style:italic;\">
R = l<sub>CABLE</sub> 2 10<sup>-7</sup> log(GMD/GMR),
</p>
<p>
where <i>l<sub>CABLE</sub></i> is the length of the cable, and
<i>GMD</i> and <i>GMR</i> are the geometric mean distance and the geometric mean radius
of the cable.
</p>
</html>"));
        end lineInductance;

        redeclare function extends lineCapacitance
          "Function that computes the capacitance of a cable"
          input ProsNet.Electrical.Transmission.MediumVoltageCables.Generic cable
            "Record that contains cable properties";
        protected
          Modelica.Units.SI.Length r "Radius";
        algorithm
          r := cable.d/2.0;
          C := l*2*Modelica.Constants.pi*Modelica.Constants.epsilon_0/log(cable.GMD/r);
            annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>",       info="<html>
<p>
This function computes the overall capacity of a cable.
</p>
<p>
When the voltage level is medium or high, the cables have geometric parameters that can
be used to compute the capacity as
</p>
<p align=\"center\" style=\"font-style:italic;\">
C = l<sub>CABLE</sub> 2 &pi; &epsilon;<sub>0</sub>/log(GMD/r),
</p>
<p>
where <i>l<sub>CABLE</sub></i> is the length of the cable,
<i>&epsilon;<sub>0</sub></i> is the dielectric constant of the air, <i>GMD</i>
is the geometric mean distance, and <i>r = d/2</i> where <i>d</i> is the inner
diameter of the cable.
</p>
</html>"));
        end lineCapacitance;

        annotation (Documentation(info="<html>
<p>
This is a base record for specifying physical properties for medium
voltage commercial cables. New cables can be added by extending
it.
</p>
<p>
For medium voltage cables, the geometric properties of the cable and the material are
specified. For example some of the properties that are specified are:
</p>
<pre>
Rdc   : Characteristic DC resistance at T = T_ref[Ohm/m]
T_ref : Reference temperature of the material [K]
d     : Inner diameter [m]
D     : Outer diameter [m]
Amp   : Ampacity [A]
</pre>
<p>
other properties such as the geometric mean diameter GMD and the
geometric mean radius GMR are by default computed using functions,
but this can be overriden.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Revised structure of the record, not it extends the base records
and add details for the medium voltage cables.
</li>
<li>
Sept 19, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end Generic;
    annotation (Documentation(info="<html>
<p>
This package contains records of physical properties of medium
voltage commercial cables. New cables can be added by extending the
base record
<a href=\"modelia://Buildings.Electrical.Transmission.MediumVoltageCables.Generic\">
Buildings.Electrical.Transmission.MediumVoltageCables.Generic</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
    end MediumVoltageCables;

    package Types "Package that contains cables materials"
      extends Modelica.Icons.TypesPackage;

      type Material = enumeration(
          Cu "Copper",
          Al "Aluminium") "Material of the cable" annotation (Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
Enumeration for materials that can be used
for cables.
</p>
</html>"));
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
This package contains an enumeration for materials.
</p>
</html>",     revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
    end Types;

    package BaseClasses "Package that contains partial models for lines and cables"
      extends Modelica.Icons.BasesPackage;

      partial model PartialBaseLine "Partial cable line dispersion model"
        parameter Modelica.Units.SI.Length l(min=0) "Length of the line";
        parameter Modelica.Units.SI.Power P_nominal(min=0)
          "Nominal power of the line";
        parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=220)
          "Nominal voltage of the line";
        final parameter Modelica.Units.SI.Frequency f_n=50
          "Frequency considered in the definition of cables properties";

        parameter Boolean use_C = false
          "Set to true to add a capacitance in the center of the line"
          annotation(Evaluate=true, Dialog(tab="Model", group="Assumptions"));
        parameter ProsNet.Electrical.Types.Load modelMode=ProsNet.Electrical.Types.Load.FixedZ_steady_state
          "Select between steady state and dynamic model" annotation (
          Evaluate=true,
          Dialog(
            tab="Model",
            group="Assumptions",
            enable=use_C),
          choices(choice=Buildings.Electrical.Types.Load.FixedZ_steady_state
              "Steady state", choice=Buildings.Electrical.Types.Load.FixedZ_dynamic
              "Dynamic"));
        parameter Boolean use_T = false
          "If true, enables the input for the temperature of the cable" annotation(Evaluate = true, Dialog(tab="Model", group="Thermal"));
        parameter Modelica.Units.SI.Temperature TCable=T_ref
          "Fixed temperature of the cable" annotation (Dialog(
            tab="Model",
            group="Thermal",
            enable=not use_T));

        parameter ProsNet.Electrical.Types.CableMode mode=ProsNet.Electrical.Types.CableMode.automatic
          "Select if choosing the cable automatically or between a list of commercial options"
          annotation (
          Evaluate=true,
          Dialog(tab="Tech. specification", group="Auto/Manual mode"),
          choicesAllMatching=true);

        replaceable parameter
          ProsNet.Electrical.Transmission.LowVoltageCables.Generic commercialCable
          constrainedby ProsNet.Electrical.Transmission.BaseClasses.BaseCable
          "Commercial cables options" annotation (
          Evaluate=true,
          Dialog(
            tab="Tech. specification",
            group="Manual mode",
            enable=mode == ProsNet.Electrical.Types.CableMode.commercial),
          choicesAllMatching=true);

        final parameter Modelica.Units.SI.Temperature T_ref=commercialCable.T_ref
          "Reference temperature of the line" annotation (Evaluate=True);
        final parameter Modelica.Units.SI.Temperature M=commercialCable.M
          "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))";
        final parameter Modelica.Units.SI.Resistance R=commercialCable.lineResistance(
            l,
            f_n,
            commercialCable) "Resistance of the cable" annotation (Evaluate=True);
        final parameter Modelica.Units.SI.Inductance L=commercialCable.lineInductance(
            l,
            f_n,
            commercialCable)
          "Inductance of the cable due to mutual and self inductance"
          annotation (Evaluate=True);
        final parameter Modelica.Units.SI.Capacitance C=
            commercialCable.lineCapacitance(
            l,
            f_n,
            commercialCable) "Capacitance of the cable" annotation (Evaluate=True);
        Buildings.HeatTransfer.Sources.PrescribedTemperature cableTemp
          "Temperature of the cable"
          annotation (Placement(transformation(extent={{-60,12},{-40,32}})));
        Modelica.Blocks.Interfaces.RealInput T if use_T "Temperature of the cable"
         annotation (
           Placement(transformation(extent={{-42,28},{-2,68}}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=270,
              origin={0,30})));
        Modelica.Blocks.Sources.RealExpression cableTemperature(y=T_in)
          "Temperature of the cable"
          annotation (Placement(transformation(extent={{-92,12},{-72,32}})));
      protected
        Modelica.Blocks.Interfaces.RealInput T_in
          "Internal variable for conditional temperature";
      equation
        assert(L>=0 and R>=0 and C>=0, "The parameters R,L,C must be positive. Check cable properties and size.");
        connect(T_in, T);

        if not use_T then
          T_in = TCable;
        end if;

        connect(cableTemperature.y, cableTemp.T) annotation (Line(
            points={{-71,22},{-62,22}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Text(
                  extent={{-150,-19},{150,-59}},
                  textColor={0,0,0},
                textString="%name")}),
          Documentation(info="<html>
<p>
This partial model contains parameters and variables needed to parametrize a
generic cable. The resistance, inductance and capacitance
are computed by the functions associated to the type of cable selected.
The type of cable is specified using a record that inherits from
<a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.BaseCable\">
Buildings.Electrical.Transmission.BaseClasses.BaseCable</a> such as (
<a href=\"modelica://Buildings.Electrical.Transmission.LowVoltageCables.Generic\">
Buildings.Electrical.Transmission.LowVoltageCables.Generic</a> or
<a href=\"modelica://Buildings.Electrical.Transmission.MediumVoltageCables.Generic\">
Buildings.Electrical.Transmission.MediumVoltageCables.Generic</a>).
The record contains functions that depending on the properties of cable compute its
resistance, inductance or capacitance.
</p>
<p>
The model has two parameters <code>use_C</code> and <code>modelMode</code> that
change the behaviour of the model. It is possible to include the effects
of a capacity or select the model to be dynamic or steady state. More information
are available in the line models that extends this partial model.
</p>

<h4>Commercial cable mode</h4>
<p>
If <code>mode = commercial</code>, the user can select the type of cable from a list
of commercial cables. The cables are divided in three different categories:
</p>
<ul>
<li>Low voltage,</li>
<li>Medium voltage, and</li>
<li>High voltage.</li>
</ul>
<p>
The details and type of cables can be found in
<a href=\"modelica://Buildings.Electrical.Transmission.LowVoltageCables\">
Buildings.Electrical.Transmission.LowVoltageCables</a> and
<a href=\"modelica://Buildings.Electrical.Transmission.MediumVoltageCables\">
Buildings.Electrical.Transmission.MediumVoltageCables</a>.
</p>

<h4>Automatic cable mode</h4>
<p>
If <code>mode = automatic</code>, the type of cable is automatically selected
depending on the value of the parameters <code>V_nominal</code> and
<code>P_nominal</code>.
</p>

<h4>Note:</h4>
<p>
More details about the functions that compute the type of cable and its
properties can be found in <a href=\"modelica://Buildings.Electrical.Transmission.Functions\">
Buildings.Electrical.Transmission.Functions</a>.
</p>
<p>
The parameter <code>commercialCable</code> is assumed to be
<a href=\"modelica://Buildings.Electrical.Transmission.LowVoltageCables.Generic\">
Buildings.Electrical.Transmission.LowVoltageCables.Generic</a>.
The parameter is replaceable so it can be redeclared using a different type, for example
<a href=\"modelica://Buildings.Electrical.Transmission.MediumVoltageCables.Generic\">
Buildings.Electrical.Transmission.MediumVoltageCables.Generic</a>.<br/>
The example models
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Lines.Examples.ACLineMedium\">
Buildings.Electrical.AC.ThreePhasesBalanced.Lines.Examples.ACLineMedium</a> and
<a href=\"modelica://Buildings.Electrical.AC.ThreePhasesBalanced.Lines.Examples.ACSimpleGridMedium\">
Buildings.Electrical.AC.ThreePhasesBalanced.Lines.Examples.ACSimpleGridMedium</a>
show how this can be done.
</p>

</html>",       revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Revised model and documentation according to change in the structure of the cable record.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
      end PartialBaseLine;

      partial model PartialLine "Partial cable line dispersion model"
        extends ProsNet.Electrical.Interfaces.PartialTwoPort;
        extends ProsNet.Electrical.Transmission.BaseClasses.PartialBaseLine;
        Real VoltageLosses(unit = "1") = abs(PhaseSystem_p.systemVoltage(terminal_p.v) -
          PhaseSystem_n.systemVoltage(terminal_n.v))/
          Buildings.Utilities.Math.Functions.smoothMax(
            PhaseSystem_p.systemVoltage(terminal_p.v),
            PhaseSystem_n.systemVoltage(terminal_n.v),
            1.0) "Percentage of voltage losses across the line";
      protected
        parameter Integer n_ = size(terminal_n.i,1) "Number of cables";
        parameter Real nominal_i_ = P_nominal / V_nominal
          "Nominal current flowing through the line";
        parameter Real nominal_v_ = V_nominal "Nominal voltage of the line";

        annotation ( Icon(coordinateSystem(
                preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Text(
                  extent={{-150,-19},{150,-59}},
                  textColor={0,0,0},
                textString="%name")}),
          Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This partial model extends the model <a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialBaseLine\">
Buildings.Electrical.Transmission.BaseClasses.PartialBaseLine</a>.
It adds two generalized electric connectors.
</p>
<h4>Note:</h4>
<p>
See <a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialBaseLine\">
Buildings.Electrical.Transmission.BaseClasses.PartialBaseLine</a> for more information.
</p>
</html>"));
      end PartialLine;

      partial model PartialNetwork "Partial model that represent an electric network"
        parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
          "Nominal voltage of the lines in the network";
        replaceable parameter ProsNet.Electrical.Transmission.Grids.PartialGrid
          grid
          "Record that describe the grid with the number of nodes, links, connections, etc."
          annotation (choicesAllMatching=true, Placement(transformation(extent=
                  {{40,60},{60,80}})));
        replaceable ProsNet.Electrical.Interfaces.BaseTerminal terminal[grid.nNodes]
          "Electric terminals for each node of the network"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        replaceable ProsNet.Electrical.Transmission.BaseClasses.PartialBaseLine
          lines[grid.nLinks](
          each mode=ProsNet.Electrical.Types.CableMode.commercial,
          l={grid.l[i, 1] for i in 1:grid.nLinks},
          each P_nominal=1000,
          each V_nominal=V_nominal)
          "Array of line models, each line connecting two nodes of the grid";

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                  {100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255}),
              Ellipse(
                extent={{-6,86},{6,74}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-86,46},{-74,34}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-36,-24},{-24,-36}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{74,46},{86,34}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{74,-54},{86,-66}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-6,-74},{6,-86}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-66,6},{-54,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{54,6},{66,-6}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-80,40},{0,80}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-60,0},{0,80}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,-80},{60,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{-32,-28},{-60,0}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{80,40},{0,80}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,-80},{0,80}},
                color={0,0,0},
                smooth=Smooth.None),
              Line(
                points={{80,-62},{80,40}},
                color={0,0,0},
                smooth=Smooth.None),
              Text(
                extent={{-140,140},{140,100}},
                textColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="%name")}), Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This partial model represents a generalized electrical network.
</p>
<p>
The model has three main components. The parameter <code>grid</code> declares the type
<a href=\"modelica://Buildings.Electrical.Transmission.Grids.PartialGrid\">
Buildings.Electrical.Transmission.Grids.PartialGrid</a>
that contains the information about the topology of the network, such as
the number of nodes,
how they are connected, and the length of each connection.
The parameter <code>terminal[...]</code> declares
an array of generalized electric connectors that are associated to each node of the grid.
The parameter <code>lines[...]</code> is an array of type
<a href=\"modelica://Buildings.Electrical.Transmission.BaseClasses.PartialBaseLine\">
Buildings.Electrical.Transmission.BaseClasses.PartialBaseLine</a> that represent the cables
in the grid.
</p>
<h4>Note:</h4>
<p>
This is a partial model that once extended can represent either DC or AC networks.
This model is based on the assumption that the topology of the network does not depend on
the type of cables that connect the nodes.
</p>
</html>"));
      end PartialNetwork;

      partial model PartialTwoPortInductance
        "Partial model of an inductive element that links two electrical connectors"
        extends Interfaces.PartialTwoPort;
        parameter Modelica.Units.SI.Inductance L "Inductance"
          annotation (Evaluate=true);
      equation
        Connections.branch(terminal_p.theta, terminal_n.theta);
        terminal_p.theta = terminal_n.theta;

        terminal_p.i = - terminal_n.i;

        annotation (Diagram(graphics={
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255})}), Icon(
              coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                        graphics={
                Text(
                  extent={{-142,-30},{144,-62}},
                  textColor={0,0,0},
                textString="L=%L"),
                Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                Line(points={{70,0},{90,0}}, color={0,0,0}),
              Rectangle(
                extent={{-70,30},{70,-30}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-42,14},{-14,-14}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-14,14},{14,-14}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{14,14},{42,-14}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-44,0},{44,-16}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
                Line(
                points={{0,0},{12,1.46953e-15}},
                color={0,0,0},
                origin={-42,0},
                rotation=180),
                Line(
                points={{-6.85214e-44,-8.39117e-60},{10,1.22461e-15}},
                color={0,0,0},
                origin={52,0},
                rotation=180)}),
          Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
Partial model of an inductance that links two generalized electrical connectors.
</p>
</html>"));
      end PartialTwoPortInductance;

      partial model PartialTwoPortRLC
        "Partial model of an RLC element that links two electrical connectors"
        extends ProsNet.Electrical.Interfaces.PartialTwoPort;
        extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort(T = T_ref);
        parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref"
          annotation (Evaluate=true);
        parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature";
        parameter Modelica.Units.SI.Temperature M=507.65
          "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))";
        parameter Modelica.Units.SI.Capacitance C "Capacity";
        parameter Modelica.Units.SI.Inductance L "Inductance";
        parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
          "Nominal voltage (V_nominal >= 0)"
          annotation (Dialog(group="Nominal conditions"));
        Modelica.Units.SI.Resistance R_actual
          "Actual resistance = R*(M + T_heatPort)/(M + T_ref) ";
      equation
        Connections.branch(terminal_p.theta, terminal_n.theta);
        terminal_p.theta = terminal_n.theta;

        assert(R_actual>=0,
         "The value of R_actual must be positive, check reference and actual temperatures");

        R_actual =R*(M + Modelica.Units.Conversions.to_degC(T_heatPort))/(M +
          Modelica.Units.Conversions.to_degC(T_ref));

        annotation (Diagram(graphics={
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255})}), Icon(
              coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                        graphics={
                Text(
                  extent={{-148,-28},{138,-60}},
                  textColor={0,0,0},
                textString="R=%R, L=%L"),
                Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                Line(points={{70,0},{90,0}}, color={0,0,0}),
              Rectangle(
                extent={{-70,32},{70,-28}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
                Line(
                points={{-6.85214e-44,-8.39117e-60},{96,1.22003e-14}},
                color={0,0,0},
                origin={64,16},
                rotation=180),
                Line(
                visible = C > 0,
                points={{-6.85214e-44,-8.39117e-60},{-4.17982e-15,16}},
                color={0,0,0},
                origin={22,16},
                rotation=180),
                Line(
                visible = C > 0,
                points={{-6.85214e-44,-8.39117e-60},{16,1.95937e-15}},
                color={0,0,0},
                origin={30,0},
                rotation=180),
                Line(
                visible = C > 0,
                points={{-6.85214e-44,-8.39117e-60},{16,1.95937e-15}},
                color={0,0,0},
                origin={30,-4},
                rotation=180),
                Line(
                visible = C > 0,
                points={{-6.85214e-44,-8.39117e-60},{-2.40346e-15,16}},
                color={0,0,0},
                origin={22,-4},
                rotation=180),
              Line(
                points={{-66,16},{-60,16},{-58,20},{-54,12},{-50,20},{-46,12},{-42,20},
                    {-38,12},{-36,16},{-32,16}},
                color={0,0,0},
                smooth=Smooth.None),
              Ellipse(
                extent={{-24,22},{-12,10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-12,22},{0,10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{0,22},{12,10}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-24,16},{12,4}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
                Text(
                  extent={{-142,-56},{144,-88}},
                  textColor={0,0,0},
                textString="C=%C")}),
          Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
Partial model of a resistance that links two generalized electrical connectors.
</p>
<p>
The model computes a resistance <i>R(T)</i> that varies depending on the temperature <i>T</i> as
</p>
<p align=\"center\" style=\"font-style:italic;\">
R(T) = R<sub>ref</sub> (M + T)/(M + T<sub>ref</sub>),
</p>
<p>
where the resistance <i>R<sub>ref</sub></i> is the reference value of the resistance,
<i>M</i> is the temperature coefficient of the cable material, and
<i>T<sub>ref</sub></i> is the reference temperature.
The temperature <i>T</i> is the temperature of the heat port if <code>useHeatPort = true</code>.
</p>
<p>
The impedance <i>L</i> and the capacity <i>C</i> do not vary with respect to the temperature
and are specified by the user.
</p>
</html>"));
      end PartialTwoPortRLC;

      partial model PartialTwoPortResistance
        "Partial model of a resistive element that links two electrical connectors"
        extends Interfaces.PartialTwoPort;
        extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort(T = T_ref);
        parameter Modelica.Units.SI.Resistance R "Resistance at temperature T_ref";
        parameter Modelica.Units.SI.Temperature T_ref=298.15 "Reference temperature";
        parameter Modelica.Units.SI.Temperature M=507.65
          "Temperature constant (R_actual = R*(M + T_heatPort)/(M + T_ref))";
        Modelica.Units.SI.Resistance R_actual
          "Actual resistance = R*(M + T_heatPort)/(M + T_ref) ";
      equation
        Connections.branch(terminal_p.theta, terminal_n.theta);
        terminal_p.theta = terminal_n.theta;

        assert(R_actual>=0,
         "The value of R_actual must be positive, check reference and actual temperatures.");

        R_actual =R*(M + Modelica.Units.Conversions.to_degC(T_heatPort))/(M +
          Modelica.Units.Conversions.to_degC(T_ref));

        terminal_p.i = - terminal_n.i;

        annotation (Diagram(graphics={
                Rectangle(extent={{-70,30},{70,-30}}, lineColor={0,0,255}),
                Line(points={{-90,0},{-70,0}}, color={0,0,255}),
                Line(points={{70,0},{90,0}},   color={0,0,255})}), Icon(
              coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                                                                        graphics={
                Text(
                  extent={{-142,-30},{144,-62}},
                  textColor={0,0,0},
                textString="R=%R"),
                Line(points={{-90,0},{-70,0}}, color={0,0,0}),
                Line(points={{70,0},{90,0}}, color={0,0,0}),
              Rectangle(
                extent={{-70,30},{70,-30}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
Partial model of a resistance that links two generalized electrical connectors.
</p>
<p>
The model computes a resistance <i>R(T)</i> that varies depending on the temperature <i>T</i> as
</p>
<p align=\"center\" style=\"font-style:italic;\">
R(T) = R<sub>ref</sub> (M + T)/(M + T<sub>ref</sub>),
</p>
<p>
where the resistance <i>R<sub>ref</sub></i> is the reference value of the resistance,
<i>M</i> is the temperature coefficient of the cable material,
and <i>T<sub>ref</sub></i> is the reference temperature.
The temperature <i>T</i> is the temperature of the heat port
if <code>useHeatPort = true</code>.
</p>
</html>"));
      end PartialTwoPortResistance;

      record BaseCable "Record that contains the properties of a generic cable"
        parameter ProsNet.Electrical.Transmission.Types.Material material=ProsNet.Electrical.Transmission.Types.Material.Al
          "Material of the cable";
        parameter Modelica.Units.SI.Current Amp(start=0.0) = 0.0
          "Ampacitance of the cable";
        parameter Modelica.Units.SI.Temperature T_ref=298.15
          "Reference cable temperature";
        parameter Modelica.Units.SI.Temperature M=228.1 + 273.15
          "Temperature constant of the material";

        replaceable partial function lineResistance
          "Function that computes the resistance of a cable"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.Length l "Length of the cable";
          input Modelica.Units.SI.Frequency f=50
            "Frequency considered in the definition of cables properties";
          output Modelica.Units.SI.Resistance R "Resistance of the cable";
        protected
          parameter Modelica.Units.SI.AngularVelocity omega=2*Modelica.Constants.pi*f;
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>"));
        end lineResistance;

        replaceable partial function lineInductance
          "Function that computes the inductance of a cable"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.Length l "Length of the cable";
          input Modelica.Units.SI.Frequency f=50
            "Frequency considered in the definition of cables properties";
          output Modelica.Units.SI.Inductance L "Inductance of the cable";
        protected
          parameter Modelica.Units.SI.AngularVelocity omega=2*Modelica.Constants.pi*f;
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>"));
        end lineInductance;

        replaceable partial function lineCapacitance
          "Function that computes the capacitance of a cable"
          extends Modelica.Icons.Function;
          input Modelica.Units.SI.Length l "Length of the cable";
          input Modelica.Units.SI.Frequency f=50
            "Frequency considered in the definition of cables properties";
          output Modelica.Units.SI.Capacitance C "Capacitance of the cable";
        protected
          parameter Modelica.Units.SI.AngularVelocity omega=2*Modelica.Constants.pi*f;
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Added function and documentation
</li>
</ul>
</html>"));
        end lineCapacitance;

        annotation (Documentation(revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Revised structure of the record, now the temperature constant <code>M</code>
is directly specified in the record.
</li>
<li>
September 23, 2014, by Marco Bonvini:<br/>
Revised structure of the record, not it contains just the minimum amount of
information needed to describe a cable.<br/>
It also contains partial function that compute the properties of the cable.
</li>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",       info="<html>
<p>
This record contains the basic properties to describe a commercial
cable.
</p>
<p>
The low voltage and medium voltage cables extends this base records and add
other specific parameters like the geometrical properties.
</p>
<p>
The record contains four partial replaceable functions used to compute
the properties of the cable such its resistance, inductance or capacitance.
</p>
</html>"));
      end BaseCable;
    annotation (Documentation(revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>",     info="<html>
<p>
This package contains partial models that describe electric
lines and cables.
</p>
</html>"));
    end BaseClasses;
  annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
            {100,100}}), graphics={
        Ellipse(
          extent={{40,8},{16,-28}},
          lineColor={0,0,0},
          fillColor={255,255,255},
          fillPattern=FillPattern.Solid),
        Line(
          points={{28,8},{-54,8},{-64,8},{-72,-10},{-64,-28},{-52,-28},{28,-28}},
          color={0,0,0},
          smooth=Smooth.Bezier),
        Line(
          points={{-70,-10},{-88,-10}},
          color={0,0,0},
          smooth=Smooth.None),
        Line(
          points={{54,-10},{28,-10}},
          color={0,0,0},
          smooth=Smooth.None)}), Documentation(info="<html>
<p>
This package contains cables that can be used
to represent a line in a electric grid. The package contains
several functions and records to parametrize cables either using
default values or values from commercial cables.
</p>
<p>
The package
<a href=\"modelica://Buildings.Electrical.Transmission.Grids\">
Buildings.Electrical.Transmission.Grids</a>
contains models of
electrical networks.
</p>
<h4>Commercial cables</h4>
<p>
The package contains several low voltage and medium voltage cable with
pre-defined physical and geometrical properties like characteristic resistances and
diameters. There are different conventions to measure the cables.
</p>

<h5>Cross-sectional area</h5>
<p>
A measure of cross-sectional area in square mm. E.g. 50 mm<sup>2</sup>
wire has a nominal circula area of 50 mm<sup>2</sup> and a diameter of
7.98 mm.
</p>

<h5>AWG (American Wire Gauge)</h5>
<p>
A measure of wire thickness (which also dictates cross-sectional area, and
for a given material, ampacity). E.g. 24 AWG wire has a nominal diameter of
0.0201 in or 0.511 mm.
</p>

<h5>kcmil (thousand of Circular Mils)</h5>
<p>
kcmil is an abbreviation for thousands of circular mils, an old measurement of
wire gauge. 1 kcmil = 0.5067 square millimeters. A mil is 1/1000 inch.
A wire 200 mils in diameter is 40 kcmil. kcmil is generally used for very
large-diameter wire. Most wires use AWG.
</p>

</html>",   revisions="<html>
<ul>
<li>
June 3, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
  end Transmission;

  package Utilities "Package with models and functions that are used by other models"
    extends Modelica.Icons.Package;

    model VoltageControl "Voltage controller"
      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
        annotation (choicesAllMatching=true);
      parameter Modelica.Units.SI.Voltage V_nominal
        "Nominal voltage of the node to be controlled";
      parameter Real vThresh(min=0.0, max=1.0) = 0.1
        "Threshold that activates voltage ctrl (ratio of nominal voltage)";
      parameter Modelica.Units.SI.Time tDelay=300
        "Time to wait before plugging the load back";
      parameter Modelica.Units.SI.Time T=0.01
        "Time constant representing the switching time";
      parameter Real y_start = 1.0 "Initial value of the control output signal";
      final parameter Modelica.Units.SI.Voltage Vmin=V_nominal*(1 - vThresh)
        "Low threshold";
      final parameter Modelica.Units.SI.Voltage Vmax=V_nominal*(1 + vThresh)
        "High threshold";
      Modelica.Blocks.Interfaces.RealOutput y(start = y_start, stateSelect = StateSelect.prefer)
        "Control signal"
        annotation (Placement(transformation(extent={{96,-10},{116,10}})));
      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          replaceable package PhaseSystem = PhaseSystem) "Generalized terminal"
        annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
      ProsNet.Electrical.Utilities.Controllers.StateMachineVoltCtrl ctrl(
        V_nominal=V_nominal,
        vThresh=vThresh,
        tDelay=tDelay)
        "Model that implements the state machines voltage controller";
    initial equation
      y = y_start;
    equation

      // Output of the control block
      y + T*der(y) = ctrl.y;

      // Voltage measurements
      ctrl.V = terminal.PhaseSystem.systemVoltage(terminal.v);

      // The controller does not consume current
      terminal.i = zeros(PhaseSystem.n);
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              lineThickness=0.5,
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-100,-40},{100,-80}},
              textColor={0,0,0},
              lineThickness=0.5,
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              textString="Voltage
CTRL"),                                       Text(
              extent={{-100,72},{100,40}},
              textColor={0,0,0},
              lineThickness=0.5,
              fillColor={0,0,255},
              fillPattern=FillPattern.Solid,
              textString="%name")}), Documentation(revisions="<html>
<ul>
<li>
March 10, 2014, by Marco Bonvini:<br/>
Added time constant <code>T</code> and first order filer to avoid
differentiation of the outputs of the finite state machine.
</li>
<li>
Oct 14, 2014, by Marco Bonvini:<br/>
Revised model and documentation.
</li>
<li>
Aug 28, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
<p>
Model representing a voltage controller that unplugs a load when
its voltage is outside of the accepted thresholds.
</p>
<p>
The model contains a finite state machine controller that detects voltage
deviations. If the voltage input <code>V</code> exceeds the
nominal value <code>V_nominal</code> by more than <i>1+V<sub>tr</sub></i>
then the control signal <code>y</code> becomes zero for
a period <code>t = tDelay</code>. If after this period the voltage is still
higher than the thresholds the output remains equal to zero.
The model has a parameter <code>T</code> that represents the time constant
associated to the electrical switch. This time constant is used to parametrize
a first order filter that represents such a dynamic effect. The presence of the first order
filter avoids that the output of the finite state machine controller
are differentiated (causing runtime errors).
</p>
</html>"));
    end VoltageControl;

    package Controllers "Package that contains state machines and control models used by the utilities"
    extends Modelica.Icons.BasesPackage;

      model StateMachineVoltCtrl "This model represents a simple voltage controller that unplug a load when
  there is a voltage fluctuation higher that a given threshold."
        Modelica.Blocks.Interfaces.RealInput V "Voltage of the node to be controlled";
        parameter Modelica.Units.SI.Voltage V_nominal
          "Nominal voltage of the node to be controlled";
        parameter Real vThresh(min=0.0, max=1.0) = 0.1
          "Threshold that activates voltage ctrl (ratio of nominal voltage)";
        parameter Modelica.Units.SI.Time tDelay=300
          "Time to wait before plugging the load back";
        output Real y
          "Output signal that represents whether the load should be connected to the grid or not";
      protected
        discrete Boolean connected
          "Boolean variable that indicates when the load is connected";
        discrete Real tSwitch "Time instant when the last event occurred";
      initial algorithm
        // Initialize with load connected and last event at t = 0
        connected := true;
        tSwitch := 0;
      equation

        // Output for every state, connected or not
        if connected then
          y = 1.0;
        else
          y = 0.0;
        end if;

      algorithm

        // Detect an overshoot in the voltage
        when
            (connected and (V > V_nominal*(1+vThresh))) then
          tSwitch := time;
          connected := false;
        end when;

        // Transition between not connected and connected again after the delay time has been elapsed
        when
            (not connected and time >= tSwitch + tDelay) then
          connected := true;
        end when;

        annotation (Documentation(revisions="<html>
<ul>
<li>
Aug 28, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",       info="<html>
<p>
Function that implements a state machine that detects voltage
deviations. If the voltage input <code>V</code> exceeds the
nominal value <code>V_nominal</code> by more than <i>1+V<sub>tr</sub></i>
then the control signal <code>y</code> becones zero for
a period equal to <code>tDelay</code>.
</p>
<p>
A signal <code>y = 0</code> can be used to turn off a load.
</p>
</html>"));
      end StateMachineVoltCtrl;
    annotation (Documentation(revisions="<html>
<ul>
<li>
Aug 28, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
<p>
This package contains state machines and controller models used by the utilities.
</p>
</html>"));
    end Controllers;

    package Examples "This package contais tests for check the correctness of the models"
    extends Modelica.Icons.ExamplesPackage;

      model TestVoltageCTRL
        "This test check the correctness of the voltage controller model"
        extends Modelica.Icons.Example;
        VoltageControl voltageControl(
        redeclare ProsNet.Electrical.DC.Interfaces.Terminal_p   terminal,
          redeclare package PhaseSystem =
              ProsNet.Electrical.PhaseSystems.TwoConductor,
          V_nominal=120,
          tDelay=2) "Voltage controller"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        DC.Sources.VoltageSource sou "Varriable voltage source"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        Modelica.Electrical.Analog.Basic.Ground ground
          annotation (Placement(transformation(extent={{-70,-36},{-50,-16}})));
        Modelica.Blocks.Sources.Sine cosine(
          amplitude=20,
          f=0.1,
          phase=0,
          offset=120) "Variable voltage signal"
          annotation (Placement(transformation(extent={{-94,-4},{-74,16}})));
        Modelica.Blocks.Sources.Constant Vtr_high(k=120*(1 + 0.1))
          "Voltage threshold high"
          annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
      equation
        connect(sou.terminal, voltageControl.terminal) annotation (Line(
            points={{-40,0},{-10,0}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(ground.p, sou.n) annotation (Line(
            points={{-60,-16},{-60,0}},
            color={0,0,255},
            smooth=Smooth.None));
        connect(cosine.y, sou.V_in) annotation (Line(
            points={{-73,6},{-60,6}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (Documentation(revisions="<html>
<ul>
<li>
March 10, 2015, by Marco Bonvini:<br/>
Revised image of the example after modification to the voltage controller
(added first order dynamics in the switch).
</li>
<li>
Oct 14, 2014, by Marco Bonvini:<br/>
Added model and documentation.
</li>
</ul>
</html>",       info="<html>
<p>
This example shows the use of the voltage controller.
</p>
<p>
The voltage controller is connected to a variable voltage source
that oscillates between <i>140</i> and <i>100</i> V. The nominal voltage is
<i>V<sub>nom</sub> = 120 </i> V. The controller has the following settings:
</p>
<ul>
<li>Nominal voltage <i>V<sub>nom</sub> = 120 </i> V,</li>
<li>Threshold <i>V<sub>tr</sub> = 0.1 (10%)</i>,</li>
<li>tdelay <i>T<sub>delay</sub> = 2 </i> s.</li>
</ul>
<p>
Therefore, when the voltage controller measures a voltage that
is 10% higher that 120 V (that is 132 V), it sets its output signal <code>y</code> to zero.
The output signal stays at zero for <i>T<sub>delay</sub></i>,
after which it expires.
Then, the controllers check again if the voltage is within the
accepted thresholds.
</p>
<p>
The image below shows how the signal becomes equal to zero when the measured
voltage exceeds the threshold.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Utilities/Examples/VoltCTRL.png\"/>
</p>
<p>
The figure shows that the signal <code>y</code> becomes zero around <i>t = 1</i> s. After
<i>T<sub>delay</sub></i> the voltage is still higher that 123 V and thus the controller waits until
<i>t = 5</i> s to change the signal to one.
</p>
</html>"),          __Dymola_Commands(file=
                "modelica://Buildings/Resources/Scripts/Dymola/Electrical/Utilities/Examples/TestVoltageCTRL.mos"
              "Simulate and plot"),
          experiment(
            StopTime=10,
            Tolerance=1e-6));
      end TestVoltageCTRL;
    annotation (Documentation(revisions="<html>
<ul>
<li>
Aug 28, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical.Utilities\">
Buildings.Electrical.Utilities</a>.
</p>
</html>"));
    end Examples;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models and functions.
</p>
</html>",   revisions="<html>
<ul>
<li>
Aug 28, 2014, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;

  package Types "This package contains new types used within the Electrical package"
    extends Modelica.Icons.TypesPackage;

    type CableMode = enumeration(
        automatic "Select automatically the size of the cable",
        commercial "Select the cable from a list of commercial options")
      "Enumeration that defines how a cable can be parameterized" annotation (
        Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type is used to indicate in which mode the cable model works.
In automatic mode the cable is automatically sized using basic information like
nominal voltage and power, in commercial mode the user can select among a list of
commercially available cables.
</html>"));
    type CharacteristicReactance =  Real (final quantity="Reactance per meter",  final unit="Ohm/m")
      "Reactance per unit length" annotation (Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type defines the reactance per unit length. It is typically used
to describe physical properties of line cables.
</html>"));
    type CharacteristicResistance = Real (final quantity="Resistance per meter", final unit="Ohm/m")
      "Resistance per unit length" annotation (Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type defines the resistance per unit length and it typically used
to describe physical properties of the line cables.
</html>"));
    type InitMode = enumeration(
        zero_current "Assume i=0 during homotopy initialization",
        linearized "Uses linear model during homotopy initialization")
      "Enumeration that defines the type of initialization assumption can be used for a load model"
      annotation (Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type is used to indicate how a model
should be initialized.
</html>"));
    type Load = enumeration(
        FixedZ_steady_state "Fixed Z, steady-state",
        FixedZ_dynamic "Fixed Z, dynamic",
        VariableZ_P_input "Variable Z, P input",
        VariableZ_y_input "Variable Z, y input")
      "Enumeration that defines the modeling assumption of the load." annotation (
        Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type indicates in which mode the load model operates.
</html>"));
    type LoadConnection = enumeration(
        wye_to_wyeg "Wye to wye grounded",
        wye_to_delta "Wye to delta")
      "Enumeration that defines the type of connection can be used for three-phase unbalanced systems"
      annotation (Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type is used to describe different types of connections that can be used in
unbalanced three phase systems.
</html>"));
    type PerUnit = Real (final quantity="Per unit", final unit="1", min=0)
      "Used to represent electric quantities with respect to reference value"
      annotation (Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type is used to declare whether an electric quantity such as voltage
is expressed in SI units or in per units (i.e., the value divided by its nominal
value).
</html>"));
    type VoltageLevel = enumeration(
        Low "Low voltage",
        Medium "Medium voltage",
        High "High voltage") "Enumeration that defines the type of voltage level"
      annotation (Documentation(revisions="<html>
<ul>
<li>
March 19, 2015, by Marco Bonvini:<br/>
Added documentation.
</li>
</ul>
</html>",     info="<html>
This type is used to define which type of voltage level is used.
This is typically used for computing or selecting the line cables.
</html>"));
  annotation (preferredView="info",
  Documentation(
  info="<html>
This package contains type definitions.
</html>",
  revisions="<html>
<ul>
<li>
June 17, 2014, by Marco Bonvini:<br/>
Added new type <code>InitMode</code> to represent different types
of initialization assumptions for the load model.
</li>
<li>
June 5, 2014, by Marco Bonvini:<br/>
Added new type <code>LoadConnection</code> to represent different types
of unbalanced connection.
</li>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
  end Types;

  package Examples "Package with example models"
  extends Modelica.Icons.ExamplesPackage;

    model RenewableSources
      "Example model that shows the impact of renewable sources on the electrical grid"
      extends Modelica.Icons.Example;
      parameter Modelica.Units.SI.Frequency f=60 "Nominal grid frequency";
      parameter Modelica.Units.SI.Voltage V_nominal=480 "Nominal grid voltage";
      parameter Modelica.Units.SI.Power PLoa_nominal=3500 "Nominal power of a load";
      parameter Modelica.Units.SI.Power PWin=PLoa_nominal*4
        "Nominal power of the wind turbine";
      parameter Modelica.Units.SI.Power PSun=PLoa_nominal*1.0
        "Nominal power of the PV";
      parameter Modelica.Units.SI.DensityOfHeatFlowRate W_m2_nominal=1000
        "Nominal solar power per unit area";
      parameter Real eff_PV = 0.12*0.85*0.9
        "Nominal solar power conversion efficiency (this should consider converion efficiency, area covered, AC/DC losses)";
      parameter Modelica.Units.SI.Area A_PV=PSun/eff_PV/W_m2_nominal
        "Nominal area of a P installation";

      AC.ThreePhasesBalanced.Sources.Grid gri(
        f=f,
        V=V_nominal,
        phiSou=0) "Grid model that provides power to the system"
        annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa1(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.8,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa2(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.9,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{0,30},{20,50}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa3(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.8,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{40,30},{60,50}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa4(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.88,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{80,30},{100,50}})));
      AC.ThreePhasesBalanced.Lines.Line line1(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=1500,
        V_nominal=V_nominal,
        P_nominal=7*(PLoa_nominal + PSun) + PWin) "Electrical line"
                  annotation (Placement(transformation(extent={{-80,10},{-60,30}})));
      AC.ThreePhasesBalanced.Lines.Line line2(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=3*(PLoa_nominal + PSun)) "Electrical line"
                 annotation (Placement(transformation(extent={{-20,10},{0,30}})));
      AC.ThreePhasesBalanced.Lines.Line line3(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=2*(PLoa_nominal + PSun)) "Electrical line"
                 annotation (Placement(transformation(extent={{20,10},{40,30}})));
      AC.ThreePhasesBalanced.Lines.Line line4(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=(PLoa_nominal + PSun)) "Electrical line"
                 annotation (Placement(transformation(extent={{60,10},{80,30}})));
      AC.ThreePhasesBalanced.Lines.Line line5(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=3*(PLoa_nominal + PSun) + PWin) "Electrical line"
        annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa5(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.95,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{-20,-50},{0,-30}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa6(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.8,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{20,-50},{40,-30}})));
      AC.ThreePhasesBalanced.Loads.Inductive loa7(mode=ProsNet.Electrical.Types.Load.VariableZ_y_input,
        V_nominal=V_nominal,
        linearized=false,
        use_pf_in=false,
        pf=0.75,
        P_nominal=-PLoa_nominal) "Electrical load"
        annotation (Placement(transformation(extent={{60,-50},{80,-30}})));
      AC.ThreePhasesBalanced.Lines.Line line6(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=2*(PLoa_nominal + PSun) + PWin) "Electrical line"
                 annotation (Placement(transformation(extent={{0,-20},{20,0}})));
      AC.ThreePhasesBalanced.Lines.Line line7(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=(PLoa_nominal + PSun) + PWin) "Electrical line"
                 annotation (Placement(transformation(extent={{40,-20},{60,0}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv1(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.85,
        azi=Buildings.Types.Azimuth.S,
        til=0.5235987755983) "PV"
        annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv2(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.8,
        azi=Buildings.Types.Azimuth.E,
        til=0.5235987755983) "PV"
        annotation (Placement(transformation(extent={{0,60},{20,80}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv3(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.8,
        azi=Buildings.Types.Azimuth.W,
        til=0.34906585039887) "PV"
        annotation (Placement(transformation(extent={{40,60},{60,80}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv4(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.9,
        azi=Buildings.Types.Azimuth.S,
        til=0.5235987755983) "PV"
        annotation (Placement(transformation(extent={{80,60},{100,80}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv5(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.95,
        azi=Buildings.Types.Azimuth.W,
        til=0.61086523819802) "PV"
        annotation (Placement(transformation(extent={{-20,-80},{0,-60}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv6(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.9,
        azi=Buildings.Types.Azimuth.E,
        til=0.43633231299858) "PV"
        annotation (Placement(transformation(extent={{20,-80},{40,-60}})));
      AC.ThreePhasesBalanced.Sources.PVSimpleOriented pv7(
        eta_DCAC=0.89,
        A=A_PV,
        fAct=0.9,
        eta=0.12,
        linearized=false,
        V_nominal=V_nominal,
        pf=0.97,
        azi=Buildings.Types.Azimuth.S,
        til=0.5235987755983) "PV"
        annotation (Placement(transformation(extent={{60,-80},{80,-60}})));
      AC.ThreePhasesBalanced.Sources.WindTurbine winTur(
        V_nominal=V_nominal,
        h=15,
        hRef=10,
        pf=0.94,
        eta_DCAC=0.92,
        nWin=0.4,
        tableOnFile=false,
        scale=PWin) "Wind turbine model"
        annotation (Placement(transformation(extent={{120,-20},{140,0}})));
      AC.ThreePhasesBalanced.Lines.Line line8(mode=ProsNet.Electrical.Types.CableMode.automatic,
          l=300,
        V_nominal=V_nominal,
        P_nominal=PWin)
                 annotation (Placement(transformation(extent={{80,-20},{100,0}})));
      Buildings.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          computeWetBulbTemperature=false, filNam=
            Modelica.Utilities.Files.loadResource(
            "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
        "Weather data model"
        annotation (Placement(transformation(extent={{-100,74},{-80,94}})));
      Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather data bus"
        annotation (Placement(transformation(extent={{120,28},{140,48}})));
      Modelica.Blocks.Sources.CombiTimeTable pow1(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.1; 2,0.1;
            4,0.1; 6,0.1; 8,0.8; 10,0.7; 12,0.3; 14,0.3;
            16,0.3; 18,0.8; 20,0.7; 22,0.3; 24,0.1],
        timeScale=3600)
        "Power consumption profile for load 1"
        annotation (Placement(transformation(extent={{-2,34},{-14,46}})));
      Modelica.Blocks.Sources.CombiTimeTable pow2(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.1; 2,0.1;
            4,0.1; 6,0.1; 8,0.8; 10,0.7; 12,0.3; 14,0.3;
            16,0.3; 18,0.8; 20,0.7; 22,0.3; 24,0.1],
        timeScale=3600)
        "Power consumption profile for load 2"
        annotation (Placement(transformation(extent={{36,34},{24,46}})));
      Modelica.Blocks.Sources.CombiTimeTable pow3(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.1; 2,0.1;
            4,0.1; 6,0.1; 8,0.8; 10,0.7; 12,0.3; 14,0.3;
            16,0.3; 18,0.8; 20,0.7; 22,0.3; 24,0.1],
        timeScale=3600)
        "Power consumption profile for load 3"
        annotation (Placement(transformation(extent={{76,34},{64,46}})));
      Modelica.Blocks.Sources.CombiTimeTable pow4(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.2; 2,0.2;
            4,0.2; 6,0.2; 8,0.8; 10,0.8; 12,0.6; 14,0.3;
            16,0.3; 18,0.8; 20,0.8; 22,0.3; 24,0.3],
        timeScale=3600)
        "Power consumption profile for load 4"
        annotation (Placement(transformation(extent={{116,34},{104,46}})));
      Modelica.Blocks.Sources.CombiTimeTable pow5(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.1; 2,0.1;
            4,0.1; 6,0.1; 8,0.5; 10,0.2; 12,0.3; 14,0.3;
            16,0.3; 18,0.9; 20,0.4; 22,0.2; 24,0.1],
        timeScale=3600)
        "Power consumption profile for load 5"
        annotation (Placement(transformation(extent={{16,-46},{4,-34}})));
      Modelica.Blocks.Sources.CombiTimeTable pow6(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.1; 2,0.1;
            4,0.1; 6,0.1; 8,0.8; 10,0.7; 12,0.3; 14,0.3;
            16,0.3; 18,0.8; 20,0.7; 22,0.3; 24,0.1],
        timeScale=3600)
        "Power consumption profile for load 6"
        annotation (Placement(transformation(extent={{56,-46},{44,-34}})));
      Modelica.Blocks.Sources.CombiTimeTable pow7(extrapolation=
            Modelica.Blocks.Types.Extrapolation.Periodic, table=[0,0.2; 2,0.1;
            4,0.1; 6,0.1; 8,0.4; 10,0.7; 12,0.3; 14,0.3;
            16,0.3; 18,0.2; 20,0.7; 22,0.3; 24,0.2],
        timeScale=3600)
        "Power consumption profile for load 7"
        annotation (Placement(transformation(extent={{96,-46},{84,-34}})));
      AC.ThreePhasesBalanced.Sensors.Probe sen1(V_nominal=V_nominal, perUnit=true)
        "Voltage probe"
        annotation (Placement(transformation(extent={{-70,0},{-50,-20}})));
      AC.ThreePhasesBalanced.Sensors.Probe sen2(V_nominal=V_nominal, perUnit=true)
        "Voltage probe" annotation (Placement(transformation(extent={{-10,10},{10,-10}},
              origin={90,8})));
      AC.ThreePhasesBalanced.Sensors.Probe sen3(V_nominal=V_nominal, perUnit=true)
        "Voltage probe" annotation (Placement(transformation(extent={{-10,10},{10,-10}},
              origin={110,-40})));
      Modelica.Blocks.Continuous.Integrator EWin
        "Energy produced by the wind turbine"
        annotation (Placement(transformation(extent={{200,-14},{220,6}})));
      Modelica.Blocks.Math.MultiSum PSol(nu=7, y(unit="W"))
        "Total produced solar power"
        annotation (Placement(transformation(extent={{174,64},{186,76}})));
      Modelica.Blocks.Continuous.Integrator ESol
        "Energy produced by the solar panels"
        annotation (Placement(transformation(extent={{200,60},{220,80}})));
      Modelica.Blocks.Sources.RealExpression PLoa(
        y=PLoa_nominal*(pow1.y[1] + pow2.y[1] + pow3.y[1] + pow4.y[1] + pow5.y[1] + pow6.y[1] + pow7.y[1]))
        "Total power consumed by the loads"
        annotation (Placement(transformation(extent={{170,-70},{190,-50}})));
      Modelica.Blocks.Continuous.Integrator ELoa(y_start=1E-10)
        "Energy consumed by the loads"
        annotation (Placement(transformation(extent={{200,-70},{220,-50}})));
      Modelica.Blocks.Math.Add EPro "Total produced power by renewables"
        annotation (Placement(transformation(extent={{240,20},{260,40}})));
      Modelica.Blocks.Math.Division ERat "Ratio of produced over consumed energy"
        annotation (Placement(transformation(extent={{280,-10},{300,10}})));
    equation
      connect(gri.terminal, line1.terminal_n) annotation (Line(
          points={{-90,40},{-90,20},{-80,20}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line1.terminal_p, loa1.terminal) annotation (Line(
          points={{-60,20},{-40,20},{-40,40}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line1.terminal_p, line2.terminal_n) annotation (Line(
          points={{-60,20},{-20,20}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line2.terminal_p, loa2.terminal) annotation (Line(
          points={{0,20},{0,40}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line2.terminal_p, line3.terminal_n) annotation (Line(
          points={{0,20},{20,20}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line3.terminal_p, loa3.terminal) annotation (Line(
          points={{40,20},{40,40}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line3.terminal_p, line4.terminal_n) annotation (Line(
          points={{40,20},{60,20}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line4.terminal_p, loa4.terminal) annotation (Line(
          points={{80,20},{80,40}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line1.terminal_p, line5.terminal_n) annotation (Line(
          points={{-60,20},{-40,20},{-40,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(loa5.terminal, line5.terminal_p) annotation (Line(
          points={{-20,-40},{-20,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line5.terminal_p, line6.terminal_n) annotation (Line(
          points={{-20,-10},{0,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line6.terminal_p, line7.terminal_n) annotation (Line(
          points={{20,-10},{40,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(loa6.terminal, line6.terminal_p) annotation (Line(
          points={{20,-40},{20,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(loa7.terminal, line7.terminal_p) annotation (Line(
          points={{60,-40},{60,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line1.terminal_p, pv1.terminal) annotation (Line(
          points={{-60,20},{-40,20},{-40,70}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line2.terminal_p, pv2.terminal) annotation (Line(
          points={{0,20},{0,70}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line3.terminal_p, pv3.terminal) annotation (Line(
          points={{40,20},{40,70}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line4.terminal_p, pv4.terminal) annotation (Line(
          points={{80,20},{80,70}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(pv5.terminal, line5.terminal_p) annotation (Line(
          points={{-20,-70},{-20,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(pv6.terminal, loa6.terminal) annotation (Line(
          points={{20,-70},{20,-40}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(pv7.terminal, loa7.terminal) annotation (Line(
          points={{60,-70},{60,-40}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line7.terminal_p, line8.terminal_n) annotation (Line(
          points={{60,-10},{80,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(line8.terminal_p, winTur.terminal) annotation (Line(
          points={{100,-10},{120,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(weaDat.weaBus, pv1.weaBus) annotation (Line(
          points={{-80,84},{-30,84},{-30,79}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaDat.weaBus, pv2.weaBus) annotation (Line(
          points={{-80,84},{10,84},{10,79}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaDat.weaBus, pv3.weaBus) annotation (Line(
          points={{-80,84},{50,84},{50,79}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaDat.weaBus, pv4.weaBus) annotation (Line(
          points={{-80,84},{90,84},{90,79}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaDat.weaBus, weaBus) annotation (Line(
          points={{-80,84},{130,84},{130,38}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(weaBus.winSpe, winTur.vWin) annotation (Line(
          points={{130,38},{130,2}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaDat.weaBus, pv5.weaBus) annotation (Line(
          points={{-80,84},{148,84},{148,-54},{-10,-54},{-10,-61}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaDat.weaBus, pv6.weaBus) annotation (Line(
          points={{-80,84},{148,84},{148,-54},{30,-54},{30,-61}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(weaDat.weaBus, pv7.weaBus) annotation (Line(
          points={{-80,84},{148,84},{148,-54},{70,-54},{70,-61}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None));
      connect(loa2.y, pow2.y[1]) annotation (Line(
          points={{20,40},{23.4,40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(pow1.y[1], loa1.y) annotation (Line(
          points={{-14.6,40},{-20,40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(loa3.y, pow3.y[1]) annotation (Line(
          points={{60,40},{63.4,40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(loa4.y, pow4.y[1]) annotation (Line(
          points={{100,40},{103.4,40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(loa5.y, pow5.y[1]) annotation (Line(
          points={{0,-40},{3.4,-40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(loa6.y, pow6.y[1]) annotation (Line(
          points={{40,-40},{43.4,-40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(loa7.y, pow7.y[1]) annotation (Line(
          points={{80,-40},{83.4,-40}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(sen1.term, line1.terminal_p) annotation (Line(
          points={{-60,-1},{-60,20}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(sen2.term, line4.terminal_p) annotation (Line(
          points={{90,17},{90,20},{80,20}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(sen3.term, line8.terminal_p) annotation (Line(
          points={{110,-31},{110,-10},{100,-10}},
          color={0,120,120},
          smooth=Smooth.None));
      connect(EWin.u, winTur.P) annotation (Line(
          points={{198,-4},{141,-4}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(pv1.P, PSol.u[1]) annotation (Line(
          points={{-19,77},{-12,77},{-12,92},{160,92},{160,73.6},{174,73.6}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.u[2], pv2.P) annotation (Line(
          points={{174,72.4},{160,72.4},{160,92},{30,92},{30,77},{21,77}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.u[3], pv3.P) annotation (Line(
          points={{174,71.2},{160,71.2},{160,92},{70,92},{70,77},{61,77}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.u[4], pv4.P) annotation (Line(
          points={{174,70},{160,70},{160,92},{110,92},{110,77},{101,77}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.u[5], pv5.P) annotation (Line(
          points={{174,68.8},{160,68.8},{160,-90},{10,-90},{10,-63},{1,-63}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.y, ESol.u) annotation (Line(
          points={{187.02,70},{198,70}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.u[6], pv6.P) annotation (Line(
          points={{174,67.6},{168,67.6},{168,72},{160,72},{160,-90},{50,-90},{50,-63},
              {41,-63}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(PSol.u[7], pv7.P) annotation (Line(
          points={{174,66.4},{168,66.4},{168,68},{160,68},{160,-90},{90,-90},{90,-63},
              {81,-63}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(ELoa.u, PLoa.y) annotation (Line(
          points={{198,-60},{191,-60}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(EPro.u1, ESol.y) annotation (Line(
          points={{238,36},{230,36},{230,70},{221,70}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(EPro.u2, EWin.y) annotation (Line(
          points={{238,24},{230,24},{230,-4},{221,-4}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      connect(ERat.u1, EPro.y) annotation (Line(
          points={{278,6},{270,6},{270,30},{261,30}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));

      connect(ERat.u2, ELoa.y) annotation (Line(
          points={{278,-6},{270,-6},{270,-60},{221,-60}},
          color={0,0,127},
          smooth=Smooth.None,
          pattern=LinePattern.Dot));
      annotation (
        Documentation(revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed assignment of parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 2, 2015, by Michael Wetter:<br/>
Changed signals for post-processing to avoid using the conditionally
enabled connector <code>loa1.y</code> outside of a <code>connect</code>
statement.
</li>
<li>
March 27, 2015, by Michael Wetter:<br/>
Revised model.
</li>
<li>
March 25, 2015, by Marco Bonvini:<br/>
Added model.
</li>
</ul>
</html>",     info="<html>
<p>
This model shows the impact of renewables on the electric grid.
The sensors show how the voltage per unit fluctuates depending on
the building load and the power produced by the PV and the wind turbine.
To the right of the model is the post-processing that computes the
ratio of energy produced by the renewables over the energy consumed
by the loads.
</p>
<h4>Ratio between energy produced by renewables and energy consumed </h4>
<p>
Th image below shows the ratio between the energy produced by renewable energy sources
over the energy consumed by the loads over one year. The solid line indicates the
Net-Zero Energy goal and the blue line indicates the actual ratio for the
neighborhood represented by the model.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Examples/RenewableSources/EnergyRatio.png\"/>
</p>

<h4>Voltage losses due to power generated by renewables</h4>
<p>
The scatter plots show the voltage levels at different locations in the network. In particular,
the plots highlight how the voltage fluctuations are related to the power generated by the
renewable sources, to the wind speed and the global horizontal irradiation.
As expected, voltage increases with the power generated by the renewables,
causing possible instabilities to the electrical grid.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/Electrical/Examples/RenewableSources/VoltageLevel.png\"/>
</p>
</html>"),
    experiment(
          StopTime=2678400,
          Tolerance=1e-06),
                __Dymola_Commands(file=
              "modelica://Buildings/Resources/Scripts/Dymola/Electrical/Examples/RenewableSources.mos"
            "Simulate and plot"),
        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-120,-100},{320,
                100}})));
    end RenewableSources;
  annotation (Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.Electrical\">
Buildings.Electrical</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
March 25, 2015, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
  end Examples;

  package Interfaces "This package contains interfaces and partial models that are inherited by other components"
    extends Modelica.Icons.InterfacesPackage;

    connector BaseTerminal "Empty connector used by partial models"

      annotation (Documentation(info="<html>
This empty connector represents the base class extended by every electric connector of type
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">Buildings.Electrical.Interfaces.Terminal</a>.
</html>",     revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
</ul>
</html>"));
    end BaseTerminal;

    partial model CapacitiveLoad "Partial model of a capacitive load"
      extends Load;
      parameter Boolean use_pf_in = false "If true, the power factor is defined by an input"
        annotation(Dialog(group="Modeling assumption"));
      parameter Real pf(min=0, max=1) = 0.8 "Power factor"
      annotation(Dialog(group="Nominal conditions"));
      Modelica.Blocks.Interfaces.RealInput pf_in(
        min=0,
        max=1,
        unit="1") if (use_pf_in) "Power factor"
                       annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,60}),  iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,60})));
    protected
      function j = PhaseSystem.j "J operator that rotates of 90 degrees";
      Modelica.Blocks.Interfaces.RealInput pf_internal
        "Hidden value of the input load for the conditional connector";
      Modelica.Units.SI.ElectricCharge q[2](each stateSelect=StateSelect.prefer)
        "Electric charge";
      Modelica.Units.SI.Admittance[2] Y "Admittance";
      Modelica.Units.SI.AngularVelocity omega "Angular velocity";
      Modelica.Units.SI.Power Q=P*tan(-acos(pf_internal))
        "Reactive power (negative because capacitive load)";
    equation
      connect(pf_in, pf_internal);

      if not use_pf_in then
        pf_internal = pf;
      end if;

      annotation (Documentation(revisions="<html>
<ul>
<li>
June 06, 2014, by Marco Bonvini:<br/>
Added power factor input <code>pf_in</code> and updated documentation.
</li>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included into the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This is a model of a generic capacitive load. This model is an extension of the base load model
<a href=\"modelica://Buildings.Electrical.Interfaces.Load\">Buildings.Electrical.Interfaces.Load</a>.
</p>
<p>
This model assumes a fixed power factor <code>pf</code> when the flag <code>use_pf_in = false</code>
otherwise it uses the power factor specified by the input <code>pf_in</code>.
</p>
<p>The power factor (either the input or the parameter) is used to compute the reactive power
<code>Q</code> given the active power <code>P</code>
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q = - P * tan(arccos(pf))
</p>
</html>"));
    end CapacitiveLoad;

    model Ground "Generalized model of a ground connection."
      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
        annotation (choicesAllMatching=true);

      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          package PhaseSystem = PhaseSystem) "Generalized terminal" annotation (
         Placement(transformation(extent={{-8,92},{8,108}}), iconTransformation(
              extent={{-8,92},{8,108}})));
    equation
      terminal.v = zeros(PhaseSystem.n);
      annotation (Documentation(info="<html>
<p>
Given a generic electric connector
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">
Buildings.Electrical.Interfaces.Terminal</a> this
model imposes the following condition on the voltage <code>V[PhaseSystem.n]</code>
</p>
<p align=\"center\" style=\"font-style:italic;\">
<b>V</b> = <span style=\"text-decoration: overline;\">0</span>,
</p>
<p>
where <span style=\"text-decoration: overline;\">0</span> is a null vector of length <code>PhaseSystem.n</code>.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
</ul>
</html>"));
    end Ground;

    model Impedance "Partial model representing a generalized impedance"
      extends ProsNet.Electrical.Interfaces.Load(
        final linearized=false,
        final mode=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
        final P_nominal(fixed=true) = 0,
        final V_nominal(fixed=true) = 1);
      parameter Boolean inductive=true
        "If true, the load is inductive, otherwise it is capacitive"
        annotation (Evaluate=true, choices(
          choice=true "Inductive",
          choice=false "Capacitive",
          __Dymola_radioButtons=true));
      parameter Modelica.Units.SI.Resistance R(
        start=1,
        min=0) = 1 "Resistance" annotation (Dialog(enable=not use_R_in));
      parameter Modelica.Units.SI.Inductance L(
        start=0,
        min=0) = 0 "Inductance"
        annotation (Dialog(enable=inductive and (not use_L_in)));
      parameter Modelica.Units.SI.Capacitance C(
        start=0,
        min=0) = 0 "Capacitance"
        annotation (Dialog(enable=(not inductive) and (not use_C_in)));
      parameter Boolean use_R_in = false "If true, R is specified by an input"
         annotation(Evaluate=true, Dialog(tab = "Variable load", group="Resistance"));
      parameter Modelica.Units.SI.Resistance RMin(
        start=R,
        min=Modelica.Constants.eps) = 1e-4 "Minimum value of the resistance"
        annotation (Evaluate=true, Dialog(
          enable=use_R_in,
          tab="Variable load",
          group="Resistance"));
      parameter Modelica.Units.SI.Resistance RMax(
        start=R,
        min=Modelica.Constants.eps) = 1e2 "Maximum value of the resistance"
        annotation (Evaluate=true, Dialog(
          enable=use_R_in,
          tab="Variable load",
          group="Resistance"));
      parameter Boolean use_C_in = false "If true, C is specified by an input"
        annotation(Evaluate=true, Dialog(tab = "Variable load", group="Capacitance"));
      parameter Modelica.Units.SI.Capacitance CMin(
        start=C,
        min=Modelica.Constants.eps) = 1e-4 "Minimum value of the capacitance"
        annotation (Evaluate=true, Dialog(
          enable=use_C_in,
          tab="Variable load",
          group="Capacitance"));
      parameter Modelica.Units.SI.Capacitance CMax(
        start=C,
        min=Modelica.Constants.eps) = 1e2 "Maximum value of the capacitance"
        annotation (Evaluate=true, Dialog(
          enable=use_C_in,
          tab="Variable load",
          group="Capacitance"));
      parameter Boolean use_L_in = false "If true, L is specified by an input"
         annotation(Evaluate=true, Dialog(tab = "Variable load", group="Inductance"));
      parameter Modelica.Units.SI.Inductance LMin(
        start=L,
        min=Modelica.Constants.eps) = 1e-4 "Minimum value of the inductance"
        annotation (Evaluate=true, Dialog(
          enable=use_L_in,
          tab="Variable load",
          group="Inductance"));
      parameter Modelica.Units.SI.Inductance LMax(
        start=L,
        min=Modelica.Constants.eps) = 1e2 "Maximum value of the inductance"
        annotation (Evaluate=true, Dialog(
          enable=use_L_in,
          tab="Variable load",
          group="Inductance"));
      Modelica.Blocks.Interfaces.RealInput y_R(min=0, max=1) if use_R_in
        "Input that sepecify variable R"
        annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={-40,100})));
      Modelica.Blocks.Interfaces.RealInput y_C(min=0, max=1) if use_C_in
        "Input that sepecify variable C"
        annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={0,100})));
      Modelica.Blocks.Interfaces.RealInput y_L(min=0, max=1) if use_L_in
        "Input that sepecify variable L"
        annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={40,100})));
    protected
      Modelica.Blocks.Interfaces.RealOutput y_R_internal
        "Internal signal used to compute the variable R_internal";
      Modelica.Blocks.Interfaces.RealOutput y_C_internal
        "Internal signal used to compute the variable C_internal";
      Modelica.Blocks.Interfaces.RealOutput y_L_internal
        "Internal signal used to compute the variable L_internal";
      Modelica.Units.SI.Resistance R_internal
        "Actual resistance used to compute the impedance";
      Modelica.Units.SI.Inductance L_internal
        "Actual inductance used to compute the impedance";
      Modelica.Units.SI.Capacitance C_internal
        "Actual capacitance used to compute the impedance";
    equation
      // These assertions ensures that if the variable R, L or C is computed using the inputs
      // the parameters min and max are sorted
      assert((not use_R_in) or RMin < RMax, "The value of RMin has to be lower than RMax");
      assert((not use_L_in) or LMin < LMax, "The value of Lmin has to be lower than Lmax");
      assert((not use_C_in) or CMin < CMax, "The value of Cmin has to be lower than Cmax");

      // Connections to internal connectors
      connect(y_R, y_R_internal);
      connect(y_C, y_C_internal);
      connect(y_L, y_L_internal);

      // Default assignment when connectors are conditionally removed
      if not use_R_in then
        y_R_internal = 0;
      end if;

      if not use_C_in then
        y_C_internal = 0;
      end if;

      if not use_L_in then
        y_L_internal = 0;
      end if;

      // Retrieve the value of the R,L,C either if fixed or
      // varying
      if not use_R_in then
        R_internal = R;
      else
        R_internal = RMin + y_R_internal*(RMax - RMin);
      end if;

      if not use_C_in then
        C_internal = C;
      else
        C_internal = CMin + y_C_internal*(CMax - CMin);
      end if;

      if not use_L_in then
        L_internal = L;
      else
        L_internal = LMin + y_L_internal*(LMax - LMin);
      end if;

      annotation ( Documentation(info="<html>
<p>
This model represents a generalized interface for an impedance.
</p>
<p>
The model has a single generalized electric terminal of type
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">
Buildings.Electrical.Interfaces.Terminal</a>
that can be redeclared.
The impedance can be of different types:
</p>
<ol>
<li>resistive,</li>
<li>inductive,</li>
<li>resistive and inductive,</li>
<li>capacitive, and</li>
<li>resistive and capacitive.</li>
</ol>
<p>
The values of the resistance <code>R</code>, capacitance <code>C</code> and
inductance <code>L</code> can be
specified as parameters of the model.
</p>
<p>
The values of the resistance <code>R</code>, capacitance <code>C</code>
and inductance <code>L</code> can also be
specified by using the input variables <code>y_R</code>, <code>y_C</code>,
and <code>y_L</code> that are Real values between <i>[0,1]</i>.<br/>
These input values are enabled by the boolean flags <code>use_R_in</code>,
<code>use_L_in</code>, and
<code>use_C_in</code>.
</p>
<h5>Example</h5>
<p>
If the flag <code>use_R_in = true</code>, the value of <code>R</code> is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
R = R<sub>min</sub> + y<sub>R</sub> (R<sub>max</sub> - R<sub>min</sub>)
</p>
</html>",     revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
</ul>
</html>"));
    end Impedance;

    partial model InductiveLoad "Partial model of an inductive load"
      extends Load;
      parameter Boolean use_pf_in = false "If true, the power factor is defined by an input"
        annotation(Dialog(group="Modeling assumption"));
      parameter Real pf(min=0, max=1) = 0.8 "Power factor"
      annotation(Dialog(group="Nominal conditions"));
      Modelica.Blocks.Interfaces.RealInput pf_in(
        min=0,
        max=1,
        unit="1") if (use_pf_in) "Power factor"
                       annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,60}),  iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,60})));
    protected
      function j = PhaseSystem.j "J operator that rotates of 90 degrees";
      Modelica.Blocks.Interfaces.RealInput pf_internal
        "Hidden value of the input load for the conditional connector";
      Modelica.Units.SI.MagneticFlux psi[2](each stateSelect=StateSelect.prefer)
        "Magnetic flux";
      Modelica.Units.SI.Impedance Z[2] "Impedance of the load";
      Modelica.Units.SI.AngularVelocity omega "Angular frequency";
      Modelica.Units.SI.Power Q=P*tan(acos(
        Buildings.Utilities.Math.Functions.smoothMin(
          x1=pf_internal,
          x2=0.99999,
          deltaX=0.0000025)))
        "Reactive power (positive because inductive load)";
    equation
      connect(pf_in, pf_internal);

      if not use_pf_in then
        pf_internal = pf;
      end if;

      annotation (Documentation(revisions="<html>
<ul>
<li>
April 4, 2024, by Michael Wetter:<br/>
Reformulated calculation of reactive power to bound argument of tangent away from &pi;,
which avoids an infinite function value.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/3776\">Buildings, #3776</a>.
</li>
<li>
June 06, 2014, by Marco Bonvini:<br/>
Added power factor input <code>pf_in</code> and updated documentation.
</li>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included into the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This is a model of a generic inductive load. This model is an extension of the base load model
<a href=\"modelica://Buildings.Electrical.Interfaces.Load\">
Buildings.Electrical.Interfaces.Load</a>.
</p>
<p>
This model assumes a fixed power factor <code>pf</code> when the flag <code>use_pf_in = false</code>
otherwise it uses the power factor specified by the input <code>pf_in</code>.
</p>
<p>The power factor (either the input or the parameter) is used to compute the reactive power
<code>Q</code> given the active power <code>P</code>
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q = P  tan(arccos(pf))
</p>
</html>"));
    end InductiveLoad;

    model Load "Partial model for a generic load"
      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
        annotation (choicesAllMatching=true);
      parameter Boolean linearized = false "If true, the load model is linearized"
        annotation(Evaluate=true,Dialog(group="Modeling assumption"));
      parameter ProsNet.Electrical.Types.Load mode(
        min=ProsNet.Electrical.Types.Load.FixedZ_steady_state,
        max=ProsNet.Electrical.Types.Load.VariableZ_y_input)=ProsNet.Electrical.Types.Load.FixedZ_steady_state
        "Type of load model (e.g., steady state, dynamic, prescribed power consumption, etc.)"
        annotation (Evaluate=true, Dialog(group="Modeling assumption"));

      parameter Modelica.Units.SI.Power P_nominal=0
        "Nominal power (negative if consumed, positive if generated). Used if mode <> Buildings.Electrical.Types.Load.VariableZ_P_input"
        annotation (Dialog(group="Nominal conditions", enable=mode <> ProsNet.Electrical.Types.Load.VariableZ_P_input));

      parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
        "Nominal voltage (V_nominal >= 0)" annotation (Evaluate=true, Dialog(group=
              "Nominal conditions", enable=(mode == ProsNet.Electrical.Types.Load.FixedZ_dynamic
               or linearized)));
      parameter ProsNet.Electrical.Types.InitMode initMode(
        min=ProsNet.Electrical.Types.InitMode.zero_current,
        max=ProsNet.Electrical.Types.InitMode.linearized)=ProsNet.Electrical.Types.InitMode.zero_current
        "Initialization mode for homotopy operator"
        annotation (Dialog(tab="Initialization"));

      Modelica.Units.SI.Voltage v[:](start=PhaseSystem.phaseVoltages(V_nominal)) =
        terminal.v "Voltage vector";
      Modelica.Units.SI.Current i[:](each start=0) = terminal.i "Current vector";
      Modelica.Units.SI.Power S[PhaseSystem.n]=PhaseSystem.phasePowers_vi(v, -i)
        "Phase powers";
      Modelica.Units.SI.Power P(start=0)
        "Power of the load (negative if consumed, positive if fed into the electrical grid)";

      Modelica.Blocks.Interfaces.RealInput y(min=0, max=1, unit="1")
        if (mode == ProsNet.Electrical.Types.Load.VariableZ_y_input)
        "Fraction of the nominal power consumed" annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,0}), iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,0})));
      Modelica.Blocks.Interfaces.RealInput Pow(unit="W")
        if (mode == ProsNet.Electrical.Types.Load.VariableZ_P_input)
        "Power consumed" annotation (Placement(transformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,0}), iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=180,
            origin={100,0})));
      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          replaceable package PhaseSystem = PhaseSystem)
        "Generalized electric terminal" annotation (Placement(transformation(
              extent={{-108,-8},{-92,8}}), iconTransformation(extent={{-108,-8},
                {-92,8}})));

    protected
      Modelica.Blocks.Interfaces.RealInput y_internal
        "Hidden value of the input load for the conditional connector";
      Modelica.Blocks.Interfaces.RealInput P_internal
        "Hidden value of the input power for the conditional connector";
      Real load(min=eps, max=1)
        "Internal representation of control signal, used to avoid singularity";
      constant Real eps = 1E-10
        "Small number used to avoid a singularity if the power is zero";
      constant Real oneEps = 1-eps
        "Small number used to avoid a singularity if the power is zero";

    initial equation
      if mode == ProsNet.Electrical.Types.Load.VariableZ_P_input then
        assert(abs(P_nominal) < 1E-10, "*** Warning: P_nominal = " + String(P_nominal) + ", but this value will be ignored.",
               AssertionLevel.warning);
      end if;

    equation
      assert(y_internal>=0 and y_internal<=1+eps, "The power load fraction P (input of the model) must be within [0,1]");

      // Connection between the conditional and inner connector
      connect(y,y_internal);
      connect(Pow,P_internal);

      // If the power is fixed, inner connector value is equal to 1
      if mode == ProsNet.Electrical.Types.Load.FixedZ_steady_state or mode ==
          ProsNet.Electrical.Types.Load.FixedZ_dynamic then
        y_internal   = 1;
        P_internal = 0;
      elseif mode == ProsNet.Electrical.Types.Load.VariableZ_y_input then
        P_internal = 0;
      elseif mode == ProsNet.Electrical.Types.Load.VariableZ_P_input then
        y_internal = 1;
      end if;

      // Value of the load, depending on the type: fixed or variable
      if mode == ProsNet.Electrical.Types.Load.VariableZ_y_input then
        load = eps + oneEps*y_internal;
      else
        load = 1;
      end if;

      // Power consumption
      if mode == ProsNet.Electrical.Types.Load.FixedZ_steady_state or mode ==
          ProsNet.Electrical.Types.Load.FixedZ_dynamic then
        P = P_nominal;
      elseif mode == ProsNet.Electrical.Types.Load.VariableZ_P_input then
        P = P_internal;
      else
        P = P_nominal*load;
      end if;

      annotation ( Documentation(revisions="<html>
<ul>
<li>
January 30, 2019, by Michael Wetter:<br/>
Set start value for <code>P</code>.
</li>
<li>
November 28, 2016, by Michael Wetter:<br/>
Removed zero start value for current.
The current is typically non-zero and zero is anyway the default start value, hence there is no need to set it.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/584\">#584</a>.
</li>
<li>
September 17, 2016, by Michael Wetter:<br/>
Corrected wrong annotation to avoid an error in the pedantic model check
in Dymola 2017 FD01 beta2.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/557\">issue 557</a>.
</li>
<li>
February 26, 2016, by Michael Wetter:<br/>
Set default value for <code>P_nominal</code>
and removed assertion warning.
This is required for pedantic model check in Dymola.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
September 24, 2015 by Michael Wetter:<br/>
Provided value for <code>P_nominal</code> if
<code>mode &lt;&gt; Buildings.Electrical.Types.Load.VariableZ_P_input</code>.
This avoids a warning during translation of
<a href=\"modelica://Buildings.Examples.ChillerPlant.DataCenterRenewables\">
Buildings.Examples.ChillerPlant.DataCenterRenewables</a>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Changed the parameter from <code>linear</code> to <code>linearized</code>
because <code>Buildings.Fluid</code> also uses <code>linearized</code>.
This change has been done to use a consistent naming across the library.
</li>
<li>June 17, 2014, by Marco Bonvini:<br/>
Adde parameter <code>initMode</code> that can be used to
select the assumption to be used during initialization phase
by the homotopy operator.
</li>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation and revised model.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included in the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This model represents a generic load that can be extended to represent
either a DC or an AC load.
</p>
<p>
The model has a single generalized electric terminal of type
<a href=\"modelica://Buildings.Electrical.Interfaces.Terminal\">
Buildings.Electrical.Interfaces.Terminal</a>
that can be redeclared.
The generalized load is modeled as an impedance whose value can change. The value of the impedance
can change depending on the value of the parameter <code>mode</code>, which is of type
<a href=\"modelica://Buildings.Electrical.Types.Load\">Buildings.Electrical.Types.Load</a>:
</p>

<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<tr>
<th>Mode</th>
<th>Description</th>
<th>Explanation</th>
</tr>
<!-- ************ -->
<tr>
<td>Buildings.Electrical.Types.Load.FixedZ_steady_state</td>
<td>fixed Z steady state</td>
<td>The load consumes exactly the power
specified by the parameter <code>P_nominal</code>.
</td>
</tr>
<!-- ************ -->
<tr>
<td>Buildings.Electrical.Types.Load.FixedZ_dynamic</td>
<td>fixed Z dynamic</td>
<td>
The load consumes exactly the power
specified by the parameter <code>P_nominal</code> at steady state.
Depending on the type
of load (e.g., inductive or capacitive)
different dynamics are represented.
</td>
</tr>
<!-- ************ -->
<tr>
<td>Buildings.Electrical.Types.Load.VariableZ_P_input</td>
<td>variable Z P input</td>
<td>
The load consumes exactly the power specified
by the input variable <code>Pow</code>.
</td>
</tr>
<!-- ************ -->
<tr>
<td>Buildings.Electrical.Types.Load.VariableZ_y_input</td>
<td>variable Z y input</td>
<td>
The load consumes exactly the a fraction of the nominal power
<code>P_nominal</code> specified by the input variable <code>y</code>.
</td>
</tr>
<!-- ************ -->
</table>


<h4>Conventions</h4>
<p>
It is assumed that the power <code>P</code> of the load is positive when produced
(e.g., the load acts like a source) and negative when consumed (e.g., the
source acts like a utilizer).
</p>

<h4>Linearized models</h4>
<p>
The model has a Boolean parameter <code>linearized</code> that by default is equal to <code>false</code>.
When the power consumption of the load is imposed, this introduces
a nonlinear equation between the voltage and the current of the load. This flag is used to
select between a linearized version
of the equations or the original nonlinear ones.<br/>
When the linearized version of the model is used, the parameter <code>V_nominal</code> has to
be specified. The nominal voltage is needed to linearize the nonlinear equations.<br/>
</p>
<p>
<b>Note:</b>
A linearized model will not consume the nominal power if the voltage
at the terminal differs from the nominal voltage.
</p>

</html>"));
    end Load;

    model PartialBaseTwoPort "Model of a generic two port component"

      replaceable ProsNet.Electrical.Interfaces.BaseTerminal terminal_n
        "Electric terminal side p"
        annotation (Placement(transformation(extent={{-108,-8},{-92,8}})));
      replaceable ProsNet.Electrical.Interfaces.BaseTerminal terminal_p
        "Electric terminal side n"
        annotation (Placement(transformation(extent={{92,-8},{108,8}})));

      annotation (Documentation(revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
</ul>
</html>",     info="<html>
<p>
This model declares connectors for electrical components with two terminals.
</p>
</html>"));
    end PartialBaseTwoPort;

    model PartialConversion
      "Model representing a generic two port system for conversion"
      extends ProsNet.Electrical.Interfaces.PartialTwoPort;
      Modelica.Units.SI.Voltage v_p "Voltage drop between the two positive pins";
      Modelica.Units.SI.Voltage v_n "Voltage drop between the two negative pins";
      Modelica.Units.SI.Current i_p "Current flowing through the positive pins";
      Modelica.Units.SI.Current i_n "Current flowing through the negative pins";
    equation
      i_p = PhaseSystem_p.systemCurrent(terminal_p.i);
      i_n = PhaseSystem_n.systemCurrent(terminal_n.i);

      v_p = PhaseSystem_p.systemVoltage(terminal_p.v);
      v_n = PhaseSystem_n.systemVoltage(terminal_n.v);

      annotation (Documentation(revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included in the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This model extends the base class
<a href=\"modelica://Buildings.Electrical.Interfaces.PartialTwoPort\">
Buildings.Electrical.Interfaces.PartialTwoPort</a>
model and declares the variables
<code>v_p</code> and <code>i_p</code> that represents the voltage and the
current at the <code>terminal_p</code>, and the variables
<code>v_n</code> and <code>i_n</code> that represents the voltage and the
current at the <code>terminal_n</code>.
These variables are used in conversion models such as transformers and AC/DC converters.
</p>
</html>"));
    end PartialConversion;

    model PartialPV "Base model for a PV system"
      extends ProsNet.Electrical.Interfaces.PartialPvBase;
      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
        annotation (choicesAllMatching=true);
      parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
        "Nominal voltage (V_nominal >= 0)"
        annotation (Evaluate=true, Dialog(group="Nominal conditions"));
      Modelica.Blocks.Interfaces.RealInput G(unit="W/m2")
        "Total solar irradiation per unit area"
         annotation (Placement(transformation(
            origin={0,70},
            extent={{-20,-20},{20,20}},
            rotation=270), iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={0,120})));

      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          final package PhaseSystem = PhaseSystem) "Generalized terminal"
        annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

    protected
      Modelica.Blocks.Sources.RealExpression solarPower(y=A*fAct*eta*G)
        "Solar energy converted at the PV panel"
        annotation (Placement(transformation(extent={{91,-10},{71,10}})));

    equation
      assert(solarPower.y>=0, "Solar power must be positive");

      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Line(points={{-90,0},{-59,0}}, color={0,0,0}),
            Text(
              extent={{-150,-104},{150,-64}},
              textColor={0,0,0},
              textString="%name"),
            Polygon(
              points={{-80,-52},{-32,63},{78,63},{29,-52},{-80,-52}},
              smooth=Smooth.None,
              fillColor={205,203,203},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Polygon(
              points={{-69,-45},{-57,-19},{-34,-19},{-45,-45},{-69,-45}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Text(
              extent={{-5,100},{98,136}},
              textColor={0,0,127},
              textString="G"),
            Polygon(
              points={{-53,-9},{-41,17},{-18,17},{-29,-9},{-53,-9}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-38,27},{-26,53},{-3,53},{-14,27},{-38,27}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-36,-45},{-24,-19},{-1,-19},{-12,-45},{-36,-45}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-20,-9},{-8,17},{15,17},{4,-9},{-20,-9}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-5,27},{7,53},{30,53},{19,27},{-5,27}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-3,-45},{9,-19},{32,-19},{21,-45},{-3,-45}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{13,-9},{25,17},{48,17},{37,-9},{13,-9}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{28,27},{40,53},{63,53},{52,27},{28,27}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Text(
              extent={{102,107},{124,81}},
              textColor={0,0,127},
              textString="P")}),
        Documentation(revisions="<html>
<ul>
<li>
October 7, 2019, by Michael Wetter:<br/>
Removed connector between <code>solarPower.y</code> and <code>P</code>
as for DC panels, an additional gain must be included in this connection.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1577\">1577</a>.
</li>
<li>
January 4, 2013, by Michael Wetter:<br/>
First implementation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Models included in the Buildings library. Modified the information section.
</li>
</ul>
</html>",   info="<html>
<p>
Partial model of a simple photovoltaic array.
</p>
<p>
This model computes the power as <i>P=A &nbsp; f<sub>act</sub> &nbsp; &eta; &nbsp; G</i>,
where <i>A</i> is the panel area,
<i>f<sub>act</sub></i> is the fraction of the aperture area,
<i>&eta;</i> is the panel efficiency and
<i>G</i> is the total solar irradiation.
</p>
<p>
<b>Note:</b> This model takes as input the total solar irradiation on the panel.
This has to be computed converting the incoming radiation to take tilt and azimuth into account.
</p>
<p>
The electrical connector is a general electrical interface.
</p>
</html>"));
    end PartialPV;

    model PartialPVOriented "Base model of a PV system with orientation"
      extends ProsNet.Electrical.Interfaces.PartialPvBase;

      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
        annotation (choicesAllMatching=true);

      parameter Modelica.Units.SI.Angle til "Surface tilt"
        annotation (Evaluate=true, Dialog(group="Orientation"));
      parameter Modelica.Units.SI.Angle azi "Surface azimuth"
        annotation (Evaluate=true, Dialog(group="Orientation"));
      parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
        "Nominal voltage (V_nominal >= 0)"
        annotation (Evaluate=true, Dialog(group="Nominal conditions"));

      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          final package PhaseSystem = PhaseSystem) "Generalized terminal"
        annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

      replaceable PartialPV panel constrainedby PartialPV(
        redeclare final package PhaseSystem = PhaseSystem,
        final A=A,
        final fAct=fAct,
        final eta=eta) "PV panel"
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      Buildings.BoundaryConditions.WeatherData.Bus weaBus "Weather data"
        annotation (Placement(transformation(extent={{-10,80},{10,100}}),
            iconTransformation(extent={{-10,80},{10,100}})));
    protected
      Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez HDifTil(final til
          =til, final azi=azi) "Diffuse irradiation on tilted surface"
        annotation (Placement(transformation(extent={{-66,62},{-46,82}})));
      Buildings.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirTil(final til
          =til, final azi=azi) "Direct irradiation on tilted surface"
        annotation (Placement(transformation(extent={{-66,35},{-46,55}})));

      Modelica.Blocks.Math.Add G "Total irradiation on tilted surface"
        annotation (Placement(transformation(extent={{10,-10},{-10,10}},
            rotation=90,
            origin={0,30})));

    equation
      connect(panel.P, P) annotation (Line(
          points={{11,7},{60,7},{60,70},{110,70}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(terminal, panel.terminal) annotation (Line(
          points={{-100,0},{-10,0}},
          color={0,0,0},
          smooth=Smooth.None));
      connect(HDifTil.H,G. u1) annotation (Line(
          points={{-45,72},{-6,72},{-6,42}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(HDirTil.H,G. u2) annotation (Line(
          points={{-45,45},{-30,45},{-30,55},{6,55},{6,42}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(G.y, panel.G) annotation (Line(
          points={{-1.33227e-15,19},{0,19},{0,12}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(HDifTil.weaBus, weaBus) annotation (Line(
          points={{-66,72},{-90,72},{-90,90},{4.44089e-16,90}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(weaBus, HDirTil.weaBus) annotation (Line(
          points={{0,90},{-90,90},{-90,45},{-66,45}},
          color={255,204,51},
          thickness=0.5,
          smooth=Smooth.None), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            grid={1,1}), graphics={
            Line(points={{-90,0},{-59,0}}, color={0,0,0}),
            Text(
              extent={{-150,-104},{150,-64}},
              textColor={0,0,0},
              textString="%name"),
            Polygon(
              points={{-80,-52},{-32,63},{78,63},{29,-52},{-80,-52}},
              smooth=Smooth.None,
              fillColor={205,203,203},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None,
              lineColor={0,0,0}),
            Polygon(
              points={{-69,-45},{-57,-19},{-34,-19},{-45,-45},{-69,-45}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-53,-9},{-41,17},{-18,17},{-29,-9},{-53,-9}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-38,27},{-26,53},{-3,53},{-14,27},{-38,27}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-36,-45},{-24,-19},{-1,-19},{-12,-45},{-36,-45}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-20,-9},{-8,17},{15,17},{4,-9},{-20,-9}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-5,27},{7,53},{30,53},{19,27},{-5,27}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{-3,-45},{9,-19},{32,-19},{21,-45},{-3,-45}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{13,-9},{25,17},{48,17},{37,-9},{13,-9}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Polygon(
              points={{28,27},{40,53},{63,53},{52,27},{28,27}},
              smooth=Smooth.None,
              fillColor={6,13,150},
              fillPattern=FillPattern.Solid,
              pattern=LinePattern.None),
            Text(
              extent={{102,107},{124,81}},
              textColor={0,0,127},
              textString="P")}),
        Documentation(revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> as this is now obtained from the weather data reader.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
September 4, 2014, by Michael Wetter:<br/>
Revised model, changed some instances to be protected.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>",   info="<html>
<p>
Partial model of a simple photovoltaic array.
</p>
<p>
This model takes as an input the
direct and diffuse solar radiation from the weather data bus.
</p>
<p>
This model computes the power as <i>P=A &nbsp; f<sub>act</sub> &nbsp; &eta; &nbsp; G</i>,
where <i>A</i> is the panel area,
<i>f<sub>act</sub></i> is the fraction of the aperture area,
<i>&eta;</i> is the panel efficiency and
<i>G</i> is the total solar irradiation, which is the sum of
direct and diffuse irradiation.
The model takes into account the location and the orientation of the PV panel,
specified by the surface tilt, latitude and azimuth.
</p>
</html>"));
    end PartialPVOriented;

    partial model PartialPvBase "Partial model with basic parameters for PVs"
      parameter Modelica.Units.SI.Area A "Gross surface area (including area not covered with active PV cells)";
      parameter Real fAct(min=0, max=1, unit="1") = 0.9
        "Fraction of surface area with active solar cells";
      parameter Real eta(min=0, max=1, unit="1") = 0.12
        "Module conversion efficiency";
      Modelica.Blocks.Interfaces.RealOutput P(unit="W") "Generated power"
        annotation (Placement(transformation(extent={{100,60},{120,80}})));
      annotation (Documentation(info="<html>
<p>
This model contains the minimum set of parameters necessary to describe
a PV system.
The model defines also an output <code>P</code> for the power generated by the PVs.
</p>
</html>",     revisions="<html>
<ul>
<li>
March 23, 2022, by Michael Wetter:<br/>
Corrected documentation string for parameter <code>A</code>.
</li>
<li>
January 29, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
    end PartialPvBase;

    model PartialTwoPort "Model of a generic two port component with phase systems"

      replaceable package PhaseSystem_p =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem
        "Phase system of terminal p"
        annotation (choicesAllMatching=true);

      replaceable package PhaseSystem_n =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem
        "Phase system of terminal n"
        annotation (choicesAllMatching=true);

      extends ProsNet.Electrical.Interfaces.PartialBaseTwoPort(redeclare replaceable
                      ProsNet.Electrical.Interfaces.Terminal terminal_n
          constrainedby ProsNet.Electrical.Interfaces.Terminal(redeclare
            replaceable package PhaseSystem = PhaseSystem_n), redeclare replaceable
                      ProsNet.Electrical.Interfaces.Terminal terminal_p
          constrainedby ProsNet.Electrical.Interfaces.Terminal(redeclare
            replaceable package PhaseSystem = PhaseSystem_p));

      annotation (Documentation(revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included into the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This is a model of a component with two electric terminals.
It represents a common interface that is extended by other models.
</p>
</html>"));
    end PartialTwoPort;

    model PartialWindTurbine
      "Partial model of a wind turbine with power output based on table as a function of wind speed"
      extends ProsNet.Electrical.Interfaces.PartialWindTurbineBase;
      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem
        "Phase system"
        annotation (choicesAllMatching=true);

      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          package PhaseSystem = PhaseSystem) "Generalized terminal"
        annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
    protected
      Modelica.Blocks.Tables.CombiTable1Ds per(
        final tableOnFile=tableOnFile,
        final table=cat(1, cat(1, [0, 0], table),
                        [vOut+10*Modelica.Constants.eps, 0;
                         vOut+20*Modelica.Constants.eps, 0]),
        final tableName=tableName,
        final fileName=fileName,
        final columns=2:2,
        final smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments)
        "Performance table that maps wind speed to electrical power output"
        annotation (Placement(transformation(extent={{-30,20},{-10,40}})));
      Modelica.Blocks.Math.Gain gain(final k=scale)
        "Gain, used to allow a user to easily scale the power"
        annotation (Placement(transformation(extent={{2,20},{22,40}})));
      DC.Sources.BaseClasses.WindCorrection                      cor(
        final h=h,
        final hRef=hRef,
        final n=nWin) "Correction for wind"
      annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            origin={-50,30})));
    initial equation
      assert(abs(table[1,2]) < Modelica.Constants.eps,
      "First data point of performance table must be at cut-in wind speed,
   and be equal to 0 Watts.
   Received + "     + String(table[1,1]) + " m/s with " + String(table[1,2]) + " Watts");
    equation
      assert(gain.y>=0, "Wind power must be positive");
      connect(per.y[1],gain. u) annotation (Line(
          points={{-9,30},{0,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(vWin,cor. vRef) annotation (Line(
          points={{1.77636e-15,120},{1.77636e-15,90},{-70,90},{-70,30},{-62.2,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(cor.vLoc,per. u) annotation (Line(
          points={{-39,30},{-32,30}},
          color={0,0,127},
          smooth=Smooth.None));
      connect(gain.y, P) annotation (Line(
          points={{23,30},{60,30},{60,60},{110,60}},
          color={0,0,127},
          smooth=Smooth.None));
      annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Rectangle(
              extent={{-100,102},{100,-98}},
              pattern=LinePattern.None,
              fillColor={202,230,255},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Rectangle(
              extent={{42,46},{46,-52}},
              fillColor={233,233,233},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Rectangle(
              extent={{-42,14},{-38,-84}},
              fillColor={233,233,233},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Polygon(
              points={{-44,12},{-26,-40},{-38,16},{-44,12}},
              smooth=Smooth.None,
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Polygon(
              points={{-38,12},{8,46},{-42,18},{-38,12}},
              smooth=Smooth.None,
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Polygon(
              points={{-42,12},{-90,40},{-38,18},{-42,12}},
              smooth=Smooth.None,
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Polygon(
              points={{40,44},{100,40},{42,50},{40,44}},
              smooth=Smooth.None,
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid,
              lineColor={0,0,0}),
            Polygon(
              points={{-21,-17},{27,17},{-25,-11},{-21,-17}},
              smooth=Smooth.None,
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid,
              origin={29,69},
              rotation=90,
              lineColor={0,0,0}),
            Polygon(
              points={{24,-14},{-20,22},{26,-8},{24,-14}},
              smooth=Smooth.None,
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid,
              origin={32,20},
              rotation=90,
              lineColor={0,0,0}),
            Ellipse(
              extent={{-46,20},{-34,8}},
              lineColor={0,0,0},
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{38,52},{50,40}},
              lineColor={0,0,0},
              fillColor={222,222,222},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-42,134},{-20,108}},
              textColor={0,0,127},
              textString="v"),
            Text(
              extent={{100,100},{122,74}},
              textColor={0,0,127},
              textString="P")}),
        Documentation(info="<html>
<p>
Model of a wind turbine whose power is computed as a function of wind-speed as defined in a table.
</p>
<p>
Input to the model is the local wind speed.
The model requires the specification of a table that maps wind speed in meters per second to generated
power <i>P<sub>t</sub></i> in Watts.
The model has a parameter called <code>scale</code> with a default value of one
that can be used to scale the power generated by the wind turbine.
The generated electrical power is
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>t</sub> scale
</p>
<p>
For example, the following specification (with default <code>scale=1</code>) of a wind turbine
</p>
<pre>
  WindTurbine_Table tur(
    table=[3.5, 0;
           5.5,   100;
           12, 900;
           14, 1000;
           25, 1000]) \"Wind turbine\";
</pre>
<p>
yields the performance shown below. In this example, the cut-in wind speed is
<i>3.5</i> meters per second,
and the cut-out wind speed is <i>25</i> meters per second,
as entered by the first and last entry of the wind speed column.
Below and above these wind speeds, the generated power is zero.
</p>
<p align=\"center\">
<img alt=\"alt-image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Sources/WindTurbine_Table.png\"/>
</p>
</html>",     revisions="<html>
<ul>
<li>
March 1, 2016, by Michael Wetter:<br/>
Removed test for equality of <code>Real</code> variables.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/493\">issue 493</a>.
</li>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Models included in the Buildings library. Modified the information section.
</li>
</ul>
</html>"));
    end PartialWindTurbine;

    partial model PartialWindTurbineBase
      "Base class for turbine model that contains basic parameters"
      final parameter Modelica.Units.SI.Velocity vIn=table[1, 1]
        "Cut-in steady wind speed";
      final parameter Modelica.Units.SI.Velocity vOut=table[size(table, 1), 1]
        "Cut-out steady wind speed";
      parameter Real scale(min=0)=1
        "Scaling factor, used to allow adjusting the power output without changing the table";

      parameter Real h "Height over ground"
        annotation (Dialog(group="Wind correction"));
      parameter Modelica.Units.SI.Height hRef=10
        "Reference height for wind measurement"
        annotation (Dialog(group="Wind correction"));
     parameter Real nWin(min=0) = 0.4
        "Height exponent for wind profile calculation"
       annotation (Dialog(group="Wind correction"));

      parameter Boolean tableOnFile=false
        "true, if table is defined on file or in function usertab";
      parameter Real table[:,2]=
              [3.5, 0;
               5.5, 0.1;
               12, 0.9;
               14, 1;
               25, 1]
        "Table of generated power (first column is wind speed, second column is power)";
      parameter String tableName="NoName"
        "Table name on file or in function usertab (see documentation)";
      parameter String fileName="NoName" "File where matrix is stored";
      parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
        "Nominal voltage (V_nominal >= 0)"
        annotation (Evaluate=true, Dialog(group="Nominal conditions"));
      Modelica.Blocks.Interfaces.RealInput vWin(unit="m/s") "Steady wind speed"
         annotation (Placement(transformation(
            origin={0,120},
            extent={{-20,-20},{20,20}},
            rotation=270), iconTransformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={0,120})));
      Modelica.Blocks.Interfaces.RealOutput P(unit="W") "Generated power"
        annotation (Placement(transformation(extent={{100,50},{120,70}})));
      annotation (Documentation(info="<html>
<p>
This partial model contains the minimum set of parameters necessary to describe
a wind turbine.
The model defines also an output <code>P</code> for the power generated by the wind turbine.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end PartialWindTurbineBase;

    partial model ResistiveLoad "Partial model of a resistive load"
      extends Load;

      annotation (Documentation(revisions="<html>
<ul>
<li>
May 14, 2015, by Marco Bonvini:<br/>
Created model to solve problems related to OpenModelica as described
in issue <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/415\">#415</a>.<br/>
OpenModelica cannot determine the value
<code>PhaseSystem.n</code> when models like
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Resistive\">
Buildings.Electrical.AC.OnePhase.Loads.Resistive</a>
inherit directly from
<a href=\"modelica://Buildings.Electrical.Interfaces.LoadBuildings.Electrical.Interfaces.Load\">
Buildings.Electrical.Interfaces.LoadBuildings.Electrical.Interfaces.Load</a>.<br/>
The same problem does not happen with models like
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Capacitive\">
Buildings.Electrical.AC.OnePhase.Loads.Capacitive</a> or
<a href=\"modelica://Buildings.Electrical.AC.OnePhase.Loads.Inductive\">
Buildings.Electrical.AC.OnePhase.Loads.Inductive</a> since they inherit
from a different model.<br/>
For such a reason this interface for resistive load model has been
added to the library.
</li>
</ul>
</html>",     info="<html>
<p>
This is a model of a generic resistive load. This model is an extension of the base load model
<a href=\"modelica://Buildings.Electrical.Interfaces.Load\">
Buildings.Electrical.Interfaces.Load</a>.
</p>
</html>"));
    end ResistiveLoad;

    model Source "Partial model of a generic source."
      replaceable package PhaseSystem =
          ProsNet.Electrical.PhaseSystems.OnePhase constrainedby
        ProsNet.Electrical.PhaseSystems.PartialPhaseSystem   "Phase system"
        annotation (choicesAllMatching=true);
      parameter Boolean potentialReference = true
        "Serve as potential root for the reference angle theta"
         annotation (Evaluate=true, Dialog(group="Reference Parameters"));
      parameter Boolean definiteReference = false
        "Serve as definite root for the reference angle theta"
         annotation (Evaluate=true, Dialog(group="Reference Parameters"));
      Modelica.Units.SI.Power S[PhaseSystem.n]=PhaseSystem.phasePowers_vi(terminal.v,
          terminal.i) "Complex power S[1] = P, S[2]= Q";
      Modelica.Units.SI.Angle phi=PhaseSystem.phase(terminal.v) - PhaseSystem.phase(
          -terminal.i) "Phase shift with respect to reference angle";
      replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
          final replaceable package PhaseSystem = PhaseSystem)
        "Generalized terminal"
        annotation (Placement(transformation(extent={{92,-8},{108,8}})));
    protected
      function j = PhaseSystem.j;
    equation
      if potentialReference then
          if definiteReference then
            Connections.root(terminal.theta);
          else
            Connections.potentialRoot(terminal.theta);
          end if;
      end if;
      annotation ( Documentation(revisions="<html>
<ul>
<li>
February 26, 2016, by Michael Wetter:<br/>
Updated documentation for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/427\">issue 427</a>.
</li>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included into the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This model represents a generic source.
</p>
<p>
In case the phase system has <code>PhaseSystem.m &gt; 0</code> and
thus the connectors are over determined,
the source can be selected to serve as reference point.
The parameters <code>potentialReference</code> and <code>definiteReference</code>
are used to define if the source model should be selected as source for
the reference angles <code>theta</code> or not.
More information about overdetermined connectors can be found
in <a href=\"#Olsson2008\">Olsson Et Al. (2008)</a>.
</p>

<h4>References</h4>
<p>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.
</p>
</html>"));
    end Source;

    connector Terminal "Generalized electric terminal"
      extends ProsNet.Electrical.Interfaces.BaseTerminal;
    replaceable package PhaseSystem = PhaseSystems.PartialPhaseSystem
        "Phase system"
      annotation (choicesAllMatching=true);
    PhaseSystem.Voltage v[PhaseSystem.n] "Voltage vector";
    flow PhaseSystem.Current i[PhaseSystem.n](each start=0) "Current vector";
    PhaseSystem.ReferenceAngle theta[PhaseSystem.m]
        "Optional vector of phase angles";
      annotation (Documentation(revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Created documentation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Model included into the Buildings library.
</li>
</ul>
</html>",     info="<html>
<p>
This connector represents a generalized electric terminal. The generalization is made possible by the
replaceable package <a href=\"modelica://Buildings.Electrical.Interfaces.Terminal.PhaseSystem\">
Buildings.Electrical.Interfaces.Terminal.PhaseSystem</a>.
The package <code>PhaseSystem</code> can be one of the packages contained in
<a href=\"modelica://Buildings.Electrical.PhaseSystems\">
Buildings.Electrical.PhaseSystems</a>.
Using this approach allows to represent DC, single phase AC and
multi phases balanced and unbalanced AC systems with the same connector.
</p>
<p>
This connector is compatible with the following Modelica libraries:
</p>
<ul>
<li><a href=\"http://www.modelon.com/products/modelica-libraries/electric-power-library\">
Electric Power Library</a>
developed by Modelon, and
</li>
<li>
<a href=\"https://github.com/modelica/PowerSystems\">Power Systems Library</a>
developed by <a href=\"mailto:Ruediger.Franke@de.abb.com\">Ruediger Franke</a> (ABB).
</li>
</ul>
<p>
The connector is overdetermined since the number of effort variables
is higher than the number of flow variables.
This happens when the phase system has a number of reference angles
<code>PhaseSystem.m &gt; 0</code>.
The over-determined connectors are defined and used in such a way
that a Modelica tool is able
to remove the superfluous but consistent equations arriving
at a balanced set of equations, based on a
graph analysis of the connection structure.
The models have to use ad-hoc constructs specified by the Modelica language to handle this situation.
More information can be found in <a href=\"#Olsson2008\">Olsson Et Al. (2008)</a>.
</p>
<p>
More details about the generalized electrical terminal
can be found in <a href=\"#RuedigerEtAl2014\">Franke and Wiesmann (2014)</a>.
</p>
<h4>References</h4>
<p>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.<br/>
</p>
<p>
<a name=\"RuedigerEtAl2014\"/>
Ruediger Franke and Hansjurg Wiesmann.<br/>
<a href=\"https://www.modelica.org/events/modelica2014/proceedings/html/submissions/ECP14096515_FrankeWiesmann.pdf\">
Flexible modeling of electrical power systems - the Modelica PowerSystems library</a>.<br/>
Proc. of the 10th Modelica Conference, Lund, Sweden, March 2014.
</p>
</html>"));
    end Terminal;

    model VariableVoltageSource
      "Partial model of a generic variable voltage source."
      extends ProsNet.Electrical.Interfaces.Source;
      parameter Boolean use_V_in = true "If true, the voltage is an input";
      parameter Modelica.Units.SI.Voltage V=1 "Value of constant voltage"
        annotation (Dialog(enable=not use_V_in));
      Modelica.Blocks.Interfaces.RealInput V_in(unit="V", min=0, start = 1)
        if use_V_in "Input voltage"
                        annotation (Placement(transformation(
            extent={{20,-20},{-20,20}},
            rotation=180,
            origin={-100,60}),
                             iconTransformation(
            extent={{20,-20},{-20,20}},
            rotation=180,
            origin={-100,60})));
    protected
      Modelica.Blocks.Interfaces.RealInput  V_in_internal(unit="V")
        "Hidden value of the input voltage for the conditional connector";
    equation

      // Connection between the conditional and inner connector
      connect(V_in,V_in_internal);

      // If the voltage is fixed, inner connector value is equal to parameter V
      if use_V_in == false then
        V_in_internal = V;
      end if;
      annotation ( Documentation(revisions="<html>
<ul>
<li>
October 14, 2014, by Marco Bonvini:<br/>
Model included into the Buildings library, added documentation.
</li>
</ul>
</html>",     info="<html>
<p>
This model represents a generic variable voltage source. The model has a boolean
flag <code>use_V_in</code>, when this flag is equal to <code>true</code>
the voltage of the source is imposed by the input variable <code>V_in</code>.
When the flag is equal to <code>false</code> the voltage source is equal to the parameter <code>V</code>.
</p>
<p>
In case the phase system adopted has <code>PhaseSystem.m &gt; 0</code> and
thus the connectors are over determined,
the source can be selected to serve as reference point.
The parameters <code>potentialReference</code> and <code>definiteReference</code> are used to define if the
source model should be selected as source for the reference angles or not.
More information about overdetermined connectors can be found
in <a href=\"#Olsson2008\">Olsson Et Al. (2008)</a>.
</p>

<h4>References</h4>
<p>
<a name=\"Olsson2008\"/>
Hans Olsson, Martin Otter, Sven Erik Mattson and Hilding Elmqvist.<br/>
<a href=\"http://elib-v3.dlr.de/55892/1/otter2008-modelica-balanced-models.pdf\">
Balanced Models in Modelica 3.0 for Increased Model Quality</a>.<br/>
Proc. of the 7th Modelica Conference, Bielefeld, Germany, March 2008.
</p>
</html>"));
    end VariableVoltageSource;

    record PartialAcDcParameters
      "Partial model that contains basic parameters for a DC/AC conversion system"
      parameter Real pf(min=0, max=1) = 0.9 "Power factor"
        annotation (Dialog(group="AC-Conversion"));
      parameter Real eta_DCAC(min=0, max=1) = 0.9 "Efficiency of DC/AC conversion"
        annotation (Dialog(group="AC-Conversion"));
      annotation (Documentation(info="<html>
<p>
This model contains the minimum set of parameters necessary to describe
an AC/DC converter.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 29, 2014, by Marco Bonvini:<br/>
First implementation.
</li>
</ul>
</html>"));
    end PartialAcDcParameters;

    record PartialPluggableUnbalanced "Partial interface for unbalanced loads"
      parameter Boolean plugPhase1 = true "If true, phase 1 is connected";
      parameter Boolean plugPhase2 = true "If true, phase 2 is connected";
      parameter Boolean plugPhase3 = true "If true, phase 3 is connected";
      annotation (Documentation(info="<html>
<p>
This record contains a set of parameters that are used when
modeling three-phase unbalanced systems. The record contains three boolean flags
that are used to determine which of the three-phase are connected to the network.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 24, 2014, by Marco Bonvini:<br/>
Changed <code>PlugPhase*</code> to <code>plugPhase*</code>.
</li>
<li>
June 4, 2014, by Marco Bonvini:<br/>
Added the information section.
</li>
</ul>
</html>"));
    end PartialPluggableUnbalanced;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models for electrical systems.
The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>",
  revisions="<html>
<ul>
<li>
May 15, 2014, by Marco Bonvini:<br/>
Added User's guide.
</li>
</ul>
</html>"));
  end Interfaces;

  package BaseClasses "Package with base classes for Buildings.Electrical"
    extends Modelica.Icons.BasesPackage;

    package WindTurbine
      model PartialWindTurbine
        "Partial model of a wind turbine with power output based on table as a function of wind speed"
        extends
          ProsNet.Electrical.BaseClasses.WindTurbine.PartialWindTurbineBase;
        replaceable package PhaseSystem =
            ProsNet.Electrical.PhaseSystems.PartialPhaseSystem constrainedby
          ProsNet.Electrical.PhaseSystems.PartialPhaseSystem
          "Phase system"
          annotation (choicesAllMatching=true);

        replaceable ProsNet.Electrical.Interfaces.Terminal terminal(redeclare
            package PhaseSystem = PhaseSystem) "Generalized terminal"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
      protected
        Modelica.Blocks.Tables.CombiTable1Ds per(
          final tableOnFile=tableOnFile,
          final table=cat(1, cat(1, [0, 0], table),
                          [vOut+10*Modelica.Constants.eps, 0;
                           vOut+20*Modelica.Constants.eps, 0]),
          final tableName=tableName,
          final fileName=fileName,
          final columns=2:2,
          final smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments)
          "Performance table that maps wind speed to electrical power output"
          annotation (Placement(transformation(extent={{-30,20},{-10,40}})));
        Modelica.Blocks.Math.Gain gain(final k=scale)
          "Gain, used to allow a user to easily scale the power"
          annotation (Placement(transformation(extent={{2,20},{22,40}})));
        DC.Sources.BaseClasses.WindCorrection                      cor(
          final h=h,
          final hRef=hRef,
          final n=nWin) "Correction for wind"
        annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={-50,30})));
      initial equation
        assert(abs(table[1,2]) < Modelica.Constants.eps,
        "First data point of performance table must be at cut-in wind speed,
   and be equal to 0 Watts.
   Received + "       + String(table[1,1]) + " m/s with " + String(table[1,2]) + " Watts");
      equation
        assert(gain.y>=0, "Wind power must be positive");
        connect(per.y[1],gain. u) annotation (Line(
            points={{-9,30},{0,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(vWin,cor. vRef) annotation (Line(
            points={{1.77636e-15,120},{1.77636e-15,90},{-70,90},{-70,30},{-62.2,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(cor.vLoc,per. u) annotation (Line(
            points={{-39,30},{-32,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(gain.y, P) annotation (Line(
            points={{23,30},{60,30},{60,60},{110,60}},
            color={0,0,127},
            smooth=Smooth.None));
        annotation (    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Rectangle(
                extent={{-100,102},{100,-98}},
                pattern=LinePattern.None,
                fillColor={202,230,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Rectangle(
                extent={{42,46},{46,-52}},
                fillColor={233,233,233},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Rectangle(
                extent={{-42,14},{-38,-84}},
                fillColor={233,233,233},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{-44,12},{-26,-40},{-38,16},{-44,12}},
                smooth=Smooth.None,
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{-38,12},{8,46},{-42,18},{-38,12}},
                smooth=Smooth.None,
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{-42,12},{-90,40},{-38,18},{-42,12}},
                smooth=Smooth.None,
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{40,44},{100,40},{42,50},{40,44}},
                smooth=Smooth.None,
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{-21,-17},{27,17},{-25,-11},{-21,-17}},
                smooth=Smooth.None,
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid,
                origin={29,69},
                rotation=90,
                lineColor={0,0,0}),
              Polygon(
                points={{24,-14},{-20,22},{26,-8},{24,-14}},
                smooth=Smooth.None,
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid,
                origin={32,20},
                rotation=90,
                lineColor={0,0,0}),
              Ellipse(
                extent={{-46,20},{-34,8}},
                lineColor={0,0,0},
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{38,52},{50,40}},
                lineColor={0,0,0},
                fillColor={222,222,222},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-42,134},{-20,108}},
                textColor={0,0,127},
                textString="v"),
              Text(
                extent={{100,100},{122,74}},
                textColor={0,0,127},
                textString="P")}),
          Documentation(info="<html>
<p>
Model of a wind turbine whose power is computed as a function of wind-speed as defined in a table.
</p>
<p>
Input to the model is the local wind speed.
The model requires the specification of a table that maps wind speed in meters per second to generated
power <i>P<sub>t</sub></i> in Watts.
The model has a parameter called <code>scale</code> with a default value of one
that can be used to scale the power generated by the wind turbine.
The generated electrical power is
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>t</sub> scale
</p>
<p>
For example, the following specification (with default <code>scale=1</code>) of a wind turbine
</p>
<pre>
  WindTurbine_Table tur(
    table=[3.5, 0;
           5.5,   100;
           12, 900;
           14, 1000;
           25, 1000]) \"Wind turbine\";
</pre>
<p>
yields the performance shown below. In this example, the cut-in wind speed is
<i>3.5</i> meters per second,
and the cut-out wind speed is <i>25</i> meters per second,
as entered by the first and last entry of the wind speed column.
Below and above these wind speeds, the generated power is zero.
</p>
<p align=\"center\">
<img alt=\"alt-image\" src=\"modelica://Buildings/Resources/Images/Electrical/DC/Sources/WindTurbine_Table.png\"/>
</p>
</html>",       revisions="<html>
<ul>
<li>
March 1, 2016, by Michael Wetter:<br/>
Removed test for equality of <code>Real</code> variables.
This is for
<a href=\"https://github.com/lbl-srg/modelica-Buildings/issues/493\">issue 493</a>.
</li>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
<li>
October 31, 2013, by Marco Bonvini:<br/>
Models included in the Buildings library. Modified the information section.
</li>
</ul>
</html>"));
      end PartialWindTurbine;

      partial model PartialWindTurbineBase
        "Base class for turbine model that contains basic parameters"
        final parameter Modelica.Units.SI.Velocity vIn=table[1, 1]
          "Cut-in steady wind speed";
        final parameter Modelica.Units.SI.Velocity vOut=table[size(table, 1), 1]
          "Cut-out steady wind speed";
        parameter Real scale(min=0)=1
          "Scaling factor, used to allow adjusting the power output without changing the table";

        parameter Real h "Height over ground"
          annotation (Dialog(group="Wind correction"));
        parameter Modelica.Units.SI.Height hRef=10
          "Reference height for wind measurement"
          annotation (Dialog(group="Wind correction"));
       parameter Real nWin(min=0) = 0.4
          "Height exponent for wind profile calculation"
         annotation (Dialog(group="Wind correction"));

        parameter Boolean tableOnFile=false
          "true, if table is defined on file or in function usertab";
        parameter Real table[:,2]=
                [3.5, 0;
                 5.5, 0.1;
                 12, 0.9;
                 14, 1;
                 25, 1]
          "Table of generated power (first column is wind speed, second column is power)";
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see documentation)";
        parameter String fileName="NoName" "File where matrix is stored";
        parameter Modelica.Units.SI.Voltage V_nominal(min=0, start=110)
          "Nominal voltage (V_nominal >= 0)"
          annotation (Evaluate=true, Dialog(group="Nominal conditions"));
        Modelica.Blocks.Interfaces.RealInput vWin(unit="m/s") "Steady wind speed"
           annotation (Placement(transformation(
              origin={0,120},
              extent={{-20,-20},{20,20}},
              rotation=270), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=270,
              origin={0,120})));
        Modelica.Blocks.Interfaces.RealOutput P(unit="W") "Generated power"
          annotation (Placement(transformation(extent={{100,50},{120,70}})));
        annotation (Documentation(info="<html>
<p>
This partial model contains the minimum set of parameters necessary to describe
a wind turbine.
The model defines also an output <code>P</code> for the power generated by the wind turbine.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 10, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialWindTurbineBase;
      annotation(preferredView="info",Documentation(info="<html>
  <p>
This package contains base classes that are used model the WindTurbine models.
</p>
</html>",
    revisions="<html>
<ul>
<li>
June 9, 2023, by Laura Maier:<br/>
Added documentation.
</li>
</ul>
</html>"));
    end WindTurbine;
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.Electrical\">Buildings.Electrical</a>.
</p>
</html>"));
  end BaseClasses;
annotation (Documentation(info="<html>
<p>
This package contains models for both DC and AC electrical systems.
</p>
</html>"), Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
          {100,100}}), graphics={Line(
        points={{32,80},{-36,12},{24,12},{-58,-74},{-58,-74}},
        color={0,0,0},
        smooth=Smooth.None), Polygon(
        points={{-58,-74},{-42,-24},{-8,-56},{-58,-74}},
        lineColor={0,0,0},
        smooth=Smooth.None,
        fillPattern=FillPattern.Solid,
        fillColor={0,0,0})}));
end Electrical;
