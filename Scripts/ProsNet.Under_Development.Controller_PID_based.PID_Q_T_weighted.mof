model PID_Q_T_weighted
  parameter Real Delta_Qdot_norm = 1 "Heat power value for normalizing the error (deviation) of the transferred heat.
      For alpha=0.5 a deviation of Delta_Qdot_norm in heat transfer is weigthed equal to a deviation of Delta_T_norm in temperature.";
  parameter Modelica.Units.SI.TemperatureDifference Delta_T_norm(min = 0.0) = 5 
    "Temperature difference for normalizing the error (deviation) of the temperature.
      For alpha=0.5 a deviation of Delta_T_norm in temperature is weighted equal to a deviation of Delta_Qdot_norm in heat transfer.";
  parameter Modelica.Units.SI.Temperature T_prim_hot_des(min = 277.0) = 338.15 
    "desired temperature supply primary side";
  parameter Modelica.Units.SI.Temperature T_sec_hot_des(min = 277.0) = 333.15 
    "desired temperature supply secondary side";
  parameter Modelica.Units.SI.TemperatureDifference DeltaT_prim_des(min = 1.0)
     = 15 "desired temperature difference primary side";
  parameter Modelica.Units.SI.TemperatureDifference DeltaT_sec_des(min = 1.0) = 15
     "desired temperature difference secondary side";
  parameter Real V_dot_sec_max(unit = "l/min", displayUnit = "l/min") = 10 
    "maximum secondary side volume flow in [l/min]";
  parameter Real k_prim_prod = 1 "Proportional gain for controller in [-]";
  parameter Real Ti_prim_prod = 0.5 "Integral time constant for controller in [s]";
  parameter Real Td_prim_prod = 0.1 "Derivative time constant for controller in [s]";
  parameter Real alpha_prim_prod(min = 0.0, max = 1.0) = 0.5 "weight for the relevance of the error of the transferred heat in comparison to the error of temperature objectives (sum is one)";
  parameter Real k_sec_prod = 1 "Proportional gain for controller in [-]";
  parameter Real Ti_sec_prod = 0.5 "Integral time constant for controller in [s]";
  parameter Real Td_sec_prod = 0.1 "Derivative time constant for controller in [s]";
  parameter Real alpha_sec_prod(min = 0.0, max = 1.0) = 0.5 "weight for the relevance of the error of the transferred heat in comparison to the error of temperature objectives (sum is one)";
  parameter Real k_prim_cons = 1 "Proportional gain for controller in [-]";
  parameter Real Ti_prim_cons = 0.5 "Integral time constant for controller in [s]";
  parameter Real Td_prim_cons = 0.1 "Derivative time constant for controller in [s]";
  parameter Real alpha_prim_cons(min = 0.0, max = 1.0) = 0.5 "weight for the relevance of the error of the transferred heat in comparison to the error of temperature objectives (sum is one)";
  parameter Real k_sec_cons = 1 "Proportional gain for controller in [-]";
  parameter Real Ti_sec_cons = 0.5 "Integral time constant for controller in [s]";
  parameter Real Td_sec_cons = 0.1 "Derivative time constant for controller in [s]";
  parameter Real alpha_sec_cons(min = 0.0, max = 1.0) = 0.5 "weight for the relevance of the error of the transferred heat in comparison to the error of temperature objectives (sum is one)";
  constant Modelica.Blocks.Types.SimpleController controllerType = 
    Modelica.Blocks.Types.SimpleController.P "Type of controller";
  parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.
    SteadyState "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real tol = 0.1 "tolerance [kW] for idle mode concerning heat transfer setpoint dotQ";
  input Modelica.Blocks.Interfaces.RealInput T_sec_hot(unit = "K", 
    displayUnit = "degC", min = 277.0) "current temperature hot level secondary side";
  input Modelica.Blocks.Interfaces.RealInput T_sec_cold(unit = "K", 
    displayUnit = "degC", min = 277.0) "current temperature cold  level secondary side";
  input Modelica.Blocks.Interfaces.RealInput T_prim_hot(unit = "K", 
    displayUnit = "degC", min = 277.0) "current temperature hot level primary side";
  input Modelica.Blocks.Interfaces.RealInput T_prim_cold(unit = "K", 
    displayUnit = "degC", min = 277.0) "current temperature cold level primary side";
  input Modelica.Blocks.Interfaces.RealInput Qdot_set(unit = "kW", 
    displayUnit = "kW") "setpoint heat transfer (positive production, negative consumption)";
  input Modelica.Blocks.Interfaces.RealInput V_dot_prim(unit = "l/min", 
    displayUnit = "l/min");
  input Modelica.Blocks.Interfaces.RealInput V_dot_sec(unit = "l/min", 
    displayUnit = "l/min");
  input Modelica.Blocks.Interfaces.RealInput Qdot_is(unit = "kW", displayUnit = 
    "kW") "currently transferred heat (positive production, negative consumption)";
  constant Modelica.Blocks.Types.SimpleController PID_prim_cons.controllerType
     = Modelica.Blocks.Types.SimpleController.P "Type of controller";
  parameter Real PID_prim_cons.k(unit = "1", min = 0.0) = k_prim_cons 
    "Gain of controller";
  parameter Modelica.Units.SI.Time PID_prim_cons.Ti(min = 1E-60) = Ti_prim_cons 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time PID_prim_cons.Td(min = 0.0) = Td_prim_cons 
    "Time constant of Derivative block";
  parameter Real PID_prim_cons.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real PID_prim_cons.yMin = 0 "Lower limit of output";
  parameter Real PID_prim_cons.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real PID_prim_cons.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real PID_prim_cons.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real PID_prim_cons.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  constant Boolean PID_prim_cons.withFeedForward = false "Use feed-forward input?";
  parameter Real PID_prim_cons.kFF = 1 "Gain of feed-forward input";
  parameter Modelica.Blocks.Types.Init PID_prim_cons.initType = initType 
    "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real PID_prim_cons.xi_start = 0 "Initial or guess value for integrator output (= integrator state)";
  parameter Real PID_prim_cons.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real PID_prim_cons.y_start = PID_prim_cons.yMax "Initial value of output";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_prim_cons.homotopyType = 
    Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Boolean PID_prim_cons.strict = false "= true, if strict limits with noEvent(..)";
  constant Modelica.Units.SI.Time PID_prim_cons.unitTime = 1;
  parameter Real PID_prim_cons.addP.k1 = PID_prim_cons.wp "Gain of input signal 1";
  parameter Real PID_prim_cons.addP.k2 = -1 "Gain of input signal 2";
  parameter Real PID_prim_cons.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real PID_prim_cons.gainPID.k(start = 1, unit = "1") = 
    PID_prim_cons.k "Gain value multiplied with input signal";
  parameter Real PID_prim_cons.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real PID_prim_cons.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real PID_prim_cons.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real PID_prim_cons.limiter.uMax(start = 1) = PID_prim_cons.yMax 
    "Upper limits of input signals";
  parameter Real PID_prim_cons.limiter.uMin = PID_prim_cons.yMin 
    "Lower limits of input signals";
  parameter Boolean PID_prim_cons.limiter.strict = PID_prim_cons.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_prim_cons.limiter.homotopyType
     = PID_prim_cons.homotopyType "Simplified model for homotopy-based initialization";
  constant Boolean PID_prim_cons.with_I = false;
  constant Boolean PID_prim_cons.with_D = false;
  parameter Real PID_prim_cons.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_prim_cons.Izero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_prim_cons.FFzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_prim_cons.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real PID_prim_cons.addFF.k2 = PID_prim_cons.kFF "Gain of input signal 2";
  constant Modelica.Blocks.Types.SimpleController PID_sec_cons.controllerType = 
    Modelica.Blocks.Types.SimpleController.P "Type of controller";
  parameter Real PID_sec_cons.k(unit = "1", min = 0.0) = k_sec_cons 
    "Gain of controller";
  parameter Modelica.Units.SI.Time PID_sec_cons.Ti(min = 1E-60) = Ti_sec_cons 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time PID_sec_cons.Td(min = 0.0) = Td_sec_cons 
    "Time constant of Derivative block";
  parameter Real PID_sec_cons.yMax(start = 1) = V_dot_sec_max "Upper limit of output";
  parameter Real PID_sec_cons.yMin = 1 "Lower limit of output";
  parameter Real PID_sec_cons.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real PID_sec_cons.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real PID_sec_cons.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real PID_sec_cons.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  constant Boolean PID_sec_cons.withFeedForward = false "Use feed-forward input?";
  parameter Real PID_sec_cons.kFF = 1 "Gain of feed-forward input";
  parameter Modelica.Blocks.Types.Init PID_sec_cons.initType = initType 
    "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real PID_sec_cons.xi_start = 0 "Initial or guess value for integrator output (= integrator state)";
  parameter Real PID_sec_cons.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real PID_sec_cons.y_start = PID_sec_cons.yMax "Initial value of output";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_sec_cons.homotopyType = 
    Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Boolean PID_sec_cons.strict = false "= true, if strict limits with noEvent(..)";
  constant Modelica.Units.SI.Time PID_sec_cons.unitTime = 1;
  parameter Real PID_sec_cons.addP.k1 = PID_sec_cons.wp "Gain of input signal 1";
  parameter Real PID_sec_cons.addP.k2 = -1 "Gain of input signal 2";
  parameter Real PID_sec_cons.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real PID_sec_cons.gainPID.k(start = 1, unit = "1") = PID_sec_cons.k 
    "Gain value multiplied with input signal";
  parameter Real PID_sec_cons.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real PID_sec_cons.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real PID_sec_cons.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real PID_sec_cons.limiter.uMax(start = 1) = PID_sec_cons.yMax 
    "Upper limits of input signals";
  parameter Real PID_sec_cons.limiter.uMin = PID_sec_cons.yMin "Lower limits of input signals";
  parameter Boolean PID_sec_cons.limiter.strict = PID_sec_cons.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_sec_cons.limiter.homotopyType
     = PID_sec_cons.homotopyType "Simplified model for homotopy-based initialization";
  constant Boolean PID_sec_cons.with_I = false;
  constant Boolean PID_sec_cons.with_D = false;
  parameter Real PID_sec_cons.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_sec_cons.Izero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_sec_cons.FFzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_sec_cons.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real PID_sec_cons.addFF.k2 = PID_sec_cons.kFF "Gain of input signal 2";
  constant Modelica.Blocks.Types.SimpleController PID_prim_prod.controllerType
     = Modelica.Blocks.Types.SimpleController.P "Type of controller";
  parameter Real PID_prim_prod.k(unit = "1", min = 0.0) = k_prim_prod 
    "Gain of controller";
  parameter Modelica.Units.SI.Time PID_prim_prod.Ti(min = 1E-60) = Ti_prim_prod 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time PID_prim_prod.Td(min = 0.0) = Td_prim_prod 
    "Time constant of Derivative block";
  parameter Real PID_prim_prod.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real PID_prim_prod.yMin = 0.1 "Lower limit of output";
  parameter Real PID_prim_prod.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real PID_prim_prod.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real PID_prim_prod.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real PID_prim_prod.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  constant Boolean PID_prim_prod.withFeedForward = false "Use feed-forward input?";
  parameter Real PID_prim_prod.kFF = 1 "Gain of feed-forward input";
  parameter Modelica.Blocks.Types.Init PID_prim_prod.initType = initType 
    "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real PID_prim_prod.xi_start = 0 "Initial or guess value for integrator output (= integrator state)";
  parameter Real PID_prim_prod.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real PID_prim_prod.y_start = PID_prim_prod.yMax "Initial value of output";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_prim_prod.homotopyType = 
    Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Boolean PID_prim_prod.strict = false "= true, if strict limits with noEvent(..)";
  constant Modelica.Units.SI.Time PID_prim_prod.unitTime = 1;
  parameter Real PID_prim_prod.addP.k1 = PID_prim_prod.wp "Gain of input signal 1";
  parameter Real PID_prim_prod.addP.k2 = -1 "Gain of input signal 2";
  parameter Real PID_prim_prod.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real PID_prim_prod.gainPID.k(start = 1, unit = "1") = 
    PID_prim_prod.k "Gain value multiplied with input signal";
  parameter Real PID_prim_prod.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real PID_prim_prod.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real PID_prim_prod.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real PID_prim_prod.limiter.uMax(start = 1) = PID_prim_prod.yMax 
    "Upper limits of input signals";
  parameter Real PID_prim_prod.limiter.uMin = PID_prim_prod.yMin 
    "Lower limits of input signals";
  parameter Boolean PID_prim_prod.limiter.strict = PID_prim_prod.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_prim_prod.limiter.homotopyType
     = PID_prim_prod.homotopyType "Simplified model for homotopy-based initialization";
  constant Boolean PID_prim_prod.with_I = false;
  constant Boolean PID_prim_prod.with_D = false;
  parameter Real PID_prim_prod.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_prim_prod.Izero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_prim_prod.FFzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_prim_prod.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real PID_prim_prod.addFF.k2 = PID_prim_prod.kFF "Gain of input signal 2";
  constant Modelica.Blocks.Types.SimpleController PID_sec_prod.controllerType = 
    Modelica.Blocks.Types.SimpleController.P "Type of controller";
  parameter Real PID_sec_prod.k(unit = "1", min = 0.0) = k_sec_prod 
    "Gain of controller";
  parameter Modelica.Units.SI.Time PID_sec_prod.Ti(min = 1E-60) = Ti_sec_prod 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time PID_sec_prod.Td(min = 0.0) = Td_sec_prod 
    "Time constant of Derivative block";
  parameter Real PID_sec_prod.yMax(start = 1) = V_dot_sec_max "Upper limit of output";
  parameter Real PID_sec_prod.yMin = 1 "Lower limit of output";
  parameter Real PID_sec_prod.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real PID_sec_prod.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real PID_sec_prod.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real PID_sec_prod.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  constant Boolean PID_sec_prod.withFeedForward = false "Use feed-forward input?";
  parameter Real PID_sec_prod.kFF = 1 "Gain of feed-forward input";
  parameter Modelica.Blocks.Types.Init PID_sec_prod.initType = initType 
    "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real PID_sec_prod.xi_start = 0 "Initial or guess value for integrator output (= integrator state)";
  parameter Real PID_sec_prod.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real PID_sec_prod.y_start = PID_sec_prod.yMax "Initial value of output";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_sec_prod.homotopyType = 
    Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Boolean PID_sec_prod.strict = false "= true, if strict limits with noEvent(..)";
  constant Modelica.Units.SI.Time PID_sec_prod.unitTime = 1;
  parameter Real PID_sec_prod.addP.k1 = PID_sec_prod.wp "Gain of input signal 1";
  parameter Real PID_sec_prod.addP.k2 = -1 "Gain of input signal 2";
  parameter Real PID_sec_prod.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real PID_sec_prod.gainPID.k(start = 1, unit = "1") = PID_sec_prod.k 
    "Gain value multiplied with input signal";
  parameter Real PID_sec_prod.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real PID_sec_prod.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real PID_sec_prod.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real PID_sec_prod.limiter.uMax(start = 1) = PID_sec_prod.yMax 
    "Upper limits of input signals";
  parameter Real PID_sec_prod.limiter.uMin = PID_sec_prod.yMin "Lower limits of input signals";
  parameter Boolean PID_sec_prod.limiter.strict = PID_sec_prod.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy PID_sec_prod.limiter.homotopyType
     = PID_sec_prod.homotopyType "Simplified model for homotopy-based initialization";
  constant Boolean PID_sec_prod.with_I = false;
  constant Boolean PID_sec_prod.with_D = false;
  parameter Real PID_sec_prod.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_sec_prod.Izero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_sec_prod.FFzero.k(start = 1) = 0 "Constant output value";
  parameter Real PID_sec_prod.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real PID_sec_prod.addFF.k2 = PID_sec_prod.kFF "Gain of input signal 2";
  input Modelica.Blocks.Interfaces.RealInput T_sec_sim(unit = "K", 
    displayUnit = "degC") "Temperature on the secondary side";

  Real beta_prim_prod(min = 0.0, max = 1.0) "weight for the relevance of the error of the temperature(difference)";
  Real beta_sec_prod(min = 0.0, max = 1.0) "weight for the relevance of the error of the temperature(difference)";
  Real beta_prim_cons(min = 0.0, max = 1.0) "weight for the relevance of the error of the temperature(difference)";
  Real beta_sec_cons(min = 0.0, max = 1.0) "weight for the relevance of the error of the temperature(difference)";
  Integer prosumer_mode "prosumer mode {-1;0;1}";
  Real T_prim_relev_des "desired value of relevant temperature (difference)
      for control of primary side";
  Real T_prim_relev_is "current value of relevant temperature (difference)
      for control of primary side";
  Real T_sec_relev_des "desired value of relevant temperature (difference)
      for control of secondary side";
  Real T_sec_relev_is "current value of relevant temperature (difference)
      for control of secondary side";
  Real PIDin_prim_cons_is_weighted "weighted input of is-values for PID_prim_cons";
  Real PIDin_prim_cons_des_weighted "weighted input of desired values for PID_prim_cons";
  Real PIDin_prim_prod_is_weighted "weighted input of is-values for PID_prim_prod";
  Real PIDin_prim_prod_des_weighted "weighted input of desired values for PID_prim_prod";
  Real PIDin_sec_cons_is_weighted "weighted input of is-values for PID_sec_cons";
  Real PIDin_sec_cons_des_weighted "weighted input of desired values for PID_sec_cons";
  Real PIDin_sec_prod_is_weighted "weighted input of is-values for PID_sec_prod";
  Real PIDin_sec_prod_des_weighted "weighted input of desired values for PID_sec_prod";
  Real error_prim_weighted "weighted overall error of primary side controller";
  Real error_sec_weighted "weighted overall error of primary side controller";
  Real error_T_prim_abs "temperature error of primary side controller";
  Real error_T_sec_abs "temperature error of primary side controller";
  Real error_Q_abs "temperature error of primary side controller";
  Real Delta_T_prim "weighted overall error of primary side controller";
  Real Delta_T_sec "weighted overall error of primary side controller";
  output Modelica.Blocks.Interfaces.RealOutput u_set "Normalized velocity of feed-in pump";
  output Modelica.Blocks.Interfaces.RealOutput kappa_set "Normalized flow coefficient for control valve";
  output Modelica.Blocks.Interfaces.IntegerOutput pi_set "Participation";
  output Modelica.Blocks.Interfaces.IntegerOutput mu_set "Operating mode";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.y "Connector of actuator output signal";
  Real PID_prim_cons.controlError = PID_prim_cons.u_s-PID_prim_cons.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.gainPID.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.limiter.y "Connector of Real output signal";
  Real PID_prim_cons.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.Izero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.FFzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_prim_cons.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_cons.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.y "Connector of actuator output signal";
  Real PID_sec_cons.controlError = PID_sec_cons.u_s-PID_sec_cons.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.gainPID.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.limiter.y "Connector of Real output signal";
  Real PID_sec_cons.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.Izero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.FFzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_sec_cons.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_cons.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.y "Connector of actuator output signal";
  Real PID_prim_prod.controlError = PID_prim_prod.u_s-PID_prim_prod.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.gainPID.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.limiter.y "Connector of Real output signal";
  Real PID_prim_prod.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.Izero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.FFzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_prim_prod.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_prim_prod.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.y "Connector of actuator output signal";
  Real PID_sec_prod.controlError = PID_sec_prod.u_s-PID_sec_prod.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.gainPID.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.limiter.y "Connector of Real output signal";
  Real PID_sec_prod.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.Izero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.FFzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput PID_sec_prod.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput PID_sec_prod.addFF.y "Connector of Real output signal";
  output Modelica.Blocks.Interfaces.RealOutput T_sec_set(unit = "K", 
    displayUnit = "degC") "Temperature on the secondary side";
  output Modelica.Blocks.Interfaces.RealOutput V_dot_sec_set(unit = "l/min", 
    displayUnit = "l/min") "volume flow rate setpoint on the secondary side";

// Equations and algorithms

  // Component PID_prim_cons.addP
  // class Modelica.Blocks.Math.Add
  equation
    PID_prim_cons.addP.y = PID_prim_cons.addP.k1*PID_prim_cons.addP.u1+
      PID_prim_cons.addP.k2*PID_prim_cons.addP.u2;

  // Component PID_prim_cons.P
  // class Modelica.Blocks.Math.Gain
  equation
    PID_prim_cons.P.y = PID_prim_cons.P.k*PID_prim_cons.P.u;

  // Component PID_prim_cons.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    PID_prim_cons.gainPID.y = PID_prim_cons.gainPID.k*PID_prim_cons.gainPID.u;

  // Component PID_prim_cons.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    PID_prim_cons.addPID.y = PID_prim_cons.addPID.k1*PID_prim_cons.addPID.u1+
      PID_prim_cons.addPID.k2*PID_prim_cons.addPID.u2+PID_prim_cons.addPID.k3*
      PID_prim_cons.addPID.u3;

  // Component PID_prim_cons.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(PID_prim_cons.limiter.uMax >= PID_prim_cons.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      PID_prim_cons.limiter.uMax, true, 0)+") < uMin (="+       String(
      PID_prim_cons.limiter.uMin, true, 0)+")");
    PID_prim_cons.limiter.simplifiedExpr = (if PID_prim_cons.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then PID_prim_cons.limiter.u
       else (if PID_prim_cons.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then PID_prim_cons.limiter.uMax else (if PID_prim_cons.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then PID_prim_cons.limiter.uMin
       else 0)));
    if (PID_prim_cons.limiter.strict) then 
      if (PID_prim_cons.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_prim_cons.limiter.y = smooth(0, noEvent((if PID_prim_cons.limiter.u
           > PID_prim_cons.limiter.uMax then PID_prim_cons.limiter.uMax else (
          if PID_prim_cons.limiter.u < PID_prim_cons.limiter.uMin then 
          PID_prim_cons.limiter.uMin else PID_prim_cons.limiter.u))));
      else
        PID_prim_cons.limiter.y = homotopy(smooth(0, noEvent((if 
          PID_prim_cons.limiter.u > PID_prim_cons.limiter.uMax then 
          PID_prim_cons.limiter.uMax else (if PID_prim_cons.limiter.u < 
          PID_prim_cons.limiter.uMin then PID_prim_cons.limiter.uMin else 
          PID_prim_cons.limiter.u)))), PID_prim_cons.limiter.simplifiedExpr);
      end if;
    else
      if (PID_prim_cons.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_prim_cons.limiter.y = smooth(0, (if PID_prim_cons.limiter.u > 
          PID_prim_cons.limiter.uMax then PID_prim_cons.limiter.uMax else (if 
          PID_prim_cons.limiter.u < PID_prim_cons.limiter.uMin then 
          PID_prim_cons.limiter.uMin else PID_prim_cons.limiter.u)));
      else
        PID_prim_cons.limiter.y = homotopy(smooth(0, (if PID_prim_cons.limiter.u
           > PID_prim_cons.limiter.uMax then PID_prim_cons.limiter.uMax else (
          if PID_prim_cons.limiter.u < PID_prim_cons.limiter.uMin then 
          PID_prim_cons.limiter.uMin else PID_prim_cons.limiter.u))), 
          PID_prim_cons.limiter.simplifiedExpr);
      end if;
    end if;

  // Component PID_prim_cons.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_prim_cons.Dzero.y = PID_prim_cons.Dzero.k;

  // Component PID_prim_cons.Izero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_prim_cons.Izero.y = PID_prim_cons.Izero.k;

  // Component PID_prim_cons.FFzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_prim_cons.FFzero.y = PID_prim_cons.FFzero.k;

  // Component PID_prim_cons.addFF
  // class Modelica.Blocks.Math.Add
  equation
    PID_prim_cons.addFF.y = PID_prim_cons.addFF.k1*PID_prim_cons.addFF.u1+
      PID_prim_cons.addFF.k2*PID_prim_cons.addFF.u2;

  // Component PID_prim_cons
  // class Modelica.Blocks.Continuous.LimPID
  equation
    if (PID_prim_cons.initType == Modelica.Blocks.Types.Init.InitialOutput and (
      PID_prim_cons.y_start < PID_prim_cons.yMin or PID_prim_cons.y_start > 
      PID_prim_cons.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        PID_prim_cons.y_start, true, 0)+") is outside of the limits of yMin (="+
               String(PID_prim_cons.yMin, true, 0)+") and yMax (="+       String
        (PID_prim_cons.yMax, true, 0)+")");
    end if;
    PID_prim_cons.addPID.u2 = PID_prim_cons.Dzero.y;
    PID_prim_cons.addFF.u2 = PID_prim_cons.FFzero.y;
    PID_prim_cons.addPID.u3 = PID_prim_cons.Izero.y;
    PID_prim_cons.addP.y = PID_prim_cons.P.u;
    PID_prim_cons.addPID.u1 = PID_prim_cons.P.y;
    PID_prim_cons.gainPID.y = PID_prim_cons.addFF.u1;
    PID_prim_cons.limiter.u = PID_prim_cons.addFF.y;
    PID_prim_cons.u_s = PID_prim_cons.addP.u1;
    PID_prim_cons.u_m = PID_prim_cons.addP.u2;
    PID_prim_cons.gainPID.u = PID_prim_cons.addPID.y;
    PID_prim_cons.y = PID_prim_cons.limiter.y;

  // Component PID_sec_cons.addP
  // class Modelica.Blocks.Math.Add
  equation
    PID_sec_cons.addP.y = PID_sec_cons.addP.k1*PID_sec_cons.addP.u1+
      PID_sec_cons.addP.k2*PID_sec_cons.addP.u2;

  // Component PID_sec_cons.P
  // class Modelica.Blocks.Math.Gain
  equation
    PID_sec_cons.P.y = PID_sec_cons.P.k*PID_sec_cons.P.u;

  // Component PID_sec_cons.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    PID_sec_cons.gainPID.y = PID_sec_cons.gainPID.k*PID_sec_cons.gainPID.u;

  // Component PID_sec_cons.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    PID_sec_cons.addPID.y = PID_sec_cons.addPID.k1*PID_sec_cons.addPID.u1+
      PID_sec_cons.addPID.k2*PID_sec_cons.addPID.u2+PID_sec_cons.addPID.k3*
      PID_sec_cons.addPID.u3;

  // Component PID_sec_cons.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(PID_sec_cons.limiter.uMax >= PID_sec_cons.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      PID_sec_cons.limiter.uMax, true, 0)+") < uMin (="+       String(
      PID_sec_cons.limiter.uMin, true, 0)+")");
    PID_sec_cons.limiter.simplifiedExpr = (if PID_sec_cons.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then PID_sec_cons.limiter.u
       else (if PID_sec_cons.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then PID_sec_cons.limiter.uMax else (if PID_sec_cons.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then PID_sec_cons.limiter.uMin
       else 0)));
    if (PID_sec_cons.limiter.strict) then 
      if (PID_sec_cons.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_sec_cons.limiter.y = smooth(0, noEvent((if PID_sec_cons.limiter.u > 
          PID_sec_cons.limiter.uMax then PID_sec_cons.limiter.uMax else (if 
          PID_sec_cons.limiter.u < PID_sec_cons.limiter.uMin then 
          PID_sec_cons.limiter.uMin else PID_sec_cons.limiter.u))));
      else
        PID_sec_cons.limiter.y = homotopy(smooth(0, noEvent((if PID_sec_cons.limiter.u
           > PID_sec_cons.limiter.uMax then PID_sec_cons.limiter.uMax else (if 
          PID_sec_cons.limiter.u < PID_sec_cons.limiter.uMin then 
          PID_sec_cons.limiter.uMin else PID_sec_cons.limiter.u)))), 
          PID_sec_cons.limiter.simplifiedExpr);
      end if;
    else
      if (PID_sec_cons.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_sec_cons.limiter.y = smooth(0, (if PID_sec_cons.limiter.u > 
          PID_sec_cons.limiter.uMax then PID_sec_cons.limiter.uMax else (if 
          PID_sec_cons.limiter.u < PID_sec_cons.limiter.uMin then 
          PID_sec_cons.limiter.uMin else PID_sec_cons.limiter.u)));
      else
        PID_sec_cons.limiter.y = homotopy(smooth(0, (if PID_sec_cons.limiter.u
           > PID_sec_cons.limiter.uMax then PID_sec_cons.limiter.uMax else (if 
          PID_sec_cons.limiter.u < PID_sec_cons.limiter.uMin then 
          PID_sec_cons.limiter.uMin else PID_sec_cons.limiter.u))), 
          PID_sec_cons.limiter.simplifiedExpr);
      end if;
    end if;

  // Component PID_sec_cons.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_sec_cons.Dzero.y = PID_sec_cons.Dzero.k;

  // Component PID_sec_cons.Izero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_sec_cons.Izero.y = PID_sec_cons.Izero.k;

  // Component PID_sec_cons.FFzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_sec_cons.FFzero.y = PID_sec_cons.FFzero.k;

  // Component PID_sec_cons.addFF
  // class Modelica.Blocks.Math.Add
  equation
    PID_sec_cons.addFF.y = PID_sec_cons.addFF.k1*PID_sec_cons.addFF.u1+
      PID_sec_cons.addFF.k2*PID_sec_cons.addFF.u2;

  // Component PID_sec_cons
  // class Modelica.Blocks.Continuous.LimPID
  equation
    if (PID_sec_cons.initType == Modelica.Blocks.Types.Init.InitialOutput and (
      PID_sec_cons.y_start < PID_sec_cons.yMin or PID_sec_cons.y_start > 
      PID_sec_cons.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        PID_sec_cons.y_start, true, 0)+") is outside of the limits of yMin (="+
               String(PID_sec_cons.yMin, true, 0)+") and yMax (="+       String(
        PID_sec_cons.yMax, true, 0)+")");
    end if;
    PID_sec_cons.addPID.u2 = PID_sec_cons.Dzero.y;
    PID_sec_cons.addFF.u2 = PID_sec_cons.FFzero.y;
    PID_sec_cons.addPID.u3 = PID_sec_cons.Izero.y;
    PID_sec_cons.addP.y = PID_sec_cons.P.u;
    PID_sec_cons.addPID.u1 = PID_sec_cons.P.y;
    PID_sec_cons.gainPID.y = PID_sec_cons.addFF.u1;
    PID_sec_cons.limiter.u = PID_sec_cons.addFF.y;
    PID_sec_cons.u_s = PID_sec_cons.addP.u1;
    PID_sec_cons.u_m = PID_sec_cons.addP.u2;
    PID_sec_cons.gainPID.u = PID_sec_cons.addPID.y;
    PID_sec_cons.y = PID_sec_cons.limiter.y;

  // Component PID_prim_prod.addP
  // class Modelica.Blocks.Math.Add
  equation
    PID_prim_prod.addP.y = PID_prim_prod.addP.k1*PID_prim_prod.addP.u1+
      PID_prim_prod.addP.k2*PID_prim_prod.addP.u2;

  // Component PID_prim_prod.P
  // class Modelica.Blocks.Math.Gain
  equation
    PID_prim_prod.P.y = PID_prim_prod.P.k*PID_prim_prod.P.u;

  // Component PID_prim_prod.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    PID_prim_prod.gainPID.y = PID_prim_prod.gainPID.k*PID_prim_prod.gainPID.u;

  // Component PID_prim_prod.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    PID_prim_prod.addPID.y = PID_prim_prod.addPID.k1*PID_prim_prod.addPID.u1+
      PID_prim_prod.addPID.k2*PID_prim_prod.addPID.u2+PID_prim_prod.addPID.k3*
      PID_prim_prod.addPID.u3;

  // Component PID_prim_prod.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(PID_prim_prod.limiter.uMax >= PID_prim_prod.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      PID_prim_prod.limiter.uMax, true, 0)+") < uMin (="+       String(
      PID_prim_prod.limiter.uMin, true, 0)+")");
    PID_prim_prod.limiter.simplifiedExpr = (if PID_prim_prod.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then PID_prim_prod.limiter.u
       else (if PID_prim_prod.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then PID_prim_prod.limiter.uMax else (if PID_prim_prod.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then PID_prim_prod.limiter.uMin
       else 0)));
    if (PID_prim_prod.limiter.strict) then 
      if (PID_prim_prod.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_prim_prod.limiter.y = smooth(0, noEvent((if PID_prim_prod.limiter.u
           > PID_prim_prod.limiter.uMax then PID_prim_prod.limiter.uMax else (
          if PID_prim_prod.limiter.u < PID_prim_prod.limiter.uMin then 
          PID_prim_prod.limiter.uMin else PID_prim_prod.limiter.u))));
      else
        PID_prim_prod.limiter.y = homotopy(smooth(0, noEvent((if 
          PID_prim_prod.limiter.u > PID_prim_prod.limiter.uMax then 
          PID_prim_prod.limiter.uMax else (if PID_prim_prod.limiter.u < 
          PID_prim_prod.limiter.uMin then PID_prim_prod.limiter.uMin else 
          PID_prim_prod.limiter.u)))), PID_prim_prod.limiter.simplifiedExpr);
      end if;
    else
      if (PID_prim_prod.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_prim_prod.limiter.y = smooth(0, (if PID_prim_prod.limiter.u > 
          PID_prim_prod.limiter.uMax then PID_prim_prod.limiter.uMax else (if 
          PID_prim_prod.limiter.u < PID_prim_prod.limiter.uMin then 
          PID_prim_prod.limiter.uMin else PID_prim_prod.limiter.u)));
      else
        PID_prim_prod.limiter.y = homotopy(smooth(0, (if PID_prim_prod.limiter.u
           > PID_prim_prod.limiter.uMax then PID_prim_prod.limiter.uMax else (
          if PID_prim_prod.limiter.u < PID_prim_prod.limiter.uMin then 
          PID_prim_prod.limiter.uMin else PID_prim_prod.limiter.u))), 
          PID_prim_prod.limiter.simplifiedExpr);
      end if;
    end if;

  // Component PID_prim_prod.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_prim_prod.Dzero.y = PID_prim_prod.Dzero.k;

  // Component PID_prim_prod.Izero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_prim_prod.Izero.y = PID_prim_prod.Izero.k;

  // Component PID_prim_prod.FFzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_prim_prod.FFzero.y = PID_prim_prod.FFzero.k;

  // Component PID_prim_prod.addFF
  // class Modelica.Blocks.Math.Add
  equation
    PID_prim_prod.addFF.y = PID_prim_prod.addFF.k1*PID_prim_prod.addFF.u1+
      PID_prim_prod.addFF.k2*PID_prim_prod.addFF.u2;

  // Component PID_prim_prod
  // class Modelica.Blocks.Continuous.LimPID
  equation
    if (PID_prim_prod.initType == Modelica.Blocks.Types.Init.InitialOutput and (
      PID_prim_prod.y_start < PID_prim_prod.yMin or PID_prim_prod.y_start > 
      PID_prim_prod.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        PID_prim_prod.y_start, true, 0)+") is outside of the limits of yMin (="+
               String(PID_prim_prod.yMin, true, 0)+") and yMax (="+       String
        (PID_prim_prod.yMax, true, 0)+")");
    end if;
    PID_prim_prod.addPID.u2 = PID_prim_prod.Dzero.y;
    PID_prim_prod.addFF.u2 = PID_prim_prod.FFzero.y;
    PID_prim_prod.addPID.u3 = PID_prim_prod.Izero.y;
    PID_prim_prod.addP.y = PID_prim_prod.P.u;
    PID_prim_prod.addPID.u1 = PID_prim_prod.P.y;
    PID_prim_prod.gainPID.y = PID_prim_prod.addFF.u1;
    PID_prim_prod.limiter.u = PID_prim_prod.addFF.y;
    PID_prim_prod.u_s = PID_prim_prod.addP.u1;
    PID_prim_prod.u_m = PID_prim_prod.addP.u2;
    PID_prim_prod.gainPID.u = PID_prim_prod.addPID.y;
    PID_prim_prod.y = PID_prim_prod.limiter.y;

  // Component PID_sec_prod.addP
  // class Modelica.Blocks.Math.Add
  equation
    PID_sec_prod.addP.y = PID_sec_prod.addP.k1*PID_sec_prod.addP.u1+
      PID_sec_prod.addP.k2*PID_sec_prod.addP.u2;

  // Component PID_sec_prod.P
  // class Modelica.Blocks.Math.Gain
  equation
    PID_sec_prod.P.y = PID_sec_prod.P.k*PID_sec_prod.P.u;

  // Component PID_sec_prod.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    PID_sec_prod.gainPID.y = PID_sec_prod.gainPID.k*PID_sec_prod.gainPID.u;

  // Component PID_sec_prod.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    PID_sec_prod.addPID.y = PID_sec_prod.addPID.k1*PID_sec_prod.addPID.u1+
      PID_sec_prod.addPID.k2*PID_sec_prod.addPID.u2+PID_sec_prod.addPID.k3*
      PID_sec_prod.addPID.u3;

  // Component PID_sec_prod.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(PID_sec_prod.limiter.uMax >= PID_sec_prod.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      PID_sec_prod.limiter.uMax, true, 0)+") < uMin (="+       String(
      PID_sec_prod.limiter.uMin, true, 0)+")");
    PID_sec_prod.limiter.simplifiedExpr = (if PID_sec_prod.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then PID_sec_prod.limiter.u
       else (if PID_sec_prod.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then PID_sec_prod.limiter.uMax else (if PID_sec_prod.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then PID_sec_prod.limiter.uMin
       else 0)));
    if (PID_sec_prod.limiter.strict) then 
      if (PID_sec_prod.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_sec_prod.limiter.y = smooth(0, noEvent((if PID_sec_prod.limiter.u > 
          PID_sec_prod.limiter.uMax then PID_sec_prod.limiter.uMax else (if 
          PID_sec_prod.limiter.u < PID_sec_prod.limiter.uMin then 
          PID_sec_prod.limiter.uMin else PID_sec_prod.limiter.u))));
      else
        PID_sec_prod.limiter.y = homotopy(smooth(0, noEvent((if PID_sec_prod.limiter.u
           > PID_sec_prod.limiter.uMax then PID_sec_prod.limiter.uMax else (if 
          PID_sec_prod.limiter.u < PID_sec_prod.limiter.uMin then 
          PID_sec_prod.limiter.uMin else PID_sec_prod.limiter.u)))), 
          PID_sec_prod.limiter.simplifiedExpr);
      end if;
    else
      if (PID_sec_prod.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        PID_sec_prod.limiter.y = smooth(0, (if PID_sec_prod.limiter.u > 
          PID_sec_prod.limiter.uMax then PID_sec_prod.limiter.uMax else (if 
          PID_sec_prod.limiter.u < PID_sec_prod.limiter.uMin then 
          PID_sec_prod.limiter.uMin else PID_sec_prod.limiter.u)));
      else
        PID_sec_prod.limiter.y = homotopy(smooth(0, (if PID_sec_prod.limiter.u
           > PID_sec_prod.limiter.uMax then PID_sec_prod.limiter.uMax else (if 
          PID_sec_prod.limiter.u < PID_sec_prod.limiter.uMin then 
          PID_sec_prod.limiter.uMin else PID_sec_prod.limiter.u))), 
          PID_sec_prod.limiter.simplifiedExpr);
      end if;
    end if;

  // Component PID_sec_prod.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_sec_prod.Dzero.y = PID_sec_prod.Dzero.k;

  // Component PID_sec_prod.Izero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_sec_prod.Izero.y = PID_sec_prod.Izero.k;

  // Component PID_sec_prod.FFzero
  // class Modelica.Blocks.Sources.Constant
  equation
    PID_sec_prod.FFzero.y = PID_sec_prod.FFzero.k;

  // Component PID_sec_prod.addFF
  // class Modelica.Blocks.Math.Add
  equation
    PID_sec_prod.addFF.y = PID_sec_prod.addFF.k1*PID_sec_prod.addFF.u1+
      PID_sec_prod.addFF.k2*PID_sec_prod.addFF.u2;

  // Component PID_sec_prod
  // class Modelica.Blocks.Continuous.LimPID
  equation
    if (PID_sec_prod.initType == Modelica.Blocks.Types.Init.InitialOutput and (
      PID_sec_prod.y_start < PID_sec_prod.yMin or PID_sec_prod.y_start > 
      PID_sec_prod.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        PID_sec_prod.y_start, true, 0)+") is outside of the limits of yMin (="+
               String(PID_sec_prod.yMin, true, 0)+") and yMax (="+       String(
        PID_sec_prod.yMax, true, 0)+")");
    end if;
    PID_sec_prod.addPID.u2 = PID_sec_prod.Dzero.y;
    PID_sec_prod.addFF.u2 = PID_sec_prod.FFzero.y;
    PID_sec_prod.addPID.u3 = PID_sec_prod.Izero.y;
    PID_sec_prod.addP.y = PID_sec_prod.P.u;
    PID_sec_prod.addPID.u1 = PID_sec_prod.P.y;
    PID_sec_prod.gainPID.y = PID_sec_prod.addFF.u1;
    PID_sec_prod.limiter.u = PID_sec_prod.addFF.y;
    PID_sec_prod.u_s = PID_sec_prod.addP.u1;
    PID_sec_prod.u_m = PID_sec_prod.addP.u2;
    PID_sec_prod.gainPID.u = PID_sec_prod.addPID.y;
    PID_sec_prod.y = PID_sec_prod.limiter.y;

  // This model
  // class ProsNet.Under_Development.Controller_PID_based.PID_Q_T_weighted
  equation
    Delta_T_prim = T_prim_hot-T_prim_cold;
    Delta_T_sec = T_sec_hot-T_sec_cold;
    beta_prim_prod = 1-alpha_prim_prod;
    beta_sec_prod = 1-alpha_sec_prod;
    beta_prim_cons = 1-alpha_prim_cons;
    beta_sec_cons = 1-alpha_sec_cons;
    if (Qdot_set <= 0-tol) then 
      prosumer_mode = -1;
      pi_set = 1;
      mu_set = -1;
      T_prim_relev_des = DeltaT_prim_des;
      T_prim_relev_is = T_prim_hot-T_prim_cold;
      T_sec_relev_des = T_sec_hot_des;
      T_sec_relev_is = T_sec_hot;
      PIDin_prim_cons_is_weighted = alpha_prim_cons*(-1)*Qdot_is/Delta_Qdot_norm
        +beta_prim_cons*(-1)*T_prim_relev_is/Delta_T_norm;
      PIDin_prim_cons_des_weighted = alpha_prim_cons*(-1)*Qdot_set/
        Delta_Qdot_norm+beta_prim_cons*(-1)*T_prim_relev_des/Delta_T_norm;
      PIDin_prim_prod_is_weighted = 0;
      PIDin_prim_prod_des_weighted = 0;
      PIDin_sec_cons_is_weighted = alpha_sec_cons*(-1)*Qdot_is/Delta_Qdot_norm+
        beta_sec_cons*(-1)*T_sec_relev_is/Delta_T_norm;
      PIDin_sec_cons_des_weighted = alpha_sec_cons*(-1)*Qdot_set/Delta_Qdot_norm
        +beta_sec_cons*(-1)*T_sec_relev_des/Delta_T_norm;
      PIDin_sec_prod_is_weighted = 0;
      PIDin_sec_prod_des_weighted = 0;
      error_prim_weighted = PIDin_prim_cons_des_weighted-PIDin_prim_cons_is_weighted;
      error_sec_weighted = PIDin_sec_cons_des_weighted-PIDin_sec_cons_is_weighted;
      error_T_prim_abs = DeltaT_prim_des-Delta_T_prim;
      error_T_sec_abs = T_sec_hot_des-T_sec_hot;
    elseif (Qdot_set >= 0+tol) then 
      prosumer_mode = 1;
      pi_set = 1;
      mu_set = 1;
      T_prim_relev_des = T_prim_hot_des;
      T_prim_relev_is = T_prim_hot;
      T_sec_relev_des = DeltaT_sec_des;
      T_sec_relev_is = T_sec_hot-T_sec_cold;
      PIDin_prim_cons_is_weighted = 0;
      PIDin_prim_cons_des_weighted = 0;
      PIDin_prim_prod_is_weighted = alpha_prim_prod*Qdot_is/Delta_Qdot_norm+
        beta_prim_prod*(-1)*T_prim_relev_is/Delta_T_norm;
      PIDin_prim_prod_des_weighted = alpha_prim_prod*Qdot_set/Delta_Qdot_norm+
        beta_prim_prod*(-1)*T_prim_relev_des/Delta_T_norm;
      PIDin_sec_cons_is_weighted = 0;
      PIDin_sec_cons_des_weighted = 0;
      PIDin_sec_prod_is_weighted = alpha_sec_prod*Qdot_is/Delta_Qdot_norm+
        beta_sec_prod*(-1)*T_sec_relev_is/Delta_T_norm;
      PIDin_sec_prod_des_weighted = alpha_sec_prod*Qdot_set/Delta_Qdot_norm+
        beta_sec_prod*(-1)*T_sec_relev_des/Delta_T_norm;
      error_prim_weighted = PIDin_prim_prod_des_weighted-PIDin_prim_prod_is_weighted;
      error_sec_weighted = PIDin_sec_prod_des_weighted-PIDin_sec_prod_is_weighted;
      error_T_prim_abs = T_prim_hot_des-T_prim_hot;
      error_T_sec_abs = DeltaT_sec_des-Delta_T_sec;
    else
      prosumer_mode = 0;
      pi_set = 0;
      mu_set = -1;
      T_prim_relev_des = 0;
      T_prim_relev_is = 0;
      T_sec_relev_des = 0;
      T_sec_relev_is = 0;
      PIDin_prim_cons_is_weighted = 0;
      PIDin_prim_cons_des_weighted = 0;
      PIDin_prim_prod_is_weighted = 0;
      PIDin_prim_prod_des_weighted = 0;
      PIDin_sec_cons_is_weighted = 0;
      PIDin_sec_cons_des_weighted = 0;
      PIDin_sec_prod_is_weighted = 0;
      PIDin_sec_prod_des_weighted = 0;
      error_prim_weighted = 0;
      error_sec_weighted = 0;
      error_T_prim_abs = 0;
      error_T_sec_abs = 0;
    end if;
    PID_prim_cons.u_s = PIDin_prim_cons_des_weighted;
    PID_prim_cons.u_m = PIDin_prim_cons_is_weighted;
    PID_prim_prod.u_s = PIDin_prim_prod_des_weighted;
    PID_prim_prod.u_m = PIDin_prim_prod_is_weighted;
    PID_sec_cons.u_s = PIDin_sec_cons_des_weighted;
    PID_sec_cons.u_m = PIDin_sec_cons_is_weighted;
    PID_sec_prod.u_s = PIDin_sec_prod_des_weighted;
    PID_sec_prod.u_m = PIDin_sec_prod_is_weighted;
    T_sec_set = T_sec_sim;
    if (prosumer_mode == -1) then 
      u_set = 0;
      kappa_set = PID_prim_cons.y;
      V_dot_sec_set = PID_sec_cons.y;
    elseif (prosumer_mode == 1) then 
      u_set = PID_prim_prod.y;
      kappa_set = 0;
      V_dot_sec_set = PID_sec_prod.y;
    else
      V_dot_sec_set = 0;
      u_set = 0;
      kappa_set = 0;
    end if;
    error_Q_abs = Qdot_set-Qdot_is;
            
// Initial equations and algorithms

  // Component PID_prim_cons
  // class Modelica.Blocks.Continuous.LimPID
  initial equation
    if (PID_prim_cons.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      PID_prim_cons.gainPID.y = PID_prim_cons.y_start;
    end if;

  // Component PID_sec_cons
  // class Modelica.Blocks.Continuous.LimPID
  initial equation
    if (PID_sec_cons.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      PID_sec_cons.gainPID.y = PID_sec_cons.y_start;
    end if;

  // Component PID_prim_prod
  // class Modelica.Blocks.Continuous.LimPID
  initial equation
    if (PID_prim_prod.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      PID_prim_prod.gainPID.y = PID_prim_prod.y_start;
    end if;

  // Component PID_sec_prod
  // class Modelica.Blocks.Continuous.LimPID
  initial equation
    if (PID_sec_prod.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      PID_sec_prod.gainPID.y = PID_sec_prod.y_start;
    end if;

end PID_Q_T_weighted;
