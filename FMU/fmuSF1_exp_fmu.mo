within ProsNet.FMU;
model fmuSF1_exp_fmu "fmuSF1_"
// Model automatically generated by Dymola from FMI model description
extends fmuIcon;
public
  parameter Real _CBIn_TSet_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput CBIn_TSet(unit = "K", displayUnit = "°C", quantity = "Temp", start = _CBIn_TSet_start) "Condensing boiler input - set temperature (power is constant)"
  annotation (Placement(transformation(extent={{-114,62},{-94,82}})));
  parameter Real _CHPIn_P_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput CHPIn_P(unit = "Nm/s", displayUnit = "kW", quantity = "Power", start = _CHPIn_P_start) "CHP input - electric power"
  annotation (Placement(transformation(extent={{-114,33},{-94,53}})));
  parameter Real _TDH_HEXout_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput TDH_HEXout(unit = "K", displayUnit = "°C", quantity = "Temp", start = _TDH_HEXout_start) "Outlet temperature of district heating heat exchanger"
  annotation (Placement(transformation(extent={{-114,5},{-94,25}})));
  parameter Real _qvSTpump_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput qvSTpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvSTpump_start) "Reference volume flow of solar thermal pump"
  annotation (Placement(transformation(extent={{-114,-24},{-94,-4}})));
  parameter Real _qvDHpump_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput qvDHpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvDHpump_start) "Reference volume flow of district heating pump - positive: feed in - negative: extraction"
  annotation (Placement(transformation(extent={{-114,-52},{-94,-32}})));
  parameter Real _qvDHWpump_start = 0.
  annotation (Dialog( group="Start values for inputs "));
  Modelica.Blocks.Interfaces.RealInput qvDHWpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvDHWpump_start) "Reference volume flow of domestic hot water pump to charge the DHW storage"
  annotation (Placement(transformation(extent={{-114,-81},{-94,-61}})));
  Modelica.Blocks.Interfaces.RealOutput qv_HEX(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow") "Volume flow to district heating heat exchanger"
  annotation (Placement(transformation(extent={{100,14},{140,54}})));
  Modelica.Blocks.Interfaces.RealOutput TDH_HEXin(unit = "K", displayUnit = "°C", quantity = "Temp") "Inlet temperature of district heating heat exchanger"
  annotation (Placement(transformation(extent={{100,-53},{140,-13}})));
public
  parameter String fmi_instanceName="fmuSF1_exp_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  constant Integer fmi_NumberOfContinuousStates = 589;
  constant Integer fmi_NumberOfEventIndicators = 90;
protected
  Real fmi_x[fmi_NumberOfContinuousStates](each fixed=false) "States";
  Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
  Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
  fmi_Functions.fmiModel fmi;
  parameter Real fmi_Initialized(fixed=false);
  Real myTime;
  Boolean fmi_StepEvent;
  Boolean fmi_NewStates;
  Boolean fmi_NewStates2(start=false,fixed=true);
  Real fmi_TNext(start=fmi_TNext_Start,fixed=true);
  parameter Real fmi_TNext_Start(fixed=false);
package fmi_Functions
  class fmiModel
  extends ExternalObject;
    function constructor "Initialize FMI model"
      extends Modelica.Icons.Function;
      input String instanceName;
      input Boolean loggingOn;
      output fmiModel fmi;
      external"C" fmi = fmuSF1_exp47521634678240760863_fmiInstantiateModel2(instanceName, loggingOn)
      annotation(Header="
#ifndef fmuSF1_exp47521634678240760863_Instantiate_C
#define fmuSF1_exp47521634678240760863_Instantiate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
#ifndef fmuSF1_exp47521634678240760863_MYSTRCMP_C
#define fmuSF1_exp47521634678240760863_MYSTRCMP_C 1
int fmuSF1_exp47521634678240760863mystrcmp(const void *_a, const void *_b) {
  char *a = _a;
  char *const *b = _b;
  return strcmp(a, *b);
}
#endif
void fmuSF1_exp47521634678240760863Logger(fmiComponent c, fmiString instanceName, fmiStatus status,
	 fmiString category, fmiString message, ...) {
  char msg[4096];
  char buf[4096];
  int len;
  va_list ap;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len <4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmiFatal:
      ModelicaMessage(\"[fmiFatal]: \");
      break;
    case fmiError:
      ModelicaMessage(\"[fmiError]: \");
      break;
    case fmiDiscard:
      ModelicaMessage(\"[fmiDiscard]: \");
      break;
    case fmiWarning:
      ModelicaMessage(\"[fmiWarning]: \");
      break;
    case fmiOK:
      ModelicaMessage(\"[fmiOK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * fmuSF1_exp47521634678240760863_fmiInstantiateModel2(const char*instanceName, fmiBoolean loggingOn) {
  static fmiMECallbackFunctions funcs = {&fmuSF1_exp47521634678240760863Logger, &calloc, &free};
  struct dy_Extended* res;

  res = calloc(1, sizeof(struct dy_Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"fmuSF1_exp.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (fmuSF1_exp.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiateModel=(fmiInstantiateModelFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiInstantiateModel\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInstantiateModel!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInstantiateModel\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiFreeModelInstance=(fmiFreeModelInstanceFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiFreeModelInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmiFreeModelInstance!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiFreeModelInstance\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmiSetTimeFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmiSetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmiGetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmiCompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiCompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmiCompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEventUpdate=(fmiEventUpdateFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiEventUpdate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiEventUpdate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEventUpdate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiInitialize=(fmiInitializeFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiInitialize\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInitialize!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInitialize\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmiGetDerivativesFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmiGetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmiTerminateFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiTerminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiTerminate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiTerminate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmiSetRealFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmiGetRealFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmiSetIntegerFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmiGetIntegerFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmiSetBooleanFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmiGetBooleanFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmiSetStringFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmiGetStringFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetString!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmiSetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetDebugLogging!\");
      return 0;
    }
    res->m=res->dyFmiInstantiateModel(instanceName, \"{4AB7521C-E6A3-467E-8240-76DC08CBD6E3}\", funcs, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->dyFirstTimeEvent=1e37;res->currentMode=dyInstantiationMode;}
  }
  return res;
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                          __Dymola_CriticalRegion="fmuSF1_exp");
    end constructor;

    function destructor "Release storage of FMI model"
      extends Modelica.Icons.Function;
      input fmiModel fmi;
      external"C"
                 fmuSF1_exp47521634678240760863_fmiFreeModelInstance2(fmi);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_Free_C
#define fmuSF1_exp47521634678240760863_Free_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiFreeModelInstance2(void*m) {
  struct dy_Extended*a=m;
  if (a) {
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeModelInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                          __Dymola_CriticalRegion="fmuSF1_exp");
    end destructor;
  end fmiModel;

    function fmiSetTime
      input fmiModel fmi;
      input Real ti;
      external"C" fmuSF1_exp47521634678240760863_fmiSetTime2(fmi, ti);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetTime_C
#define fmuSF1_exp47521634678240760863_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetTime2(void*m, double ti) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyInstantiationMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti>a->dyTime || (a->currentMode==dyEventMode && ti==a->dyTime && !isModelicaEvent())){
      a->currentMode=dyContinuousTimeMode;
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti <= a->dyTime && a->currentMode == dyContinuousTimeMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK ) ModelicaError(\"SetTime failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiSetTime;

    function fmiSetContinuousStates
      input fmiModel fmi;
      input Real x[:];
      external"C" fmuSF1_exp47521634678240760863_fmiSetContinuousStates2(
        fmi,
        x,
        size(x, 1));
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetContinuousStates_C
#define fmuSF1_exp47521634678240760863_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetContinuousStates failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiSetContinuousStates;

    function fmiGetContinuousStates
      input fmiModel fmi;
      input Integer nx;
      output Real x[nx];
      external"C" fmuSF1_exp47521634678240760863_fmiGetContinuousStates2(
        fmi,
        x,
        nx);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetContinuousStates_C
#define fmuSF1_exp47521634678240760863_GetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetContinuousStates failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetContinuousStates;

    function fmiCompletedStep
      input fmiModel fmi;
      output Real crossing;
      external"C" crossing = fmuSF1_exp47521634678240760863_fmiCompletedStep2(fmi);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_CompletedStep_C
#define fmuSF1_exp47521634678240760863_CompletedStep_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double fmuSF1_exp47521634678240760863_fmiCompletedStep2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      fmiBoolean b=0;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->dyLastTime=a->dyTime;
      if (b) a->dyTriggered=1;
    } else status=fmiOK;
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiCompletedStep;

    function CompletedStep
      input fmiModel fmi;
      output Real crossing;
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      crossing := fmiCompletedStep(fmi);
      annotation(LateInline=true);
    end CompletedStep;

    function fmiEventUpdate
      input fmiModel fmi;
      output Real tnext;
      output Boolean stateReset;
      external"C" stateReset = fmuSF1_exp47521634678240760863_fmiEventUpdate2(fmi, tnext);
      annotation(Header="
#ifndef fmuSF1_exp47521634678240760863_EventUpdate_C
#define fmuSF1_exp47521634678240760863_EventUpdate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
int fmuSF1_exp47521634678240760863_fmiEventUpdate2(void*m, double*tnext){
  struct dy_Extended*a=m;
  fmiEventInfo ev;
  fmiStatus status=fmiFatal;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      fmiBoolean b;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->currentMode=dyEventMode;
    }
    status=a->dyFmiEventUpdate(a->m, 0, &ev);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
  }
  if (ev.terminateSimulation) terminate(\"Terminate signaled by FMU\");
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"EventUpdate failed\");
  *tnext=ev.nextEventTime;
  return ev.stateValuesChanged;
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiEventUpdate;

    function EventUpdate
      input fmiModel fmi;
      output Real tnext;
      output Boolean stateReset;
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      (tnext, stateReset) := fmiEventUpdate(fmi);
      annotation(LateInline=true);
    end EventUpdate;

    function fmiInitialize
      input fmiModel fmi;
      output Real tnext;
      output Real initialized=1;
      external"C" tnext = fmuSF1_exp47521634678240760863_fmiInitialize2(fmi);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_Initialize_C
#define fmuSF1_exp47521634678240760863_Initialize_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double fmuSF1_exp47521634678240760863_fmiInitialize2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  fmiBoolean toleranceControlled=fmiFalse;
  fmiReal tolerance=0;
  fmiEventInfo ev;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiInitialize(a->m, toleranceControlled, tolerance, &ev);
      a->currentMode=dyEventMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->dyFirstTimeEvent=ev.nextEventTime;
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"Initialize failed\");
  return a->dyFirstTimeEvent;
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiInitialize;

    function fmiGetDerivatives
    input fmiModel fmi;
    input Integer nx;
    output Real dx[nx];
    external"C" fmuSF1_exp47521634678240760863_fmiGetDerivatives2(
      fmi,
      dx,
      nx);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetDerivatives_C
#define fmuSF1_exp47521634678240760863_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetDerivatives failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetDerivatives;

    function GetDerivatives
      input fmiModel fmi;
      input Integer nx;
      output Real dx[nx];
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      dx := fmiGetDerivatives(fmi, nx);
      annotation(LateInline=true);
    end GetDerivatives;

    function fmiGetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      external"C" fmuSF1_exp47521634678240760863_fmiGetEventIndicators2(
        fmi,
        z,
        nz);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetEventIndicators_C
#define fmuSF1_exp47521634678240760863_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetEventIndicators(a->m, z, nz);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetEventIndicators failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetEventIndicators;

    function GetEventIndicators
      input fmiModel fmi;
      input Integer nz;
      output Real z[nz];
      input Real dummyTime;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      z := fmiGetEventIndicators(fmi, nz);
      annotation(LateInline=true);
    end GetEventIndicators;

    function GetOutput
      input fmiModel fmi;
      input Real Time;
      input Integer outputValueReference[1];
      output Real outputVariable;
      input Real realInputs[:];
      input Integer integerInputs[:];
      input Boolean booleanInputs[:];
      input Integer realInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      input Integer booleanInputValueReferences[:];
    algorithm
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1],1);
      annotation(LateInline=true);
    end GetOutput;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      output Real dummy= 1;
      external"C"
                 fmuSF1_exp47521634678240760863_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetReal_C
#define fmuSF1_exp47521634678240760863_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealParam
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
    protected
      Real oldVals[size(refs, 1)];
      external"C"
                 fmuSF1_exp47521634678240760863_fmiSetRealParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetRealParam_C
#define fmuSF1_exp47521634678240760863_SetRealParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetRealParam2(void*m, const int*refs, size_t nrefs, const double*vals, double*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetReal(a->m, refs, nrefs, oldVals);
      for(i=0; i<nrefs;++i){
        if( abs(vals[i]-oldVals[i])> 5e-16){
          ModelicaError(\"SetRealParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealParam;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      input Real dummy;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}, dummy));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      input Real preAvailable;
      external"C" fmuSF1_exp47521634678240760863_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetReal_C
#define fmuSF1_exp47521634678240760863_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetReal failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetReal;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}, dummy));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" fmuSF1_exp47521634678240760863_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetInteger_C
#define fmuSF1_exp47521634678240760863_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetInteger;

    function fmiSetInteger
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      output Real dummy= 1;
      external"C" fmuSF1_exp47521634678240760863_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetInteger_C
#define fmuSF1_exp47521634678240760863_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerParam
    input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" fmuSF1_exp47521634678240760863_fmiSetIntegerParam2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetIntegerParam_C
#define fmuSF1_exp47521634678240760863_SetIntegerParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetIntegerParam2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i=0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      for(i = 0; i< nrefs; ++i){
        if(vals[i]!=oldVals[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerParam;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      input Integer dummy;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}, dummy));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" fmuSF1_exp47521634678240760863_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetBoolean_C
#define fmuSF1_exp47521634678240760863_GetBoolean_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(vals));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetBoolean failed\");
  for(i=nr-1;i>=0;i--) vals[i]=((fmiBoolean*)(vals))[i];
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetBoolean;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      output Real dummy2= 1;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" fmuSF1_exp47521634678240760863_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetBoolean_C
#define fmuSF1_exp47521634678240760863_SetBoolean_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals,int*dummy) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetBooleanParam
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" fmuSF1_exp47521634678240760863_fmiSetBooleanParam2(
      fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetBooleanParam_C
#define fmuSF1_exp47521634678240760863_SetBooleanParam_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetBooleanParam2(void*m, const int* refs, size_t nr, const int* vals,int*dummy,int*oldVals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
    }else{
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(oldVals));
      for(i=nr-1;i>=0;i--){
        oldVals[i]=((fmiBoolean*)(oldVals))[i];
        if(oldVals[i]!=dummy[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanParam;

    function fmiGetString
      input fmiModel fmi;
      input Integer refs[:];
      output String vals[size(refs, 1)];
      input Integer preAvailable;
      external"C" fmuSF1_exp47521634678240760863_fmiGetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetString_C
#define fmuSF1_exp47521634678240760863_GetString_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetString2(void*m, const int*refs, size_t nrefs, fmiString* vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"StringInteger failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
    end fmiGetString;

    function fmiSetString
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" fmuSF1_exp47521634678240760863_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetString_C
#define fmuSF1_exp47521634678240760863_SetString_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void fmuSF1_exp47521634678240760863_fmiSetString2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetStringParam
    input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" fmuSF1_exp47521634678240760863_fmiSetStringParam2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetStringParam_C
#define fmuSF1_exp47521634678240760863_SetStringParam_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void fmuSF1_exp47521634678240760863_fmiSetStringParam2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif", Library="fmuSF1_exp", LibraryDirectory=
            "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetStringParam;

    function noHysteresis
      input Real x;
      output Real y;
    algorithm
      y:=x+(if (x < 0) then -1 else 1);
    end noHysteresis;
end fmi_Functions;
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn);
  end when;
  fmi_StepEvent = fmi_Functions.CompletedStep(fmi, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0))>0.5;
  der(fmi_x) = fmi_Functions.GetDerivatives(fmi, size(fmi_x, 1), myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
  fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
  for i in 1:size(fmi_z,1) loop
    fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
  end for;
  when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_StepEvent, not initial()}) then
    (fmi_TNext, fmi_NewStates) =  fmi_Functions.EventUpdate(fmi, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    fmi_NewStates2 = if fmi_NewStates then not pre(fmi_NewStates2) else pre(fmi_NewStates2);
  end when;
  for i in 1:size(fmi_x,1) loop
    when {fmi_NewStates2, not fmi_NewStates2} then
      reinit(fmi_x[i], fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x,1))*{if i==j then 1 else 0 for j in 1:size(fmi_x,1)});
    end when;
  end for;
algorithm
  fmi_Functions.fmiSetTime(fmi, time);
  myTime := time;
  fmi_Functions.fmiSetContinuousStates(fmi, fmi_x);
initial algorithm
 // 0 Real parameters
 // 0 Real start values
 // 0 Integer parameters
 // 0 Integer start values
 // 0 Boolean parameters
 // 0 Boolean start values
 // 0 Enumeration parameters
 // 0 Enumeration start values
 // 0 String parameters
 // Set InitalInputs
fmi_Functions.fmiSetReal(fmi, {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, {_CBIn_TSet_start, _CHPIn_P_start, _TDH_HEXout_start, _qvDHWpump_start, _qvDHpump_start, _qvSTpump_start});
  fmi_Functions.fmiSetTime(fmi, time);
  (fmi_TNext_Start,fmi_Initialized) :=fmi_Functions.fmiInitialize(fmi);
  fmi_x :=fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x, 1));
equation
    qv_HEX =  fmi_Functions.GetOutput(fmi,myTime,{805306368}, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    TDH_HEXin =  fmi_Functions.GetOutput(fmi,myTime,{805306369}, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
  annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=0, StopTime=1, Tolerance=1e-06),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 1.0 ME")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 1.0</li>
<li>modelName = fmuSF1_exp</li>
<li>generationTool = SimulationX 4.2.1.68046 (12/15/20)</li>
<li>generationDateAndTime = 2021-06-29T11:51:51</li>
</ul>
</html>"));
end fmuSF1_exp_fmu;
