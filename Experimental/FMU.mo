within ProsNet.Experimental;
package FMU "FMU models from the CoSES library"
extends Modelica.Icons.VariantsPackage;
  model fmuSF1_exp_fmu "fmuSF1_"
  // Model automatically generated by Dymola from FMI model description
  extends fmuIcon;
  public
    parameter Real _CBIn_TSet_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput CBIn_TSet(unit = "K", displayUnit = "°C", quantity = "Temp", start = _CBIn_TSet_start) "Condensing boiler input - set temperature (power is constant)"
    annotation (Placement(transformation(extent={{-114,62},{-94,82}})));
    parameter Real _CHPIn_P_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput CHPIn_P(unit = "Nm/s", displayUnit = "kW", quantity = "Power", start = _CHPIn_P_start) "CHP input - electric power"
    annotation (Placement(transformation(extent={{-114,33},{-94,53}})));
    parameter Real _TDH_HEXout_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput TDH_HEXout(unit = "K", displayUnit = "°C", quantity = "Temp", start = _TDH_HEXout_start) "Outlet temperature of district heating heat exchanger"
    annotation (Placement(transformation(extent={{-114,5},{-94,25}})));
    parameter Real _qvSTpump_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput qvSTpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvSTpump_start) "Reference volume flow of solar thermal pump"
    annotation (Placement(transformation(extent={{-114,-24},{-94,-4}})));
    parameter Real _qvDHpump_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput qvDHpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvDHpump_start) "Reference volume flow of district heating pump - positive: feed in - negative: extraction"
    annotation (Placement(transformation(extent={{-114,-52},{-94,-32}})));
    parameter Real _qvDHWpump_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput qvDHWpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvDHWpump_start) "Reference volume flow of domestic hot water pump to charge the DHW storage"
    annotation (Placement(transformation(extent={{-114,-81},{-94,-61}})));
    Modelica.Blocks.Interfaces.RealOutput qv_HEX(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow") "Volume flow to district heating heat exchanger"
    annotation (Placement(transformation(extent={{100,14},{140,54}})));
    Modelica.Blocks.Interfaces.RealOutput TDH_HEXin(unit = "K", displayUnit = "°C", quantity = "Temp") "Inlet temperature of district heating heat exchanger"
    annotation (Placement(transformation(extent={{100,-53},{140,-13}})));
  public
    parameter String fmi_instanceName="fmuSF1_exp_fmu"
    annotation (Dialog(tab="FMI", group="Instance name"));
    parameter Boolean fmi_loggingOn=false
    annotation (Dialog(tab="FMI", group="Enable logging"));
    constant Integer fmi_NumberOfContinuousStates = 589;
    constant Integer fmi_NumberOfEventIndicators = 90;
  protected
    Real fmi_x[fmi_NumberOfContinuousStates](each fixed=false) "States";
    Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
    Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
    fmi_Functions.fmiModel fmi;
    parameter Real fmi_Initialized(fixed=false);
    Real myTime;
    Boolean fmi_StepEvent;
    Boolean fmi_NewStates;
    Boolean fmi_NewStates2(start=false,fixed=true);
    Real fmi_TNext(start=fmi_TNext_Start,fixed=true);
    parameter Real fmi_TNext_Start(fixed=false);
  package fmi_Functions
    class fmiModel
    extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        output fmiModel fmi;
        external"C" fmi = fmuSF1_exp47521634678240760863_fmiInstantiateModel2(instanceName, loggingOn)
        annotation(Header="
#ifndef fmuSF1_exp47521634678240760863_Instantiate_C
#define fmuSF1_exp47521634678240760863_Instantiate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
#ifndef fmuSF1_exp47521634678240760863_MYSTRCMP_C
#define fmuSF1_exp47521634678240760863_MYSTRCMP_C 1
int fmuSF1_exp47521634678240760863mystrcmp(const void *_a, const void *_b) {
  char *a = _a;
  char *const *b = _b;
  return strcmp(a, *b);
}
#endif
void fmuSF1_exp47521634678240760863Logger(fmiComponent c, fmiString instanceName, fmiStatus status,
	 fmiString category, fmiString message, ...) {
  char msg[4096];
  char buf[4096];
  int len;
  va_list ap;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len <4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmiFatal:
      ModelicaMessage(\"[fmiFatal]: \");
      break;
    case fmiError:
      ModelicaMessage(\"[fmiError]: \");
      break;
    case fmiDiscard:
      ModelicaMessage(\"[fmiDiscard]: \");
      break;
    case fmiWarning:
      ModelicaMessage(\"[fmiWarning]: \");
      break;
    case fmiOK:
      ModelicaMessage(\"[fmiOK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * fmuSF1_exp47521634678240760863_fmiInstantiateModel2(const char*instanceName, fmiBoolean loggingOn) {
  static fmiMECallbackFunctions funcs = {&fmuSF1_exp47521634678240760863Logger, &calloc, &free};
  struct dy_Extended* res;

  res = calloc(1, sizeof(struct dy_Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"fmuSF1_exp.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (fmuSF1_exp.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiateModel=(fmiInstantiateModelFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiInstantiateModel\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInstantiateModel!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInstantiateModel\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiFreeModelInstance=(fmiFreeModelInstanceFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiFreeModelInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmiFreeModelInstance!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiFreeModelInstance\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmiSetTimeFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmiSetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmiGetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmiCompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiCompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmiCompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEventUpdate=(fmiEventUpdateFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiEventUpdate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiEventUpdate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEventUpdate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiInitialize=(fmiInitializeFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiInitialize\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInitialize!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInitialize\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmiGetDerivativesFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmiGetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmiTerminateFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiTerminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiTerminate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiTerminate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmiSetRealFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmiGetRealFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmiSetIntegerFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmiGetIntegerFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmiSetBooleanFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmiGetBooleanFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmiSetStringFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmiGetStringFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiGetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetString!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmiSetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmuSF1_exp_fmiSetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetDebugLogging!\");
      return 0;
    }
    res->m=res->dyFmiInstantiateModel(instanceName, \"{4AB7521C-E6A3-467E-8240-76DC08CBD6E3}\", funcs, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->dyFirstTimeEvent=1e37;res->currentMode=dyInstantiationMode;}
  }
  return res;
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
                "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                          __Dymola_CriticalRegion="fmuSF1_exp");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   fmuSF1_exp47521634678240760863_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_Free_C
#define fmuSF1_exp47521634678240760863_Free_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiFreeModelInstance2(void*m) {
  struct dy_Extended*a=m;
  if (a) {
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeModelInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
                "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                          __Dymola_CriticalRegion="fmuSF1_exp");
      end destructor;
    end fmiModel;

      function fmiSetTime
        input fmiModel fmi;
        input Real ti;
        external"C" fmuSF1_exp47521634678240760863_fmiSetTime2(fmi, ti);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetTime_C
#define fmuSF1_exp47521634678240760863_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetTime2(void*m, double ti) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyInstantiationMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti>a->dyTime || (a->currentMode==dyEventMode && ti==a->dyTime && !isModelicaEvent())){
      a->currentMode=dyContinuousTimeMode;
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti <= a->dyTime && a->currentMode == dyContinuousTimeMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK ) ModelicaError(\"SetTime failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiSetTime;

      function fmiSetContinuousStates
        input fmiModel fmi;
        input Real x[:];
        external"C" fmuSF1_exp47521634678240760863_fmiSetContinuousStates2(
          fmi,
          x,
          size(x, 1));
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetContinuousStates_C
#define fmuSF1_exp47521634678240760863_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetContinuousStates failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiSetContinuousStates;

      function fmiGetContinuousStates
        input fmiModel fmi;
        input Integer nx;
        output Real x[nx];
        external"C" fmuSF1_exp47521634678240760863_fmiGetContinuousStates2(
          fmi,
          x,
          nx);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetContinuousStates_C
#define fmuSF1_exp47521634678240760863_GetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetContinuousStates failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetContinuousStates;

      function fmiCompletedStep
        input fmiModel fmi;
        output Real crossing;
        external"C" crossing = fmuSF1_exp47521634678240760863_fmiCompletedStep2(fmi);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_CompletedStep_C
#define fmuSF1_exp47521634678240760863_CompletedStep_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double fmuSF1_exp47521634678240760863_fmiCompletedStep2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      fmiBoolean b=0;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->dyLastTime=a->dyTime;
      if (b) a->dyTriggered=1;
    } else status=fmiOK;
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiCompletedStep;

      function CompletedStep
        input fmiModel fmi;
        output Real crossing;
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        crossing := fmiCompletedStep(fmi);
        annotation(LateInline=true);
      end CompletedStep;

      function fmiEventUpdate
        input fmiModel fmi;
        output Real tnext;
        output Boolean stateReset;
        external"C" stateReset = fmuSF1_exp47521634678240760863_fmiEventUpdate2(fmi, tnext);
        annotation(Header="
#ifndef fmuSF1_exp47521634678240760863_EventUpdate_C
#define fmuSF1_exp47521634678240760863_EventUpdate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
int fmuSF1_exp47521634678240760863_fmiEventUpdate2(void*m, double*tnext){
  struct dy_Extended*a=m;
  fmiEventInfo ev;
  fmiStatus status=fmiFatal;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      fmiBoolean b;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->currentMode=dyEventMode;
    }
    status=a->dyFmiEventUpdate(a->m, 0, &ev);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
  }
  if (ev.terminateSimulation) terminate(\"Terminate signaled by FMU\");
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"EventUpdate failed\");
  *tnext=ev.nextEventTime;
  return ev.stateValuesChanged;
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiEventUpdate;

      function EventUpdate
        input fmiModel fmi;
        output Real tnext;
        output Boolean stateReset;
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        (tnext, stateReset) := fmiEventUpdate(fmi);
        annotation(LateInline=true);
      end EventUpdate;

      function fmiInitialize
        input fmiModel fmi;
        output Real tnext;
        output Real initialized=1;
        external"C" tnext = fmuSF1_exp47521634678240760863_fmiInitialize2(fmi);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_Initialize_C
#define fmuSF1_exp47521634678240760863_Initialize_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double fmuSF1_exp47521634678240760863_fmiInitialize2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  fmiBoolean toleranceControlled=fmiFalse;
  fmiReal tolerance=0;
  fmiEventInfo ev;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiInitialize(a->m, toleranceControlled, tolerance, &ev);
      a->currentMode=dyEventMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->dyFirstTimeEvent=ev.nextEventTime;
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"Initialize failed\");
  return a->dyFirstTimeEvent;
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiInitialize;

      function fmiGetDerivatives
      input fmiModel fmi;
      input Integer nx;
      output Real dx[nx];
      external"C" fmuSF1_exp47521634678240760863_fmiGetDerivatives2(
        fmi,
        dx,
        nx);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetDerivatives_C
#define fmuSF1_exp47521634678240760863_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetDerivatives failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetDerivatives;

      function GetDerivatives
        input fmiModel fmi;
        input Integer nx;
        output Real dx[nx];
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        dx := fmiGetDerivatives(fmi, nx);
        annotation(LateInline=true);
      end GetDerivatives;

      function fmiGetEventIndicators
        input fmiModel fmi;
        input Integer nz;
        output Real z[nz];
        external"C" fmuSF1_exp47521634678240760863_fmiGetEventIndicators2(
          fmi,
          z,
          nz);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetEventIndicators_C
#define fmuSF1_exp47521634678240760863_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetEventIndicators(a->m, z, nz);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetEventIndicators failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetEventIndicators;

      function GetEventIndicators
        input fmiModel fmi;
        input Integer nz;
        output Real z[nz];
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        z := fmiGetEventIndicators(fmi, nz);
        annotation(LateInline=true);
      end GetEventIndicators;

      function GetOutput
        input fmiModel fmi;
        input Real Time;
        input Integer outputValueReference[1];
        output Real outputVariable;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1],1);
        annotation(LateInline=true);
      end GetOutput;

      function fmiSetReal
        input fmiModel fmi;
        input Integer refs[:];
        input Real vals[size(refs, 1)];
        output Real dummy= 1;
        external"C"
                   fmuSF1_exp47521634678240760863_fmiSetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetReal_C
#define fmuSF1_exp47521634678240760863_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetReal;

      function fmiSetRealParam
        input fmiModel fmi;
        input Integer refs[:];
        input Real vals[size(refs, 1)];
      protected
        Real oldVals[size(refs, 1)];
        external"C"
                   fmuSF1_exp47521634678240760863_fmiSetRealParam2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          oldVals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetRealParam_C
#define fmuSF1_exp47521634678240760863_SetRealParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetRealParam2(void*m, const int*refs, size_t nrefs, const double*vals, double*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetReal(a->m, refs, nrefs, oldVals);
      for(i=0; i<nrefs;++i){
        if( abs(vals[i]-oldVals[i])> 5e-16){
          ModelicaError(\"SetRealParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetRealParam;

      function fmiGetRealScalar
        input fmiModel fmi;
        input Integer ref;
        input Real dummy;
        output Real val;
      algorithm
          val := scalar(fmiGetReal(fmi, {ref}, dummy));
      end fmiGetRealScalar;

      function fmiGetReal
        input fmiModel fmi;
        input Integer refs[:];
        output Real vals[size(refs, 1)];
        input Real preAvailable;
        external"C" fmuSF1_exp47521634678240760863_fmiGetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetReal_C
#define fmuSF1_exp47521634678240760863_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetReal failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetReal;

      function fmiGetIntegerScalar
        input fmiModel fmi;
        input Integer ref;
        input Integer dummy;
        output Integer val;
      algorithm
          val := scalar(fmiGetInteger(fmi, {ref}, dummy));
      end fmiGetIntegerScalar;

      function fmiGetInteger
        input fmiModel fmi;
        input Integer refs[:];
        output Integer vals[size(refs, 1)];
        input Integer preAvailable;
        external"C" fmuSF1_exp47521634678240760863_fmiGetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetInteger_C
#define fmuSF1_exp47521634678240760863_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetInteger failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetInteger;

      function fmiSetInteger
      input fmiModel fmi;
        input Integer refs[:];
        input Integer vals[size(refs, 1)];
        output Real dummy= 1;
        external"C" fmuSF1_exp47521634678240760863_fmiSetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetInteger_C
#define fmuSF1_exp47521634678240760863_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetInteger;

      function fmiSetIntegerParam
      input fmiModel fmi;
        input Integer refs[:];
        input Integer vals[size(refs, 1)];
      protected
        Integer oldVals[size(refs, 1)];
        external"C" fmuSF1_exp47521634678240760863_fmiSetIntegerParam2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          oldVals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetIntegerParam_C
#define fmuSF1_exp47521634678240760863_SetIntegerParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetIntegerParam2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i=0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      for(i = 0; i< nrefs; ++i){
        if(vals[i]!=oldVals[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetIntegerParam;

      function fmiGetBooleanScalar
        input fmiModel fmi;
        input Integer ref;
        input Integer dummy;
        output Boolean val;
      algorithm
          val := scalar(fmiGetBoolean(fmi, {ref}, dummy));
      end fmiGetBooleanScalar;

      function fmiGetBoolean
        input fmiModel fmi;
        input Integer refs[:];
        output Boolean vals[size(refs, 1)];
        input Integer preAvailable;
        external"C" fmuSF1_exp47521634678240760863_fmiGetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetBoolean_C
#define fmuSF1_exp47521634678240760863_GetBoolean_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(vals));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetBoolean failed\");
  for(i=nr-1;i>=0;i--) vals[i]=((fmiBoolean*)(vals))[i];
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetBoolean;

      function fmiSetBoolean
        input fmiModel fmi;
        input Integer refs[:];
        input Boolean vals[size(refs, 1)];
        output Real dummy2= 1;
      protected
        Boolean dummy[size(refs, 1)];
        external"C" fmuSF1_exp47521634678240760863_fmiSetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          dummy);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetBoolean_C
#define fmuSF1_exp47521634678240760863_SetBoolean_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals,int*dummy) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetBoolean;

      function fmiSetBooleanParam
        input fmiModel fmi;
        input Integer refs[:];
        input Boolean vals[size(refs, 1)];
      protected
        Boolean dummy[size(refs, 1)];
        Boolean oldVals[size(refs, 1)];
        external"C" fmuSF1_exp47521634678240760863_fmiSetBooleanParam2(
        fmi,
          refs,
          size(refs, 1),
          vals,
          dummy,
          oldVals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetBooleanParam_C
#define fmuSF1_exp47521634678240760863_SetBooleanParam_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiSetBooleanParam2(void*m, const int* refs, size_t nr, const int* vals,int*dummy,int*oldVals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
    }else{
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(oldVals));
      for(i=nr-1;i>=0;i--){
        oldVals[i]=((fmiBoolean*)(oldVals))[i];
        if(oldVals[i]!=dummy[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetBooleanParam;

      function fmiGetString
        input fmiModel fmi;
        input Integer refs[:];
        output String vals[size(refs, 1)];
        input Integer preAvailable;
        external"C" fmuSF1_exp47521634678240760863_fmiGetString2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_GetString_C
#define fmuSF1_exp47521634678240760863_GetString_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_exp47521634678240760863_fmiGetString2(void*m, const int*refs, size_t nrefs, fmiString* vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"StringInteger failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp");
      end fmiGetString;

      function fmiSetString
      input fmiModel fmi;
        input Integer refs[:];
        input String vals[size(refs, 1)];
        external"C" fmuSF1_exp47521634678240760863_fmiSetString2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetString_C
#define fmuSF1_exp47521634678240760863_SetString_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void fmuSF1_exp47521634678240760863_fmiSetString2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetString;

      function fmiSetStringParam
      input fmiModel fmi;
        input Integer refs[:];
        input String vals[size(refs, 1)];
        external"C" fmuSF1_exp47521634678240760863_fmiSetStringParam2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_exp47521634678240760863_SetStringParam_C
#define fmuSF1_exp47521634678240760863_SetStringParam_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void fmuSF1_exp47521634678240760863_fmiSetStringParam2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif",   Library="fmuSF1_exp", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_exp/binaries",                                            __Dymola_CriticalRegion="fmuSF1_exp",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetStringParam;

      function noHysteresis
        input Real x;
        output Real y;
      algorithm
        y:=x+(if (x < 0) then -1 else 1);
      end noHysteresis;
  end fmi_Functions;
  equation
    when initial() then
      fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn);
    end when;
    fmi_StepEvent = fmi_Functions.CompletedStep(fmi, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0))>0.5;
    der(fmi_x) = fmi_Functions.GetDerivatives(fmi, size(fmi_x, 1), myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    for i in 1:size(fmi_z,1) loop
      fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
    end for;
    when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_StepEvent, not initial()}) then
      (fmi_TNext, fmi_NewStates) =  fmi_Functions.EventUpdate(fmi, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
      fmi_NewStates2 = if fmi_NewStates then not pre(fmi_NewStates2) else pre(fmi_NewStates2);
    end when;
    for i in 1:size(fmi_x,1) loop
      when {fmi_NewStates2, not fmi_NewStates2} then
        reinit(fmi_x[i], fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x,1))*{if i==j then 1 else 0 for j in 1:size(fmi_x,1)});
      end when;
    end for;
  algorithm
    fmi_Functions.fmiSetTime(fmi, time);
    myTime := time;
    fmi_Functions.fmiSetContinuousStates(fmi, fmi_x);
  initial algorithm
   // 0 Real parameters
   // 0 Real start values
   // 0 Integer parameters
   // 0 Integer start values
   // 0 Boolean parameters
   // 0 Boolean start values
   // 0 Enumeration parameters
   // 0 Enumeration start values
   // 0 String parameters
   // Set InitalInputs
  fmi_Functions.fmiSetReal(fmi, {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, {_CBIn_TSet_start, _CHPIn_P_start, _TDH_HEXout_start, _qvDHWpump_start, _qvDHpump_start, _qvSTpump_start});
    fmi_Functions.fmiSetTime(fmi, time);
    (fmi_TNext_Start,fmi_Initialized) :=fmi_Functions.fmiInitialize(fmi);
    fmi_x :=fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x, 1));
  equation
      qv_HEX =  fmi_Functions.GetOutput(fmi,myTime,{805306368}, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
      TDH_HEXin =  fmi_Functions.GetOutput(fmi,myTime,{805306369}, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=0, StopTime=1, Tolerance=1e-06),
      Icon(graphics={
        Text(extent={{-150,150},{150,110}},
          lineColor={0,0,255},
          textString="%name"),
        Text(extent={{-150,-110},{150,-150}},
          lineColor={95,95,95},
          textString="FMI 1.0 ME")}),
  Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 1.0</li>
<li>modelName = fmuSF1_exp</li>
<li>generationTool = SimulationX 4.2.1.68046 (12/15/20)</li>
<li>generationDateAndTime = 2021-06-29T11:51:51</li>
</ul>
</html>"));
  end fmuSF1_exp_fmu;

  package Validation
  extends Modelica.Icons.ExamplesPackage;
    model fmuSF1 "Validation of the fmuSF1 FMU model"
      extends Modelica.Icons.Example;

      Modelica.Blocks.Sources.IntegerConstant pi(k=1)
        annotation (Placement(transformation(extent={{-78,24},{-58,44}})));
      Modelica.Blocks.Sources.Constant op(k=0.5)
        annotation (Placement(transformation(extent={{60,60},{40,80}})));
      Modelica.Blocks.Sources.Constant y(k=0.5)
        annotation (Placement(transformation(extent={{60,20},{40,40}})));
      Fluid.Sources.Boundary_pT bou1(
        redeclare package Medium = Media.Water,
                                     nPorts=1) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={-76,-66})));
      Fluid.Sources.Boundary_pT bou2(redeclare package Medium = Media.Water,
        p=400000,
        T=343.15,                    nPorts=1) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=180,
            origin={92,6})));
      Fluid.Sources.MassFlowSource_T boundary(
        redeclare package Medium = Media.Water,
        use_m_flow_in=true,
        m_flow=0.358,
        use_T_in=true,
        T=343.15,
        nPorts=1)
        annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={-30,-42})));
      Fluid.Sources.Boundary_pT bou3(redeclare package Medium = Media.Water, nPorts=
           1)                                  annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={50,-70})));

      Prosumers.BaseClasses.PrimarySide priSide(
        redeclare package Medium1 = ProsNet.Media.Water,
        redeclare package Medium2 = ProsNet.Media.Water,
        redeclare Fluid.Pumps.Data.Pumps.QuadraticCharacteristic feedinPer)
        annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

      Fluid.Sensors.TemperatureTwoPort temPriHot(m_flow_nominal=priSide.m_flow_nominal_1, tau=1)
        annotation (Placement(transformation(extent={{48,-10},{68,10}})));
      Fluid.Sensors.TemperatureTwoPort temPriCold(m_flow_nominal=priSide.m_flow_nominal_1, tau=1)
        annotation (Placement(transformation(extent={{-62,-4},{-42,16}})));
      fmuSF1_exp_fmu fmuSF1_exp_fmu1 annotation (Placement(transformation(
            extent={{-19,-19},{19,19}},
            rotation=90,
            origin={11,-151})));
      Modelica.Blocks.Sources.IntegerConstant mu(k=-1)
        annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
      Modelica.Blocks.Math.Gain gain(k=1000) annotation (Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={4,-102})));
      Modelica.Blocks.Sources.Constant qvDHpump(k=0.000166667) annotation (
          Placement(transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={20,-224})));
      Fluid.Sensors.TemperatureTwoPort temSecHot(m_flow_nominal=priSide.m_flow_nominal_1,
          tau=1) annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={36,-36})));
      Modelica.Blocks.Sources.Constant zero(k=0) annotation (Placement(
            transformation(
            extent={{-10,-10},{10,10}},
            rotation=90,
            origin={-16,-224})));
      Fluid.Sensors.TemperatureTwoPort temSecCold(m_flow_nominal=priSide.m_flow_nominal_1,
          tau=1) annotation (Placement(transformation(
            extent={{10,-10},{-10,10}},
            rotation=90,
            origin={-32,-18})));
    equation
      connect(pi.y, priSide.pi) annotation (Line(points={{-57,34},{-36,34},{-36,12},{-12,12}},
            color={255,127,0}));
      connect(priSide.feedPump_y_set, y.y)
        annotation (Line(points={{4,12},{4,30},{39,30}}, color={0,0,127}));
      connect(op.y, priSide.conVal_op_set)
        annotation (Line(points={{39,70},{-4,70},{-4,12}}, color={0,0,127}));
      connect(priSide.port_b1, temPriHot.port_a)
        annotation (Line(points={{10,6},{26,6},{26,0},{48,0}}, color={0,127,255}));
      connect(temPriHot.port_b, bou2.ports[1])
        annotation (Line(points={{68,0},{72,0},{72,6},{82,6}}, color={0,127,255}));
      connect(bou1.ports[1], temPriCold.port_a)
        annotation (Line(points={{-76,-56},{-76,6},{-62,6}}, color={0,127,255}));
      connect(temPriCold.port_b, priSide.port_a1)
        annotation (Line(points={{-42,6},{-10,6}}, color={0,127,255}));
      connect(mu.y, priSide.mu) annotation (Line(points={{-59,70},{-30,70},{-30,
              15.8},{-12,15.8}}, color={255,127,0}));
      connect(fmuSF1_exp_fmu1.qv_HEX, gain.u) annotation (Line(points={{4.54,-128.2},
              {4.54,-120.1},{4,-120.1},{4,-114}}, color={0,0,127}));
      connect(gain.y, boundary.m_flow_in) annotation (Line(points={{4,-91},{4,-80},
              {-38,-80},{-38,-54}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.qvDHpump, qvDHpump.y) annotation (Line(points={{18.98,
              -170.76},{18.98,-191.38},{20,-191.38},{20,-213}}, color={0,0,127}));
      connect(priSide.port_a2, temSecHot.port_a) annotation (Line(points={{10,-6},{
              24,-6},{24,-26},{36,-26}}, color={0,127,255}));
      connect(temSecHot.port_b, bou3.ports[1]) annotation (Line(points={{36,-46},{
              44,-46},{44,-60},{50,-60}}, color={0,127,255}));
      connect(temSecHot.T, fmuSF1_exp_fmu1.TDH_HEXout) annotation (Line(points={{25,
              -36},{-16,-36},{-16,-112},{-40,-112},{-40,-184},{8,-184},{8,-178},{
              8.15,-178},{8.15,-170.76}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.TDH_HEXin, boundary.T_in) annotation (Line(points={{
              17.27,-128.2},{17.27,-66},{-34,-66},{-34,-54}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.CBIn_TSet, zero.y) annotation (Line(points={{-2.68,
              -170.76},{-2.68,-192.38},{-16,-192.38},{-16,-213}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.CHPIn_P, zero.y) annotation (Line(points={{2.83,
              -170.76},{2.83,-192.38},{-16,-192.38},{-16,-213}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.qvSTpump, zero.y) annotation (Line(points={{13.66,
              -170.76},{13.66,-191.38},{-16,-191.38},{-16,-213}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.qvDHWpump, zero.y) annotation (Line(points={{24.49,
              -170.76},{24.49,-192.38},{-16,-192.38},{-16,-213}}, color={0,0,127}));
      connect(boundary.ports[1], temSecCold.port_b) annotation (Line(points={{-30,
              -32},{-32,-32},{-32,-28}}, color={0,127,255}));
      connect(temSecCold.port_a, priSide.port_b2)
        annotation (Line(points={{-32,-8},{-32,-6},{-10,-6}}, color={0,127,255}));
      annotation (experiment(StopTime=100,Tolerance=1e-006),
      Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
            coordinateSystem(preserveAspectRatio=false)));
    end fmuSF1;

    model fmuSF1_basic "Validation of the fmuSF1_ FMU"
      Modelica.Blocks.Sources.Constant qvDHpump(k=0.000166667)
        annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
      Modelica.Blocks.Sources.Constant TDH_HEXout(k=80 + 273.15)
        annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
      Modelica.Blocks.Sources.Constant zero(k=0)
        annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
      fmuSF1_exp_fmu fmuSF1_exp_fmu1
        annotation (Placement(transformation(extent={{-6,-6},{58,58}})));
    equation
      connect(fmuSF1_exp_fmu1.TDH_HEXout, TDH_HEXout.y) annotation (Line(points={{
              -7.28,30.8},{-34,30.8},{-34,30},{-60,30},{-60,10},{-79,10}}, color={0,
              0,127}));
      connect(fmuSF1_exp_fmu1.qvDHpump, qvDHpump.y) annotation (Line(points={{-7.28,
              12.56},{-30,12.56},{-30,12},{-52,12},{-52,-50},{-79,-50}}, color={0,0,
              127}));
      connect(fmuSF1_exp_fmu1.CBIn_TSet, zero.y) annotation (Line(points={{-7.28,
              49.04},{-43.64,49.04},{-43.64,50},{-79,50}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.CHPIn_P, zero.y) annotation (Line(points={{-7.28,
              39.76},{-43.64,39.76},{-43.64,50},{-79,50}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.qvSTpump, zero.y) annotation (Line(points={{-7.28,
              21.52},{-43.64,21.52},{-43.64,50},{-79,50}}, color={0,0,127}));
      connect(fmuSF1_exp_fmu1.qvDHWpump, zero.y) annotation (Line(points={{-7.28,
              3.28},{-43.64,3.28},{-43.64,50},{-79,50}}, color={0,0,127}));
    end fmuSF1_basic;

    model basic_fmuSF1 "Basic validation of the fmuSF1 model with constant inputs"
      fmuSF1_encapsulated fmuSF1_encapsulated1
        annotation (Placement(transformation(extent={{-24,-26},{30,28}})));
      Modelica.Blocks.Sources.Constant zero(k=0)
        annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
      Modelica.Blocks.Sources.Constant TDH_HEXout(k=80 + 273.15)
        annotation (Placement(transformation(extent={{-100,-4},{-80,16}})));
      Modelica.Blocks.Sources.Constant qvDHpump(k=0.000166667)
        annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
    equation
      connect(TDH_HEXout.y, fmuSF1_encapsulated1.TDH_HEXout) annotation (Line(
            points={{-79,6},{-54,6},{-54,5.05},{-25.08,5.05}}, color={0,0,127}));
      connect(qvDHpump.y, fmuSF1_encapsulated1.qvDHpump) annotation (Line(points={{
              -79,-50},{-52,-50},{-52,-10.34},{-25.08,-10.34}}, color={0,0,127}));
      connect(zero.y, fmuSF1_encapsulated1.CBIn_TSet) annotation (Line(points={{-79,
              50},{-64,50},{-64,20.44},{-25.08,20.44}}, color={0,0,127}));
      connect(fmuSF1_encapsulated1.CHPIn_P, zero.y) annotation (Line(points={{
              -25.08,12.61},{-64.54,12.61},{-64.54,50},{-79,50}}, color={0,0,127}));
      connect(fmuSF1_encapsulated1.qvSTpump, zero.y) annotation (Line(points={{
              -25.08,-2.78},{-64.54,-2.78},{-64.54,50},{-79,50}}, color={0,0,127}));
      connect(zero.y, fmuSF1_encapsulated1.qvDHWpump) annotation (Line(points={{-79,
              50},{-64,50},{-64,-18.17},{-25.08,-18.17}}, color={0,0,127}));
      annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
            coordinateSystem(preserveAspectRatio=false)));
    end basic_fmuSF1;

    model FMUhacked
      Modelica.Blocks.Sources.Constant zero(k=0)
        annotation (Placement(transformation(extent={{-144,6},{-124,26}})));
      Modelica.Blocks.Sources.Constant TDH_HEXout(k=80 + 273.15)
        annotation (Placement(transformation(extent={{-144,-34},{-124,-14}})));
      Modelica.Blocks.Sources.Constant qvDHpump(k=0.000166667)
        annotation (Placement(transformation(extent={{-144,-94},{-124,-74}})));
      ProsNet.Experimental.FMU.fmuSF1_outer_exp_hack_new_fmu fmuSF1_outer_exp_hack_new_fmu1
        annotation (Placement(transformation(extent={{-38,-36},{42,44}})));
    equation
      connect(TDH_HEXout.y, fmuSF1_outer_exp_hack_new_fmu1.TDH_HEXout) annotation (
          Line(points={{-123,-24},{-82,-24},{-82,10},{-39.6,10}}, color={0,0,127}));
      connect(qvDHpump.y, fmuSF1_outer_exp_hack_new_fmu1.qvDHpump) annotation (Line(
            points={{-123,-84},{-92,-84},{-92,-46},{-60,-46},{-60,-12.8},{-39.6,
              -12.8}}, color={0,0,127}));
      connect(zero.y, fmuSF1_outer_exp_hack_new_fmu1.CBIn_TSet) annotation (Line(
            points={{-123,16},{-100,16},{-100,32},{-70,32},{-70,32.8},{-39.6,32.8}},
            color={0,0,127}));
      connect(fmuSF1_outer_exp_hack_new_fmu1.CHPIn_P, zero.y) annotation (Line(
            points={{-39.6,21.2},{-81.8,21.2},{-81.8,16},{-123,16}}, color={0,0,127}));
      connect(zero.y, fmuSF1_outer_exp_hack_new_fmu1.qvSTpump) annotation (Line(
            points={{-123,16},{-110,16},{-110,-1.6},{-39.6,-1.6}}, color={0,0,127}));
      connect(fmuSF1_outer_exp_hack_new_fmu1.qvDHWpump,
        fmuSF1_outer_exp_hack_new_fmu1.qvSTpump) annotation (Line(points={{-39.6,
              -24.4},{-68,-24.4},{-68,-1.6},{-39.6,-1.6}}, color={0,0,127}));
      annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
            coordinateSystem(preserveAspectRatio=false)));
    end FMUhacked;
  end Validation;

  model fmuSF1_outer_exp_hack_new_fmu "fmuSF1 hacked"
  // Model automatically generated by Dymola from FMI model description
  extends fmuIcon;
  public
    Real dem_T_RL(unit = "-", displayUnit = "-", quantity = "Unitless") "Return temperature";
    parameter Real _CBIn_TSet_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput CBIn_TSet(unit = "K", displayUnit = "°C", quantity = "Temp", start = _CBIn_TSet_start) "Condensing boiler input - set temperature (power is constant)"
    annotation (Placement(transformation(extent={{-114,62},{-94,82}})));
    parameter Real _CHPIn_P_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput CHPIn_P(unit = "Nm/s", displayUnit = "kW", quantity = "Power", start = _CHPIn_P_start) "CHP input - electric power"
    annotation (Placement(transformation(extent={{-114,33},{-94,53}})));
    parameter Real _TDH_HEXout_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput TDH_HEXout(unit = "K", displayUnit = "°C", quantity = "Temp", start = _TDH_HEXout_start) "Outlet temperature of district heating heat exchanger"
    annotation (Placement(transformation(extent={{-114,5},{-94,25}})));
    parameter Real _qvSTpump_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput qvSTpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvSTpump_start) "Reference volume flow of solar thermal pump"
    annotation (Placement(transformation(extent={{-114,-24},{-94,-4}})));
    parameter Real _qvDHpump_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput qvDHpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvDHpump_start) "Reference volume flow of district heating pump - positive: feed in - negative: extraction"
    annotation (Placement(transformation(extent={{-114,-52},{-94,-32}})));
    parameter Real _qvDHWpump_start = 0.
    annotation (Dialog( group="Start values for inputs "));
    Modelica.Blocks.Interfaces.RealInput qvDHWpump(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow", start = _qvDHWpump_start) "Reference volume flow of domestic hot water pump to charge the DHW storage"
    annotation (Placement(transformation(extent={{-114,-81},{-94,-61}})));
    Modelica.Blocks.Interfaces.RealOutput qv_HEX(unit = "m³/s", displayUnit = "l/min", quantity = "VolumeFlow") "Volume flow to district heating heat exchanger"
    annotation (Placement(transformation(extent={{100,14},{140,54}})));
    Modelica.Blocks.Interfaces.RealOutput TDH_HEXin(unit = "K", displayUnit = "°C", quantity = "Temp") "Inlet temperature of district heating heat exchanger"
    annotation (Placement(transformation(extent={{100,-53},{140,-13}})));
  public
    parameter String fmi_instanceName="fmuSF1_outer_exp_hack_new_fmu"
    annotation (Dialog(tab="FMI", group="Instance name"));
    parameter Boolean fmi_loggingOn=false
    annotation (Dialog(tab="FMI", group="Enable logging"));
    constant Integer fmi_NumberOfContinuousStates = 589;
    constant Integer fmi_NumberOfEventIndicators = 90;
  protected
    Real fmi_x[fmi_NumberOfContinuousStates](each fixed=false) "States";
    Real fmi_z[fmi_NumberOfEventIndicators] "Event indicators";
    Boolean fmi_z_positive[fmi_NumberOfEventIndicators](each start=false, fixed=true);
    fmi_Functions.fmiModel fmi;
    parameter Real fmi_Initialized(fixed=false);
    Real myTime;
    Boolean fmi_StepEvent;
    Boolean fmi_NewStates;
    Boolean fmi_NewStates2(start=false,fixed=true);
    Real fmi_TNext(start=fmi_TNext_Start,fixed=true);
    parameter Real fmi_TNext_Start(fixed=false);
  package fmi_Functions
    class fmiModel
    extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        output fmiModel fmi;
        external"C" fmi = fmuSF1_outer_exp_hack77420503548182941207_fmiInstantiateModel2(instanceName, loggingOn)
        annotation(Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_Instantiate_C
#define fmuSF1_outer_exp_hack77420503548182941207_Instantiate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
#ifndef fmuSF1_outer_exp_hack77420503548182941207_MYSTRCMP_C
#define fmuSF1_outer_exp_hack77420503548182941207_MYSTRCMP_C 1
int fmuSF1_outer_exp_hack77420503548182941207mystrcmp(const void *_a, const void *_b) {
  char *a = _a;
  char *const *b = _b;
  return strcmp(a, *b);
}
#endif
void fmuSF1_outer_exp_hack77420503548182941207Logger(fmiComponent c, fmiString instanceName, fmiStatus status,
	 fmiString category, fmiString message, ...) {
  char msg[4096];
  char buf[4096];
  int len;
  va_list ap;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len <4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmiFatal:
      ModelicaMessage(\"[fmiFatal]: \");
      break;
    case fmiError:
      ModelicaMessage(\"[fmiError]: \");
      break;
    case fmiDiscard:
      ModelicaMessage(\"[fmiDiscard]: \");
      break;
    case fmiWarning:
      ModelicaMessage(\"[fmiWarning]: \");
      break;
    case fmiOK:
      ModelicaMessage(\"[fmiOK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * fmuSF1_outer_exp_hack77420503548182941207_fmiInstantiateModel2(const char*instanceName, fmiBoolean loggingOn) {
  static fmiMECallbackFunctions funcs = {&fmuSF1_outer_exp_hack77420503548182941207Logger, &calloc, &free};
  struct dy_Extended* res;

  res = calloc(1, sizeof(struct dy_Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"fmuSF1_outer_exp_hack.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (fmuSF1_outer_exp_hack.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiateModel=(fmiInstantiateModelFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiInstantiateModel\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInstantiateModel!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInstantiateModel\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiFreeModelInstance=(fmiFreeModelInstanceFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiFreeModelInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmiFreeModelInstance!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiFreeModelInstance\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetTime=(fmiSetTimeFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetTime\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetTime!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetTime\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetContinuousStates=(fmiSetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiSetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetContinuousStates=(fmiGetContinuousStatesFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetContinuousStates\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetContinuousStates!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetContinuousStates\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiCompletedIntegratorStep=(fmiCompletedIntegratorStepFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiCompletedIntegratorStep\"))) {
      ModelicaError(\"GetProcAddress failed for fmiCompletedIntegratorStep!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiCompletedIntegratorStep\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiEventUpdate=(fmiEventUpdateFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiEventUpdate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiEventUpdate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiEventUpdate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiInitialize=(fmiInitializeFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiInitialize\"))) {
      ModelicaError(\"GetProcAddress failed for fmiInitialize!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiInitialize\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetDerivatives=(fmiGetDerivativesFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetDerivatives\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetDerivatives!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetDerivatives\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiGetEventIndicators=(fmiGetEventIndicatorsFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetEventIndicators\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetEventIndicators!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiGetEventIndicators\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmiTerminateFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiTerminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmiTerminate!\\n The model was imported as a model exchange FMU but could not load the ME specific function fmiTerminate\\n Verify that the FMU supports Model Exchange\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmiSetRealFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmiGetRealFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmiSetIntegerFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmiGetIntegerFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmiSetBooleanFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmiGetBooleanFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmiSetStringFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmiGetStringFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiGetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmiGetString!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmiSetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmuSF1_outer_exp_hack_fmiSetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmiSetDebugLogging!\");
      return 0;
    }
    res->m=res->dyFmiInstantiateModel(instanceName, \"{7C7420B5-0F35-4F81-8CBC-B2BE94D120E7}\", funcs, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->dyFirstTimeEvent=1e37;res->currentMode=dyInstantiationMode;}
  }
  return res;
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
                "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                    __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   fmuSF1_outer_exp_hack77420503548182941207_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_Free_C
#define fmuSF1_outer_exp_hack77420503548182941207_Free_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiFreeModelInstance2(void*m) {
  struct dy_Extended*a=m;
  if (a) {
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeModelInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
                "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                    __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end destructor;
    end fmiModel;

      function fmiSetTime
        input fmiModel fmi;
        input Real ti;
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetTime2(fmi, ti);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetTime_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetTime_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetTime2(void*m, double ti) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyInstantiationMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti>a->dyTime || (a->currentMode==dyEventMode && ti==a->dyTime && !isModelicaEvent())){
      a->currentMode=dyContinuousTimeMode;
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else if(ti <= a->dyTime && a->currentMode == dyContinuousTimeMode){
      a->dyTime=ti;
      status=a->dyFmiSetTime(a->m, ti);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK ) ModelicaError(\"SetTime failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiSetTime;

      function fmiSetContinuousStates
        input fmiModel fmi;
        input Real x[:];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetContinuousStates2(
          fmi,
          x,
          size(x, 1));
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetContinuousStates_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetContinuousStates2(void*m, const double*x, size_t nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      status=a->dyFmiSetContinuousStates(a->m, x, nx);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetContinuousStates failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiSetContinuousStates;

      function fmiGetContinuousStates
        input fmiModel fmi;
        input Integer nx;
        output Real x[nx];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetContinuousStates2(
          fmi,
          x,
          nx);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetContinuousStates_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetContinuousStates_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetContinuousStates2(void*m, double*x, int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetContinuousStates(a->m, x, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetContinuousStates failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetContinuousStates;

      function fmiCompletedStep
        input fmiModel fmi;
        output Real crossing;
        external"C" crossing = fmuSF1_outer_exp_hack77420503548182941207_fmiCompletedStep2(fmi);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_CompletedStep_C
#define fmuSF1_outer_exp_hack77420503548182941207_CompletedStep_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double fmuSF1_outer_exp_hack77420503548182941207_fmiCompletedStep2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    if (a->dyTime>a->dyLastTime) {
      fmiBoolean b=0;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->dyLastTime=a->dyTime;
      if (b) a->dyTriggered=1;
    } else status=fmiOK;
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"CompletedIntegratorStep failed\");
  return a->dyTriggered && a->dyTime>=a->dyLastTime;
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiCompletedStep;

      function CompletedStep
        input fmiModel fmi;
        output Real crossing;
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        crossing := fmiCompletedStep(fmi);
        annotation(LateInline=true);
      end CompletedStep;

      function fmiEventUpdate
        input fmiModel fmi;
        output Real tnext;
        output Boolean stateReset;
        external"C" stateReset = fmuSF1_outer_exp_hack77420503548182941207_fmiEventUpdate2(fmi, tnext);
        annotation(Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_EventUpdate_C
#define fmuSF1_outer_exp_hack77420503548182941207_EventUpdate_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
int fmuSF1_outer_exp_hack77420503548182941207_fmiEventUpdate2(void*m, double*tnext){
  struct dy_Extended*a=m;
  fmiEventInfo ev;
  fmiStatus status=fmiFatal;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode==dyContinuousTimeMode){
      fmiBoolean b;
      status=a->dyFmiCompletedIntegratorStep(a->m, &b);
      a->currentMode=dyEventMode;
    }
    status=a->dyFmiEventUpdate(a->m, 0, &ev);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
  }
  if (ev.terminateSimulation) terminate(\"Terminate signaled by FMU\");
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"EventUpdate failed\");
  *tnext=ev.nextEventTime;
  return ev.stateValuesChanged;
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiEventUpdate;

      function EventUpdate
        input fmiModel fmi;
        output Real tnext;
        output Boolean stateReset;
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        (tnext, stateReset) := fmiEventUpdate(fmi);
        annotation(LateInline=true);
      end EventUpdate;

      function fmiInitialize
        input fmiModel fmi;
        output Real tnext;
        output Real initialized=1;
        external"C" tnext = fmuSF1_outer_exp_hack77420503548182941207_fmiInitialize2(fmi);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_Initialize_C
#define fmuSF1_outer_exp_hack77420503548182941207_Initialize_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
double fmuSF1_outer_exp_hack77420503548182941207_fmiInitialize2(void*m) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  fmiBoolean toleranceControlled=fmiFalse;
  fmiReal tolerance=0;
  fmiEventInfo ev;
  ev.nextEventTime=1e37;
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiInitialize(a->m, toleranceControlled, tolerance, &ev);
      a->currentMode=dyEventMode;
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->dyFirstTimeEvent=ev.nextEventTime;
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"Initialize failed\");
  return a->dyFirstTimeEvent;
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiInitialize;

      function fmiGetDerivatives
      input fmiModel fmi;
      input Integer nx;
      output Real dx[nx];
      external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetDerivatives2(
        fmi,
        dx,
        nx);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetDerivatives_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetDerivatives_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetDerivatives2(void*m,double*dx,int nx) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetDerivatives(a->m, dx, nx);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetDerivatives failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetDerivatives;

      function GetDerivatives
        input fmiModel fmi;
        input Integer nx;
        output Real dx[nx];
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        dx := fmiGetDerivatives(fmi, nx);
        annotation(LateInline=true);
      end GetDerivatives;

      function fmiGetEventIndicators
        input fmiModel fmi;
        input Integer nz;
        output Real z[nz];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetEventIndicators2(
          fmi,
          z,
          nz);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetEventIndicators_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetEventIndicators_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetEventIndicators2(void*m,double*z,int nz) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetEventIndicators(a->m, z, nz);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetEventIndicators failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetEventIndicators;

      function GetEventIndicators
        input fmiModel fmi;
        input Integer nz;
        output Real z[nz];
        input Real dummyTime;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        z := fmiGetEventIndicators(fmi, nz);
        annotation(LateInline=true);
      end GetEventIndicators;

      function GetOutput
        input fmiModel fmi;
        input Real Time;
        input Integer outputValueReference[1];
        output Real outputVariable;
        input Real realInputs[:];
        input Integer integerInputs[:];
        input Boolean booleanInputs[:];
        input Integer realInputValueReferences[:];
        input Integer integerInputValueReferences[:];
        input Integer booleanInputValueReferences[:];
      algorithm
        fmiSetReal(fmi,realInputValueReferences,realInputs);
        fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
        fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
        outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1],1);
        annotation(LateInline=true);
      end GetOutput;

      function fmiSetReal
        input fmiModel fmi;
        input Integer refs[:];
        input Real vals[size(refs, 1)];
        output Real dummy= 1;
        external"C"
                   fmuSF1_outer_exp_hack77420503548182941207_fmiSetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetReal_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetReal;

      function fmiSetRealParam
        input fmiModel fmi;
        input Integer refs[:];
        input Real vals[size(refs, 1)];
      protected
        Real oldVals[size(refs, 1)];
        external"C"
                   fmuSF1_outer_exp_hack77420503548182941207_fmiSetRealParam2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          oldVals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetRealParam_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetRealParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetRealParam2(void*m, const int*refs, size_t nrefs, const double*vals, double*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetReal(a->m, refs, nrefs, oldVals);
      for(i=0; i<nrefs;++i){
        if( abs(vals[i]-oldVals[i])> 5e-16){
          ModelicaError(\"SetRealParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetReal failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetRealParam;

      function fmiGetRealScalar
        input fmiModel fmi;
        input Integer ref;
        input Real dummy;
        output Real val;
      algorithm
          val := scalar(fmiGetReal(fmi, {ref}, dummy));
      end fmiGetRealScalar;

      function fmiGetReal
        input fmiModel fmi;
        input Integer refs[:];
        output Real vals[size(refs, 1)];
        input Real preAvailable;
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetReal2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetReal_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetReal failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetReal;

      function fmiGetIntegerScalar
        input fmiModel fmi;
        input Integer ref;
        input Integer dummy;
        output Integer val;
      algorithm
          val := scalar(fmiGetInteger(fmi, {ref}, dummy));
      end fmiGetIntegerScalar;

      function fmiGetInteger
        input fmiModel fmi;
        input Integer refs[:];
        output Integer vals[size(refs, 1)];
        input Integer preAvailable;
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetInteger_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetInteger failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetInteger;

      function fmiSetInteger
      input fmiModel fmi;
        input Integer refs[:];
        input Integer vals[size(refs, 1)];
        output Real dummy= 1;
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetInteger2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetInteger_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetInteger;

      function fmiSetIntegerParam
      input fmiModel fmi;
        input Integer refs[:];
        input Integer vals[size(refs, 1)];
      protected
        Integer oldVals[size(refs, 1)];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetIntegerParam2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          oldVals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetIntegerParam_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetIntegerParam_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetIntegerParam2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  int i=0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }else{
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      for(i = 0; i< nrefs; ++i){
        if(vals[i]!=oldVals[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetInteger failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetIntegerParam;

      function fmiGetBooleanScalar
        input fmiModel fmi;
        input Integer ref;
        input Integer dummy;
        output Boolean val;
      algorithm
          val := scalar(fmiGetBoolean(fmi, {ref}, dummy));
      end fmiGetBooleanScalar;

      function fmiGetBoolean
        input fmiModel fmi;
        input Integer refs[:];
        output Boolean vals[size(refs, 1)];
        input Integer preAvailable;
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetBoolean_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetBoolean_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(vals));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"GetBoolean failed\");
  for(i=nr-1;i>=0;i--) vals[i]=((fmiBoolean*)(vals))[i];
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetBoolean;

      function fmiSetBoolean
        input fmiModel fmi;
        input Integer refs[:];
        input Boolean vals[size(refs, 1)];
        output Real dummy2= 1;
      protected
        Boolean dummy[size(refs, 1)];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetBoolean2(
          fmi,
          refs,
          size(refs, 1),
          vals,
          dummy);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetBoolean_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetBoolean_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals,int*dummy) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetBoolean;

      function fmiSetBooleanParam
        input fmiModel fmi;
        input Integer refs[:];
        input Boolean vals[size(refs, 1)];
      protected
        Boolean dummy[size(refs, 1)];
        Boolean oldVals[size(refs, 1)];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetBooleanParam2(
        fmi,
          refs,
          size(refs, 1),
          vals,
          dummy,
          oldVals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetBooleanParam_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetBooleanParam_C 1
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetBooleanParam2(void*m, const int* refs, size_t nr, const int* vals,int*dummy,int*oldVals) {
  int i;
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmiBoolean*)(dummy))[i]=vals[i];
  if (a) {
    if(a->currentMode == dyInstantiationMode){
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmiBoolean*)(dummy));
    }else{
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmiBoolean*)(oldVals));
      for(i=nr-1;i>=0;i--){
        oldVals[i]=((fmiBoolean*)(oldVals))[i];
        if(oldVals[i]!=dummy[i]){
          ModelicaError(\"SetIntegerParameter: new parameters with diferent values are being set after initialization, this is not allowed\");
        }
      }
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetBoolean failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetBooleanParam;

      function fmiGetString
        input fmiModel fmi;
        input Integer refs[:];
        output String vals[size(refs, 1)];
        input Integer preAvailable;
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiGetString2(
          fmi,
          refs,
          size(refs, 1),
          vals);
        annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_GetString_C
#define fmuSF1_outer_exp_hack77420503548182941207_GetString_C 1
#include <stdlib.h>
#include \"FMI/fmiImport.h\"
void fmuSF1_outer_exp_hack77420503548182941207_fmiGetString2(void*m, const int*refs, size_t nrefs, fmiString* vals) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if (a) {
    status=a->dyFmiGetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"StringInteger failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack");
      end fmiGetString;

      function fmiSetString
      input fmiModel fmi;
        input Integer refs[:];
        input String vals[size(refs, 1)];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetString2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetString_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetString_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetString2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetString;

      function fmiSetStringParam
      input fmiModel fmi;
        input Integer refs[:];
        input String vals[size(refs, 1)];
        external"C" fmuSF1_outer_exp_hack77420503548182941207_fmiSetStringParam2(
          fmi,
          refs,
          size(refs, 1),
          vals);
          annotation (Header="
#ifndef fmuSF1_outer_exp_hack77420503548182941207_SetStringParam_C
#define fmuSF1_outer_exp_hack77420503548182941207_SetStringParam_C 1
#include \"FMI/fmiImport.h\"
#include <stdlib.h>
void fmuSF1_outer_exp_hack77420503548182941207_fmiSetStringParam2(void*m, const int*refs, size_t nrefs, const fmiString vals[]) {
  struct dy_Extended*a=m;
  fmiStatus status=fmiFatal;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyInstantiationMode){
		status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    }else{
      status=fmiOK;
    }
  }
  if (status!=fmiOK && status!=fmiWarning) ModelicaError(\"SetString failed\");
}
#endif",   Library="fmuSF1_outer_exp_hack", LibraryDirectory=
              "modelica://ProsNet/Resources/Library/FMU/fmuSF1_outer_exp_hack_new/binaries",                                                                      __Dymola_CriticalRegion="fmuSF1_outer_exp_hack",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
      end fmiSetStringParam;

      function noHysteresis
        input Real x;
        output Real y;
      algorithm
        y:=x+(if (x < 0) then -1 else 1);
      end noHysteresis;
  end fmi_Functions;
  equation
    when initial() then
      fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn);
    end when;
    fmi_StepEvent = fmi_Functions.CompletedStep(fmi, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0))>0.5;
    der(fmi_x) = fmi_Functions.GetDerivatives(fmi, size(fmi_x, 1), myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    fmi_z  = fmi_Functions.GetEventIndicators(fmi, fmi_NumberOfEventIndicators, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
    for i in 1:size(fmi_z,1) loop
      fmi_z_positive[i] = fmi_Functions.noHysteresis(fmi_z[i]) > 0;
    end for;
    when cat(1, change(fmi_z_positive), {time>=pre(fmi_TNext), fmi_StepEvent, not initial()}) then
      (fmi_TNext, fmi_NewStates) =  fmi_Functions.EventUpdate(fmi, myTime, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump}, fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
      fmi_NewStates2 = if fmi_NewStates then not pre(fmi_NewStates2) else pre(fmi_NewStates2);
    end when;
    for i in 1:size(fmi_x,1) loop
      when {fmi_NewStates2, not fmi_NewStates2} then
        reinit(fmi_x[i], fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x,1))*{if i==j then 1 else 0 for j in 1:size(fmi_x,1)});
      end when;
    end for;
  algorithm
    fmi_Functions.fmiSetTime(fmi, time);
    myTime := time;
    fmi_Functions.fmiSetContinuousStates(fmi, fmi_x);
  initial algorithm
   // 0 Real parameters
   // 0 Real start values
   // 0 Integer parameters
   // 0 Integer start values
   // 0 Boolean parameters
   // 0 Boolean start values
   // 0 Enumeration parameters
   // 0 Enumeration start values
   // 0 String parameters
   // Set InitalInputs
  fmi_Functions.fmiSetReal(fmi, {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, {_CBIn_TSet_start, _CHPIn_P_start, _TDH_HEXout_start, _qvDHWpump_start, _qvDHpump_start, _qvSTpump_start});
    fmi_Functions.fmiSetTime(fmi, time);
    (fmi_TNext_Start,fmi_Initialized) :=fmi_Functions.fmiInitialize(fmi);
    fmi_x :=fmi_Functions.fmiGetContinuousStates(fmi, size(fmi_x, 1));
  equation
      qv_HEX =  fmi_Functions.GetOutput(fmi,myTime,{805306368}, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
      TDH_HEXin =  fmi_Functions.GetOutput(fmi,myTime,{805306369}, {CBIn_TSet, CHPIn_P, TDH_HEXout, qvDHWpump, qvDHpump, qvSTpump},fill(0,0), fill(false,0), {536870912, 536870913, 536870914, 536870917, 536870916, 536870915}, fill(0,0), fill(0,0));
  {dem_T_RL} = fmi_Functions.fmiGetReal(fmi, {805306370}, myTime);
    annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=0, StopTime=1, Tolerance=1e-06),
      Icon(graphics={
        Text(extent={{-150,150},{150,110}},
          lineColor={0,0,255},
          textString="%name"),
        Text(extent={{-150,-110},{150,-150}},
          lineColor={95,95,95},
          textString="FMI 1.0 ME")}),
  Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 1.0</li>
<li>modelName = fmuSF1_outer_exp_hack</li>
<li>generationTool = SimulationX 4.2.1.68046 (12/15/20)</li>
<li>generationDateAndTime = 2021-07-13T01:25:21</li>
</ul>
</html>"));
  end fmuSF1_outer_exp_hack_new_fmu;
end FMU;
