within ProsNet;
package BoundaryConditions "Package with models for boundary conditions"
  extends Modelica.Icons.Package;

  package UsersGuide "User's Guide"
    extends Modelica.Icons.Information;
  annotation (preferredView="info",
  Documentation(info="<html>
<p>This package contains models to read or compute boundary conditions, such as weather data, solar irradition and sky temperatures.
The calculations follow the description in Wetter (2004), Appendix A.4.2.</p>
<h4>Accessing weather data</h4>
<p>
The model
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>
can read TMY3 weather data for different locations.
The documentation of that model explains how to add
weather data for locations that are not distributed with the
<code>Buildings</code> library.
</p>
<p>
To access these weather data from the graphical model editor,
proceed as follows:
</p>
<ol>
<li>
<p>
Create an instance of
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</p>
</li>
<li>
<p>
Create an instance of
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.Bus\">
Buildings.BoundaryConditions.WeatherData.Bus</a>.
</p>
</li>
<li>
<p>
Draw a connection between these two instances.
</p>
</li>
<li>
<p>
Finally, to send weather data to an input connector of a model,
connect the input connector of that model with the instance of
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.Bus\">
Buildings.BoundaryConditions.WeatherData.Bus</a>.
Some models connect to the whole weather data bus, such as
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.Examples.IncidenceAngle\">
Buildings.BoundaryConditions.SolarGeometry.Examples.IncidenceAngle</a>,
in which case the connection will directly be drawn.
Other models require only an individual signal from the weather data bus,
such as
<a href=\"modelica://Buildings.BoundaryConditions.SkyTemperature.Examples.BlackBody\">
Buildings.BoundaryConditions.SkyTemperature.Examples.BlackBody</a>.
In this situation, Modelica modeling environments typically show a window that allows you to
select what data from this weather data bus you want to connect
with your model.
</p>
</li>
</ol>
<h4>Conventions for surface azimuth and tilt</h4>
<p>To compute the solar irradiation, parameters such as the surface azimuth and the surface tilt are defined as shown in the following three figures. </p>
<p align=\"center\"><img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/ear_ray.png\"/> </p>
<p align=\"center\"><img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/zen_sun.png\"/> </p>
<p align=\"center\"><img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/zen_pla.png\"/> </p>
<p>
For the surface azimuth and tilt, the enumerations
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>
and
<a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>
can be used.
</p>
<p>
Note that a ceiling has a tilt of <i>0</i>
, and also the solar collector models
in
<a href=\"modelica://Buildings.Fluid.SolarCollectors\">Buildings.Fluid.SolarCollectors</a>
require a tilt of <i>0</i>
if they are facing straight upwards.
This is correct because
the solar irradiation on a ceiling construction is on the other-side surface,
which faces upwards toward the sky. Hence, a construction is considered
a ceiling from the view point of a person standing inside a room.
</p>

<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>"));
  end UsersGuide;

  package SkyTemperature "Package with models to compute the sky temperature"
    extends Modelica.Icons.VariantsPackage;

    block BlackBody "Calculate black body sky temperature"
      extends Modelica.Blocks.Icons.Block;

      parameter ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.
           TemperaturesAndSkyCover "Computation of black-body sky temperature"
        annotation (choicesAllMatching=true, Evaluate=true);
      Modelica.Blocks.Interfaces.RealInput TDryBul(
        final quantity="ThermodynamicTemperature",
        final unit="K",
        displayUnit="degC") "Dry bulb temperature at ground level"
        annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
      Modelica.Blocks.Interfaces.RealInput TDewPoi(
        final quantity="ThermodynamicTemperature",
        final unit="K",
        displayUnit="degC") "Dew point temperature"
        annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
      Modelica.Blocks.Interfaces.RealInput nOpa( min=0, max=1, unit="1")
        "Opaque sky cover [0, 1]"
        annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
      Modelica.Blocks.Interfaces.RealOutput TBlaSky(
        final quantity="ThermodynamicTemperature",
        displayUnit="degC",
        final unit="K") "Black-body sky temperature"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      Modelica.Blocks.Interfaces.RealInput HHorIR(
        unit="W/m2",
        min=0,
        nominal=100) "Horizontal infrared irradiation"
        annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
    protected
      Modelica.Units.SI.Temperature TDewPoiK "Dewpoint temperature";
      Modelica.Units.SI.Emissivity epsSky "Black-body absorptivity of sky";
      Real nOpa10(min=0, max=10) "Opaque sky cover in [0, 10]";
    equation
      if calTSky == ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
        TDewPoiK =  Buildings.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
        nOpa10 =  10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
        epsSky =  (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
          0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
        TBlaSky =  TDryBul*(epsSky^0.25);
      else
        TDewPoiK =  273.15;
        nOpa10   =  0.0;
        epsSky   =  0.0;
        TBlaSky  =  (HHorIR/Modelica.Constants.sigma)^0.25;
      end if;
      annotation (
        defaultComponentName="TBlaSky",
        Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation.
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 3, 2017, by Michael Wetter:<br/>
Removed <code>import</code> statement.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/852\">#852</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed unit and comment of input <code>nOpa</code> for correct display of units
in <code>weaBus</code> and input <code>radHorIR</code> to <code>HHorIR</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code>.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br/>
Added types for parameters and attributes for variables.
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br/>
Use <code>smoothMin()</code> instead of <code>min()</code>.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255}),
            Text(
              extent={{-50,44},{56,-40}},
              textColor={0,0,255},
              textString="T"),
            Text(
              extent={{-96,84},{-66,74}},
              textColor={0,0,127},
              textString="TDry"),
            Text(
              extent={{-90,36},{-66,24}},
              textColor={0,0,127},
              textString="TDewPoi"),
            Text(
              extent={{-92,-74},{-62,-88}},
              textColor={0,0,127},
              textString="radHorIR"),
            Text(
              extent={{16,-6},{54,-28}},
              textColor={0,0,255},
              textString="bs"),
            Text(
              extent={{-88,-24},{-64,-36}},
              textColor={0,0,127},
              textString="nOpa")}));
    end BlackBody;

    package Examples "Collection of models that illustrate model use and test models"
      extends Modelica.Icons.ExamplesPackage;

      model BlackBody "Test model for black body sky temperature"
        extends Modelica.Icons.Example;

        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
        ProsNet.BoundaryConditions.SkyTemperature.BlackBody TBlaSky
          "Black body sky temperature computed from temperature and sky cover"
          annotation (Placement(transformation(extent={{40,20},{60,40}})));
        ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather data bus"
          annotation (Placement(transformation(extent={{0,0},{20,20}}),
              iconTransformation(extent={{0,0},{2,2}})));
        ProsNet.BoundaryConditions.SkyTemperature.BlackBody TBlaSkyIrr(calTSky=
              ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.HorizontalRadiation)
          "Black body sky temperature computation compued from horizontal infrared radiation"
          annotation (Placement(transformation(extent={{40,-20},{60,0}})));
      equation

        connect(weaBus, weaDat.weaBus) annotation (Line(
            points={{10,10},{-20,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.TDewPoi, TBlaSky.TDewPoi) annotation (Line(
            points={{10,10},{24,10},{24,33},{38,33}},
            color={255,204,51},
            thickness=0.5));
        connect(weaBus.nOpa, TBlaSky.nOpa) annotation (Line(
            points={{10,10},{24,10},{24,27},{38,27}},
            color={255,204,51},
            thickness=0.5));

        connect(weaBus.TDryBul, TBlaSky.TDryBul) annotation (Line(
            points={{10,10},{24,10},{24,38},{38,38}},
            color={255,204,51},
            thickness=0.5));
        connect(weaBus.HHorIR, TBlaSky.HHorIR) annotation (Line(
            points={{10,10},{24,10},{24,22},{38,22}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus.TDewPoi, TBlaSkyIrr.TDewPoi) annotation (Line(
            points={{10,10},{24,10},{24,-7},{38,-7}},
            color={255,204,51},
            thickness=0.5));
        connect(weaBus.nOpa, TBlaSkyIrr.nOpa) annotation (Line(
            points={{10,10},{24,10},{24,-13},{38,-13}},
            color={255,204,51},
            thickness=0.5));
        connect(weaBus.TDryBul, TBlaSkyIrr.TDryBul) annotation (Line(
            points={{10,10},{24,10},{24,-2},{38,-2}},
            color={255,204,51},
            thickness=0.5));
        connect(weaBus.HHorIR, TBlaSkyIrr.HHorIR) annotation (Line(
            points={{10,10},{24,10},{24,-18},{38,-18}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
        Documentation(info="<html>
<p>
This example computes the black-body sky temperature
for Chicago.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 18, 2017, by Filip Jorissen:<br/>
Now computing both options of <code>TBlaSky</code>.
This verifies the consistency of the two computation methods.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/648\">#648</a>.
</li>
<li>
January 7, 2016, by Michael Wetter:<br/>
Changed <code>connect</code> statement for infrared radiation due renaming of the
variable. This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">issue 376</a>.
Added comments.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
      experiment(Tolerance=1e-6, StartTime=0, StopTime=86400),
          __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SkyTemperature/Examples/BlackBody.mos"
              "Simulate and plot"));
      end BlackBody;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.SkyTemperature\">
Buildings.BoundaryConditions.SkyTemperature</a>.
</p>
</html>"));
    end Examples;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
  end SkyTemperature;

  package SolarGeometry "Package with models to compute solar geometry"
    extends Modelica.Icons.VariantsPackage;

    block IncidenceAngle "Solar incidence angle on a tilted surface"
      extends Modelica.Blocks.Icons.Block;
      parameter Modelica.Units.SI.Angle azi "Surface azimuth";
      parameter Modelica.Units.SI.Angle til "Surface tilt";

      Modelica.Blocks.Interfaces.RealOutput y(
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg") "Incidence angle" annotation (Placement(transformation(
              extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{
                120,10}})));
      WeatherData.Bus weaBus "Weather data"
        annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
    protected
      ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
        "Declination angle"
        annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
      ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle solHouAng
        "Solar hour angle"
        annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));
      ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.IncidenceAngle incAng(final azi
          =azi, final til=til) "Incidence angle"
        annotation (Placement(transformation(extent={{40,-10},{60,10}})));
    equation
      connect(incAng.incAng, y) annotation (Line(
          points={{61,0},{88.25,0},{88.25,1.16573e-015},{95.5,1.16573e-015},{95.5,0},
              {110,0}},
          color={0,0,127}));
      connect(decAng.decAng, incAng.decAng) annotation (Line(
          points={{-19,40},{20,40},{20,5.4},{37.8,5.4}},
          color={0,0,127}));
      connect(solHouAng.solHouAng, incAng.solHouAng) annotation (Line(
          points={{-19,-40},{20,-40},{20,-4.8},{38,-4.8}},
          color={0,0,127}));
      connect(weaBus.cloTim, decAng.nDay) annotation (Line(
          points={{-100,0},{-80,0},{-80,40},{-42,40}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
          points={{-100,0},{-80,0},{-80,-40},{-42,-40}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.lat, incAng.lat) annotation (Line(
          points={{-100,0},{38,0}},
          color={255,204,51},
          thickness=0.5), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));
      annotation (
        defaultComponentName="incAng",
        Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface.
For a definition of the parameters, see the User's Guide
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">Buildings.BoundaryConditions.UsersGuide</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
November 30, 2011, by Michael Wetter:<br/>
Removed <code>connect(y, y)</code> statement.
</li>
<li>
February 28, 2011, by Wangda Zuo:<br/>
Use local civil time instead of clock time.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255}), Bitmap(extent={{-90,-90},{90,90}}, fileName=
                  "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png")}));
    end IncidenceAngle;

    block ProjectedShadowLength "Length of shadow projected onto a direction"
      extends Modelica.Blocks.Icons.Block;

      parameter String filNam=""
        "Name of weather data file (used to read longitude, latitude and time zone)"
        annotation (Dialog(
            loadSelector(filter="Weather files (*.mos)",
            caption="Select weather file"),
            group="Location"));

      parameter Modelica.Units.SI.Angle lon(displayUnit="deg") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
        absFilNam) "Longitude" annotation (Evaluate=true, Dialog(group="Location"));
      parameter Modelica.Units.SI.Angle lat(displayUnit="deg") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(
        absFilNam) "Latitude" annotation (Evaluate=true, Dialog(group="Location"));
      parameter Modelica.Units.SI.Time timZon(displayUnit="h") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(
        absFilNam) "Time zone" annotation (Evaluate=true, Dialog(group="Location"));

      parameter Modelica.Units.SI.Length h "Height of surface";
      parameter Modelica.Units.SI.Angle azi "Surface azimuth";

      Modelica.Blocks.Interfaces.RealOutput y(
        final quantity="Length",
        final unit="m") "Projected shadow length"
        annotation (Placement(transformation(extent={{180,-10},{200,10}}),
            iconTransformation(extent={{100,-10},{120,10}})));

    protected
      final parameter String absFilNam = ProsNet.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath(  filNam)
        "Absolute path of the file";

      WeatherData.BaseClasses.LocalCivilTime locTim(
          final lon=lon, final timZon=timZon) "Local civil time"
        annotation (Placement(transformation(extent={{-20,90},{0,110}})));
      WeatherData.BaseClasses.EquationOfTime eqnTim "Equation of time"
        annotation (Placement(transformation(extent={{-20,130},{0,150}})));
      WeatherData.BaseClasses.SolarTime solTim "Solar time"
        annotation (Placement(transformation(extent={{20,110},{40,130}})));
      Buildings.Utilities.Time.ModelTime modTim "Model time"
        annotation (Placement(transformation(extent={{-160,-10},{-140,10}})));
       BaseClasses.Declination decAng "Declination angle"
        annotation (Placement(transformation(extent={{-120,-60},{-100,-40}})));

      ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle zen(final lat
          =lat) "Solar zenith angle"
        annotation (Placement(transformation(extent={{-70,-90},{-50,-70}})));
      Modelica.Blocks.Math.Tan tan "Tangent of solar zenith angle"
        annotation (Placement(transformation(extent={{-30,-90},{-10,-70}})));
      Modelica.Blocks.Math.Gain shaLen(k=-h) "Length of shadow"
        annotation (Placement(transformation(extent={{0,-90},{20,-70}})));
      BaseClasses.SolarAzimuth solAzi(
        final lat=lat) "Solar azimuth"
        annotation (Placement(transformation(extent={{-30,-60},{-10,-40}})));
      Modelica.Blocks.Sources.Constant surAzi(final k=azi) "Surface azimuth"
        annotation (Placement(transformation(extent={{-30,-20},{-10,0}})));
      Modelica.Blocks.Math.Add add(
        final k1=1,
        final k2=-1) "Angle between surface azimuth and solar azimuth"
        annotation (Placement(transformation(extent={{10,-40},{30,-20}})));
      Modelica.Blocks.Math.Cos cos "Cosine"
        annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
      Modelica.Blocks.Math.Product proShaLen "Projected shadow length"
        annotation (Placement(transformation(extent={{70,-90},{90,-70}})));

      BaseClasses.SolarHourAngle solHouAng "Solar hour angle"
        annotation (Placement(transformation(extent={{60,110},{80,130}})));

      Modelica.Blocks.Sources.RealExpression pShaLen(
        y=noEvent(if abs(zen.zen) < 0.5*Modelica.Constants.pi then proShaLen.y else 0.0))
        "Projected shadow length"
        annotation (Placement(transformation(extent={{102,-10},{122,10}})));
    equation
      connect(tan.u, zen.zen)
        annotation (Line(points={{-32,-80},{-32,-80},{-49,-80}},
                         color={0,0,127}));
      connect(tan.y, shaLen.u)
        annotation (Line(points={{-9,-80},{-9,-80},{-2,-80}},
                         color={0,0,127}));
      connect(solAzi.zen, zen.zen) annotation (Line(points={{-32,-44},{-40,-44},{-40,
              -80},{-49,-80}},
                        color={0,0,127}));
      connect(add.u1, surAzi.y)
        annotation (Line(points={{8,-24},{0,-24},{0,-10},{-9,-10}},
                         color={0,0,127}));
      connect(solAzi.solAzi, add.u2)
        annotation (Line(points={{-9,-50},{0,-50},{0,-36},{8,-36}},
                         color={0,0,127}));
      connect(add.y, cos.u)
        annotation (Line(points={{31,-30},{38,-30}},
                         color={0,0,127}));
      connect(shaLen.y, proShaLen.u2)
        annotation (Line(points={{21,-80},{40,-80},{40,-86},{68,-86}},
                         color={0,0,127}));
      connect(proShaLen.u1, cos.y)
        annotation (Line(points={{68,-74},{64,-74},{64,-60},{64,-60},{64,-30},{61,-30}},
                         color={0,0,127}));
      connect(solHouAng.solHouAng, zen.solHouAng) annotation (Line(points={{81,120},
              {100,120},{100,80},{-80,80},{-80,-84},{-72,-84},{-72,-84.8}},
                         color={0,0,127}));
      connect(modTim.y,locTim. cloTim) annotation (Line(
          points={{-139,0},{-50,0},{-50,100},{-22,100}},
          color={0,0,127}));
      connect(modTim.y,eqnTim. nDay) annotation (Line(
          points={{-139,0},{-128,0},{-128,140},{-22,140}},
          color={0,0,127}));
      connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(points={{1,140},{12,140},
              {12,126},{18,126}}, color={0,0,127}));
      connect(locTim.locTim, solTim.locTim) annotation (Line(points={{1,100},{12,100},
              {12,114.6},{18,114.6}}, color={0,0,127}));
      connect(solHouAng.solTim, solTim.solTim)
        annotation (Line(points={{58,120},{56,120},{41,120}}, color={0,0,127}));
      connect(decAng.nDay, modTim.y) annotation (Line(points={{-122,-50},{-128,-50},
              {-128,60},{-128,0},{-139,0}},
                                          color={0,0,127}));
      connect(zen.decAng, decAng.decAng) annotation (Line(points={{-72,-74.6},{-88,-74.6},
              {-88,-50},{-99,-50}},
                                  color={0,0,127}));
      connect(solAzi.decAng, decAng.decAng) annotation (Line(points={{-32,-50},{-88,
              -50},{-99,-50}},         color={0,0,127}));
      connect(solAzi.solTim, solTim.solTim) annotation (Line(points={{-32,-56},{-42,
              -56},{-74,-56},{-74,72},{48,72},{48,120},{41,120}}, color={0,0,127}));
      connect(pShaLen.y, y)
        annotation (Line(points={{123,0},{190,0}}, color={0,0,127}));
      annotation (
        defaultComponentName="proShaLen",
        Documentation(info="<html>
<p>
This component computes the length of a shadow projected onto a horizontal plane
into the direction that is perpendicular to the surface azimuth <code>azi</code>.
</p>
<p>
The parameter <code>azi</code> is the azimuth of the surface that is perpendicular
to the direction of the view. For example, if
<code>azi=Buildings.Types.Azimuth.S</code>,
then one is looking towards South. Hence, in the Northern hemisphere, at
noon, the length of the shadow is <em>negative</em> as one is looking
towards South but the shadow is in ones back.
Similarly, for
<code>azi=Buildings.Types.Azimuth.E</code>, there is a shade of negative length
in the morning, and of positive length in the afternoon.
The example
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.Examples.ProjectedShadowLength\">
Buildings.BoundaryConditions.SolarGeometry.Examples.ProjectedShadowLength</a>
illustrates this.
</p>
<p>
For a definition of the parameters, see the User's Guide
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">
Buildings.BoundaryConditions.UsersGuide</a>.
The surface azimuth is defined in
<a href=\"modelica://Buildings.Types.Azimuth\">
Buildings.Types.Azimuth</a>.
</p>
<p>
The component requires as parameters the longitude, latitude and time zone.
These can automatically be assigned by setting the parameter <code>filNam</code>
to a weather data file, in which case these values are read from the weather data file.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 20, 2016, by Thierry S. Nouidui:<br/>
Refactored the model and added a <code>realExpression</code> with <code>noEvent()</code>
to avoid spikes in the trajectory.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/626\">Buildings, #626</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Introduced <code>absFilNam</code> to avoid multiple calls to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Set <code>Evaluate=true</code> for parameters <code>lon</code>,
<code>lat</code> and <code>timZon</code>.
This is required for OpenModelica to avoid a compilation error in
<code>Buildings.BoundaryConditions.SolarGeometry.Examples.ProjectedShadowLength</code>.
</li>
<li>
November 14, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
            graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Solid,
              fillColor={240,240,240}),
                                  Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255}),
            Polygon(
              points={{-50,-34},{38,6},{36,66},{-52,36},{-50,-34}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={0,0,0}),
            Polygon(
              points={{-50,-34},{38,6},{76,-4},{-4,-46},{-50,-34}},
              lineColor={175,175,175},
              fillPattern=FillPattern.Sphere,
              fillColor={175,175,175}),
            Line(points={{-90,100},{-4,-44}}, color={255,255,0}),
            Line(points={{-74,100},{8,-40}}, color={255,255,0}),
            Line(points={{-60,100},{20,-34}}, color={255,255,0}),
            Line(points={{-44,100},{32,-28}}, color={255,255,0}),
            Line(points={{-30,100},{44,-22}}, color={255,255,0}),
            Line(points={{-14,100},{54,-16}}, color={255,255,0}),
            Line(points={{2,100},{66,-10}}, color={255,255,0}),
            Line(points={{16,100},{76,-4}}, color={255,255,0})}),
        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-180,-160},{180,
                160}})));
    end ProjectedShadowLength;

    block ZenithAngle "Zenith angle"
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealOutput y(
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg") "Zenith angle"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      WeatherData.Bus weaBus "Weather data"
        annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
    protected
       ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle zen
        annotation (Placement(transformation(extent={{0,-10},{20,10}})));
    equation
      connect(zen.zen, y) annotation (Line(
          points={{21,0},{88.25,0},{88.25,0},{95.5,
              0},{95.5,0},{110,0}},
          color={0,0,127}));
      connect(weaBus.solDec, zen.decAng) annotation (Line(
          points={{-100,0},{-40,0},{-40,5.4},{-2,5.4}},
          color={255,204,51},
          thickness=0.5));
      connect(weaBus.solHouAng, zen.solHouAng) annotation (Line(
          points={{-100,0},{-40,0},{-40,-4.8},{-2,-4.8}},
          color={255,204,51},
          thickness=0.5));
      connect(weaBus.lat, zen.lat) annotation (Line(
          points={{-100,0},{-2,0}},
          color={255,204,51},
          thickness=0.5), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));
      annotation (
        defaultComponentName="zen",
        Documentation(info="<html>
<p>
This component computes the zenith angle,
which is the angle between the earth surface normal and the sun beam.
For a definition of the parameters, see the User's Guide
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">
Buildings.BoundaryConditions.UsersGuide</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Changed model to get declination angle and
solar hour angle from weather bus.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255}), Bitmap(extent={{-90,-90},{90,90}}, fileName=
                  "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png")}));
    end ZenithAngle;

    package Examples "Collection of models that illustrate model use and test models"
      extends Modelica.Icons.ExamplesPackage;

      model IncidenceAngle "Test model for solar incidence angle"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.SolarGeometry.IncidenceAngle incAngHor(til=
              Buildings.Types.Tilt.Ceiling, azi=0.3)
          "Incidence angle on horizontal surface"
          annotation (Placement(transformation(extent={{0,70},{20,90}})));
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          "Weather data (Chicago)"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        ProsNet.BoundaryConditions.SolarGeometry.IncidenceAngle incAngNor(azi=
              Buildings.Types.Azimuth.N, til=Buildings.Types.Tilt.Wall)
          "Incidence angle on North-facing surface"
          annotation (Placement(transformation(extent={{0,30},{20,50}})));
        ProsNet.BoundaryConditions.SolarGeometry.IncidenceAngle incAngWes(azi=
              Buildings.Types.Azimuth.W, til=Buildings.Types.Tilt.Wall)
          "Incidence angle on West-facing surface"
          annotation (Placement(transformation(extent={{0,-10},{20,10}})));
        ProsNet.BoundaryConditions.SolarGeometry.IncidenceAngle incAngSou(azi=
              Buildings.Types.Azimuth.S, til=Buildings.Types.Tilt.Wall)
          "Incidence angle on South-facing surface"
          annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
        ProsNet.BoundaryConditions.SolarGeometry.IncidenceAngle incAngEas(azi=
              Buildings.Types.Azimuth.E, til=Buildings.Types.Tilt.Wall)
          "Incidence angle on East-facing surface"
          annotation (Placement(transformation(extent={{0,-90},{20,-70}})));
      equation
        connect(weaDat.weaBus, incAngHor.weaBus) annotation (Line(
            points={{-40,0},{-20,0},{-20,80},{0,80}},
            color={255,204,51},
            thickness=0.5));
        connect(incAngNor.weaBus, weaDat.weaBus) annotation (Line(
            points={{0,40},{-20,40},{-20,0},{-40,0}},
            color={255,204,51},
            thickness=0.5));
        connect(incAngWes.weaBus, weaDat.weaBus) annotation (Line(
            points={{0,0},{-40,0}},
            color={255,204,51},
            thickness=0.5));
        connect(incAngSou.weaBus, weaDat.weaBus) annotation (Line(
            points={{0,-40},{-20,-40},{-20,0},{-40,0}},
            color={255,204,51},
            thickness=0.5));
        connect(incAngEas.weaBus, weaDat.weaBus) annotation (Line(
            points={{0,-80},{-20,-80},{-20,0},{-40,0}},
            color={255,204,51},
            thickness=0.5));
        annotation (
        Documentation(info="<html>
<p>
This example computes the solar incidence angle on tilted surfaces.
There are fives surfaces, a horizontal surface and a surface
that faces Norths, East, South and West.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 24, 2015, by Michael Wetter:<br/>
Assigned azimuth and tilt using the types from
<a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>.
</li>
<li>
January 16, 2015, by Michael Wetter:<br/>
Added surfaces for each orientation.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
      experiment(Tolerance=1e-6, StopTime=86400),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/Examples/IncidenceAngle.mos"
              "Simulate and plot"));
      end IncidenceAngle;

      model ProjectedShadowLength "Test model for projected shadow length"
        extends Modelica.Icons.Example;
        parameter Modelica.Units.SI.Length h=2 "Height of object";
        ProsNet.BoundaryConditions.SolarGeometry.ProjectedShadowLength proShaLenEas(
          azi=Buildings.Types.Azimuth.E,
          h=h,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          "Projected shadow length facing east"
          annotation (Placement(transformation(extent={{-10,60},{10,80}})));
        ProsNet.BoundaryConditions.SolarGeometry.ProjectedShadowLength proShaLenSou(
          azi=Buildings.Types.Azimuth.S,
          h=h,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          "Projected shadow length facing south"
          annotation (Placement(transformation(extent={{-10,20},{10,40}})));
        ProsNet.BoundaryConditions.SolarGeometry.ProjectedShadowLength proShaLenWes(
          azi=Buildings.Types.Azimuth.W,
          h=h,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          "Projected shadow length facing West"
          annotation (Placement(transformation(extent={{-10,-40},{10,-20}})));
        ProsNet.BoundaryConditions.SolarGeometry.ProjectedShadowLength proShaLenNor(
          azi=Buildings.Types.Azimuth.N,
          h=h,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          "Projected shadow length facing North"
          annotation (Placement(transformation(extent={{-10,-80},{10,-60}})));
        annotation (
        Documentation(info="<html>
<p>
This example computes how far a shadow of a <i>2</i> meter high
object is in different directions.
The figure below shows this length for January 1 in Chicago.
Note that the length of the shadow is <em>negative</em>
if the azimuth is selected to be south because the shadow
is towards the north.
</p>
<p align=\"center\">
<img alt=\"Simulation results\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/Examples/ProjectedShadowLength.png\" border=\"1\" />
</p>
</html>",       revisions="<html>
<ul>
<li>
November 14, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
      experiment(StartTime=0, Tolerance=1e-6, StopTime=86400),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/Examples/ProjectedShadowLength.mos"
              "Simulate and plot"));
      end ProjectedShadowLength;

      model ZenithAngle "Test model for zenith angle"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.SolarGeometry.ZenithAngle zen "Zenith angle"
          annotation (Placement(transformation(extent={{20,0},{40,20}})));
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
      equation
        connect(weaDat.weaBus, zen.weaBus) annotation (Line(
            points={{-20,10},{20,10}},
            color={255,204,51},
            thickness=0.5));
        annotation (
        Documentation(info="<html>
<p>
This example computes the zenith angle,
which is the angle between the earth surface normal and the sun beam.
</p>
</html>",       revisions="<html>
<ul>
<li>
February 25, 2012, by Michael Wetter:<br/>
Changed model to get declination angle and
solar hour angle from weather bus.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(StartTime=100000, Tolerance=1e-6, StopTime=300000),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/Examples/ZenithAngle.mos"
              "Simulate and plot"));
      end ZenithAngle;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry\">
Buildings.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
    end Examples;

    package BaseClasses "Package with base classes for Buildings.BoundaryConditions.SolarGeometry"
      extends Modelica.Icons.BasesPackage;

      block AltitudeAngle "Solar altitude angle"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
          "Zenith angle"
      annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput alt(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Solar altitude angle"
      annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        alt = (Modelica.Constants.pi/2) - zen;
        annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/AltitudeAngle.png")}),
          defaultComponentName="altAng", Documentation(info="<html>
<p>
This block computes the altitude angle of the sun with respect to a horizontal surface.
The altitude angle is the angle between the sun ray and the projection of the ray
on a horizontal surface.
It is the complementory angle to the zenith angle.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the output connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
      end AltitudeAngle;

      block Declination "Declination angle"
        extends
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.PartialConvertTime;
        Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
          "Day number with units of seconds"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput decAng(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Solar declination angle"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
        constant Real k1 = sin(23.45*2*Modelica.Constants.pi/360) "Constant";
        constant Real k2 = 2*Modelica.Constants.pi/365.25 "Constant";
      equation
        modTimAux = nDay;
        decAng = Modelica.Math.asin(-k1 * Modelica.Math.cos((calTimAux/86400 + 10)*k2))
          "(A4.5)";
        annotation (
          defaultComponentName="decAng",
          Documentation(info="<html>
<p>
This component computes the solar declination, which is
the angle between the equatorial plane and the solar beam.
The input signal <code>nDay</code> is the one-based number of the day, but in seconds.
Hence, during January 1, we should have <code>nDay = 86400</code> seconds.
Since the effect of using a continuous number rather than an integer is small,
we approximate this so that <code>nDay = 0</code> at the start of January 1,
and <code>nDay = 86400</code> at the end of January 1.
</p>
<h4>Validation</h4>
<p>
A validation with a more detailed calculation can be found at
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Updated documentation and added validation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/382\">issue 382</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of output signal as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
November 11, 2015, by Michael Wetter:<br/>
Corrected typo in documentation.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/Declination.png"),
                                    Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255})}));
      end Declination;

      block IncidenceAngle "The solar incidence angle on a tilted surface"
        extends Modelica.Blocks.Icons.Block;
        parameter Modelica.Units.SI.Angle azi(displayUnit="deg")
          "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south";
        parameter Modelica.Units.SI.Angle til(displayUnit="deg")
          "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof";
        Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
          "Solar hour angle"
          annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
        Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
          "Declination"
          annotation (Placement(transformation(extent={{-142,34},{-102,74}})));
        Modelica.Blocks.Interfaces.RealOutput incAng(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Incidence angle on a tilted surface"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput lat(quantity="Angle",
          unit="rad",
          displayUnit="deg")
          "Latitude"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
      protected
        Real dec_c=Modelica.Math.cos(decAng) "Cosine of declination angle";
        Real dec_s=Modelica.Math.sin(decAng) "Sine of declination angle";
        Real sol_c=Modelica.Math.cos(solHouAng) "Cosine of solar hour angle";
        Real sol_s=Modelica.Math.sin(solHouAng) "Sine of solar hour angle";
        Real lat_c=Modelica.Math.cos(lat) "Cosine of latitude";
        Real lat_s=Modelica.Math.sin(lat) "Sine of latitude";
      equation
        incAng = Modelica.Math.acos(Modelica.Math.cos(til)*(dec_c*sol_c*lat_c + dec_s
          *lat_s) + Modelica.Math.sin(til)*(Modelica.Math.sin(azi)*dec_c*sol_s +
          Modelica.Math.cos(azi)*(dec_c*sol_c*lat_s - dec_s*lat_c))) "(A.4.13)";
        annotation (
          defaultComponentName="incAng",
          Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface using the solar hour angle and the declination angle as input.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png"),
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-98,60},{-56,50}},
                textColor={0,0,127},
                textString="decAng"),
              Text(
                extent={{-98,-42},{-42,-54}},
                textColor={0,0,127},
                textString="solHouAng")}));
      end IncidenceAngle;

      block SolarAzimuth "Solar azimuth"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
          "Zenith angle"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}}),
              iconTransformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
          "Solar time" annotation (Placement(transformation(extent={{-140,-60},{-100,
                  -20}}), iconTransformation(extent={{-140,-60},{-100,-20}})));
        Modelica.Blocks.Interfaces.RealInput lat(quantity="Angle", unit="rad")
          "Latitude" annotation (Placement(transformation(extent={{-140,-100},{-100,
                  -60}}), iconTransformation(extent={{-140,-100},{-100,-60}})));
        Modelica.Blocks.Interfaces.RealOutput solAzi(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Solar Azimuth"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
          "Declination angle"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
              iconTransformation(extent={{-140,18},{-100,58}})));

      protected
        Real arg "cos(solAzi) after data validity check";
        Real tmp "cos(solAzi) before data validity check";
        Real solAziTem "Temporary variable for solar azimuth";

        constant Modelica.Units.SI.Time day=86400 "Number of seconds in a day";
        constant Modelica.Units.SI.Angle polarCircle=1.1617
          "Latitude of polar circle (66 degree 33 min 44 sec)";
        Boolean outsidePolarCircle = lat < polarCircle and lat > -polarCircle
          "Flag, true if latitude is outside polar region";
      equation
        tmp = (Modelica.Math.sin(lat)*Modelica.Math.cos(zen) - Modelica.Math.sin(
          decAng))/(Modelica.Math.cos(lat)*Modelica.Math.sin(zen));
        arg = min(1.0, max(-1.0, tmp));

        solAziTem =  Modelica.Math.acos(arg); // Solar azimuth (A4.9a and b) as a positive number

        // If outside the polar circle, the only non-differentiability is at night when the sun is set.
        // Hence, we use noEvent.
        // If inside the polar circle, there is a jump at (solar-)midnight when the sun can
        // be above the horizon. Hence, we do not use noEvent(...)
        // Written as one line with functions so that lat does not become structural parameter with JModelica.org
        solAzi = if outsidePolarCircle then solarAzimuthNoEvent(solAziTem, solTim, day) else solarAzimuthWithEvent(solAziTem, solTim, day);

        annotation (
          defaultComponentName="solAzi",
          Documentation(info="<html>
<p>
This component computes the solar azimuth angle.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 16, 2021, by Michael Wetter:<br/>
Removed parameter <code>lat</code> and added an input connector for this quantity.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
June 9, 2020, by David Blum:<br/>
Reformulated to use one-line if-statements.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1373\">issue 1373</a>.
</li>
<li>
October 13, 2017, by Michael Wetter:<br/>
Reformulated to use equation rather than algorithm section.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/834\">issue 834</a>.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed model to avoid an event at solar noon.
</li>
<li>
February 28, 2012, by Wangda Zuo:<br/>
Add solar time conversion since it is removed from <code>solTim</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarAzimuth.png"),
                                    Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-102,84},{-60,74}},
                textColor={0,0,127},
                textString="zen"),
              Text(
                extent={{-96,-36},{-54,-46}},
                textColor={0,0,127},
                textString="solTim"),
              Text(
                extent={{-96,24},{-54,14}},
                textColor={0,0,127},
                textString="decAng"),
              Text(
                extent={{-96,-86},{-54,-96}},
                textColor={0,0,127},
                textString="lat")}));
      end SolarAzimuth;

      block SolarHourAngle "Solar hour angle"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
          "Solar time"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput solHouAng(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Solar hour angle"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
          "Our unit is s instead of h in (A4.6)";
        annotation (
          defaultComponentName="solHouAng",
          Documentation(info="<html>
<p>
This component computes the solar hour angle,
which is defined as the angle between the circle
that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarHourAngle.png"),
                                    Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255})}));
      end SolarHourAngle;

      block WallSolarAzimuth
        "Angle measured in a horizontal plane between the projection of the sun's rays and the normal to a vertical surface"
        extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealInput incAng(quantity="Angle",
                                                    unit="rad",
                                                    displayUnit="rad")
          "Solar incidence angle"
          annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
        Modelica.Blocks.Interfaces.RealInput alt(quantity="Angle",
                                               unit="rad",
                                               displayUnit="rad")
          "Solar altitude angle (angle between sun ray and horizontal surface)"
          annotation (Placement(transformation(extent={{-140,28},{-100,68}})));
        Modelica.Blocks.Interfaces.RealOutput verAzi(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg")
          "Angle between projection of sun's rays and normal to vertical surface"
      annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
        constant Modelica.Units.SI.Angle delta=1*Modelica.Constants.pi/180
          "Small angle";
        constant Modelica.Units.SI.Angle ninety=Modelica.Constants.pi/2 - delta
          "+89 degree";
        constant Real deltaX = 1E-4 "Small number used for smoothing";
        Real alt_c "Cosine of altitude, bounded away from zero";
        Real rat "Ratio of cosines";
      equation
        alt_c=Modelica.Math.cos(Buildings.Utilities.Math.Functions.smoothLimit(
              x=alt, l=-ninety, u=ninety, deltaX=delta));
        rat = Modelica.Math.cos(incAng)/alt_c;
        // Due to the smoothLimit, rat can be about 1E-3 greater than 1 or smaller than -1.
        // Hence, below we use another call to smoothLimit to ensure that the argument of
        // acos(.) is inside the interval [-1, 1].
        verAzi=Modelica.Math.acos(
             Buildings.Utilities.Math.Functions.smoothLimit(x=rat, l=-1+deltaX, u=1-deltaX, deltaX=deltaX/10));

        annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/WallSolarAzimuth.png")}),
      defaultComponentName="wallSolAzi",
      Documentation(info="<html>
<p>
This block computes the wall solar azimuth angle.
It is the angle between the projection of the sun ray on a horizontal surface
and the line perpendicular to the wall. The value of this angle varies from <i>0</i> to <i>180</i> degrees.
In the northern hemisphere at solar noon, the value of the wall solar azimuth angle is zero if the wall is facing south.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 5, 2012, by Michael Wetter:<br/>
Decreased <code>deltaX</code> from <i>1e-3</i> to <i>1e-4</i>, as
the looser tolerance gives sharp changes in
<a href=\"modelica://Buildings.HeatTransfer.Windows.BaseClasses.Examples.Overhang\">
Buildings.HeatTransfer.Windows.BaseClasses.Examples.Overhang</a>.
</li>
<li>
February 23, 2012, by Michael Wetter:<br/>
Guarded against division by zero because the altitude angle can be <i>90</i> degree
in the tropics, and hence its cosine can take on zero.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak<br/>
First implementation.
</li>
</ul>
</html>"));
      end WallSolarAzimuth;

      block ZenithAngle "Zenith angle"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
          "Solar hour angle"
          annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
        Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
          "Solar declination angle"
          annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
              iconTransformation(extent={{-140,34},{-100,74}})));
        Modelica.Blocks.Interfaces.RealOutput zen(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Zenith angle"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput lat(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Latitude"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
              iconTransformation(extent={{-140,-20},{-100,20}})));
      equation
        zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
          Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
          decAng)) "(A4.8)";
        annotation (
          defaultComponentName="zen",
          Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
Input are the solar hour angle and the declination angle.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the input connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Bitmap(extent={{-86,-88},{94,92}}, fileName=
                    "modelica://Buildings/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png"),
                                    Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-98,62},{-46,46}},
                textColor={0,0,127},
                textString="decAng"),
              Text(
                extent={{-98,-40},{-22,-58}},
                textColor={0,0,127},
                textString="solHouAng")}));
      end ZenithAngle;

      function solarAzimuthNoEvent "Determines solar azimuth with no event"
        input Real solAziTem(quantity="Angle",unit="rad",displayUnit="deg") "Temporary solar azimuth";
        input Real solTim(quantity="Time", unit="s") "Solar time";
        input Real day(quantity="Time", unit="s") "Number of seconds in day";
        output Real solAzi(quantity="Angle",unit="rad",displayUnit="deg") "Solar azimuth";
      algorithm
        if noEvent(solTim - integer(solTim/day)*day<43200) then
          solAzi := -solAziTem;
        else
          solAzi := solAziTem;
        end if;

        annotation (
          Documentation(info="<html>
<p>
This function is used within
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth</a> 
to calculate solar azimuth with no events.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 9, 2020 by David Blum:<br/>
Initial implementation.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1373\">#1373</a>. 
</li>
</ul>
</html>"));
      end solarAzimuthNoEvent;

      function solarAzimuthWithEvent "Determines solar azimuth with event"
        input Real solAziTem(quantity="Angle",unit="rad",displayUnit="deg") "Temporary solar azimuth";
        input Real solTim(quantity="Time", unit="s") "Solar time";
        input Real day(quantity="Time", unit="s") "Number of seconds in day";
        output Real solAzi(quantity="Angle",unit="rad",displayUnit="deg") "Solar azimuth";
      algorithm
        if (solTim - integer(solTim/day)*day<43200) then
          solAzi := -solAziTem;
        else
          solAzi := solAziTem;
        end if;
        annotation (
          Documentation(info="<html>
<p>
This function is used within
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth</a> 
to calculate solar azimuth with events.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 9, 2020 by David Blum:<br/>
Initial implementation.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1373\">#1373</a>. 
</li>
</ul>
</html>"));
      end solarAzimuthWithEvent;

      package Examples "Collection of models that illustrate model use and test models"
        extends Modelica.Icons.ExamplesPackage;

        model AltitudeAngle "Test model for altitude angle"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle zen(lat=
                0.73268921998722) "Zenith angle"
            annotation (Placement(transformation(extent={{36,-10},{56,10}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
            "Declination angle"
            annotation (Placement(transformation(extent={{0,20},{20,40}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle solHouAng
            "Solar hour angle"
            annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{-44,-10},{-24,10}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.AltitudeAngle altAng
            "Altitude angle: Angle between Sun ray and horizontal surface)"
            annotation (Placement(transformation(extent={{68,-10},{88,10}})));
        equation
          connect(decAng.decAng, zen.decAng) annotation (Line(
              points={{21,30},{26,30},{26,5.4},{34,5.4}},
              color={0,0,127}));
          connect(solHouAng.solHouAng, zen.solHouAng) annotation (Line(
              points={{21,-30},{26,-30},{26,-4.8},{34,-4.8}},
              color={0,0,127}));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-60,5.82867e-16},{-53.5,5.82867e-16},{-53.5,1.13798e-15},{-47,
                  1.13798e-15},{-47,5.55112e-16},{-34,5.55112e-16}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.cloTim, decAng.nDay) annotation (Line(
              points={{-34,5.55112e-16},{-20,5.55112e-16},{-20,30},{-2,30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
              points={{-34,5.55112e-16},{-20,5.55112e-16},{-20,-30},{-2,-30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(zen.zen, altAng.zen) annotation (Line(
              points={{57,6.10623e-16},{59.25,6.10623e-16},{59.25,1.27676e-15},{61.5,
                  1.27676e-15},{61.5,6.66134e-16},{66,6.66134e-16}},
              color={0,0,127}));
          annotation (experiment(Tolerance=1e-6, StopTime=86400),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/AltitudeAngle.mos"
                "Simulate and plot"),
        Documentation(info="<html>
<p>
This example calculates the altitude angle of the sun at a given time.
The altitude angle is the angle between the sun ray and the projection of the ray on a horizontal surface.
</p>
<p>
Components used in this model are:
</p>
<ul>
<li>
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination\">Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination</a>
</li>
<li>
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle\">Buildings.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle</a>
</li>
<li>
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle\">Buildings.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle</a>
</li>
</ul>
<br/>
</html>",
        revisions="<html>
<ul>
<li>
Feb 01, 2012, by Kaustubh Phalak<br/>
First implementation.
</li>
</ul>
</html>"));
        end AltitudeAngle;

        model Declination "Test model for declination"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
            "Declination angle"
            annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Buildings.Utilities.Time.ModelTime modTim "Model time"
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));

          Modelica.Blocks.Sources.TimeTable solDecNOAA(table=[
               0, -0.4007544;
         2678400, -0.2960882;
         5097600, -0.1292836;
         7776000,  0.0824143;
        10368000,  0.2656267;
        13046400,  0.3860123;
        15638400,  0.4027150;
        18316800,  0.3123199;
        20995200,  0.1414929;
        23587200, -0.0587907;
        26265600, -0.2544026;
        28857600, -0.3817216;
        28944000, -0.3843185;
        31536000, -0.4010977], y(unit="rad")) "Solar declination according to NOAA"
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
        equation
          connect(modTim.y, decAng.nDay) annotation (Line(
              points={{1,10},{18,10}},
              color={0,0,127}));
          annotation (
          Documentation(info="<html>
<p>This model validates the computation of the solar declination, which is the angle between the equatorial plane and the solar beam. The time table <code><span style=\"font-family: Courier New,courier;\">solDecNOAA</span></code> outputs the solar declination according to the computation of the National Oceanic and Atmospheric Administration (NOAA), using their yearly calculator from <a href=\"http://www.esrl.noaa.gov/gmd/grad/solcalc/calcdetails.html\">http://www.esrl.noaa.gov/gmd/grad/solcalc/calcdetails.html</a>. The values differ slightly because the equation in <a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination\">Buildings.BoundaryConditions.SolarGeometry.BaseClasses.Declination</a> is an approximation. </p>
</html>",         revisions="<html>
<ul>
<li>
January 6, 2015, by Michael Wetter:<br/>
Updated documentation and added validation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/382\">issue 382</a>.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=3.1536e+007),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/Declination.mos"
                "Simulate and plot"));
        end Declination;

        model IncidenceAngle "Test model for incidence angle"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
            "Declination angle"
            annotation (Placement(transformation(extent={{0,20},{20,40}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle solHouAng
            "Solar hour angle"
            annotation (Placement(transformation(extent={{0,-40},{20,-20}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.IncidenceAngle incAng(azi=
                Buildings.Types.Azimuth.S, til=Buildings.Types.Tilt.Wall)
            "Incidence angle"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{-46,-10},{-26,10}})));
        equation
          connect(decAng.decAng, incAng.decAng) annotation (Line(
              points={{21,30},{30,30},{30,5.4},{37.8,5.4}},
              color={0,0,127}));
          connect(solHouAng.solHouAng, incAng.solHouAng) annotation (Line(
              points={{21,-30},{28,-30},{28,-4.8},{38,-4.8}},
              color={0,0,127}));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-60,5.82867e-16},{-54,5.82867e-16},{-54,1.13798e-15},{-48,
                  1.13798e-15},{-48,5.55112e-16},{-36,5.55112e-16}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.cloTim, decAng.nDay) annotation (Line(
              points={{-36,5.55112e-16},{-20,5.55112e-16},{-20,30},{-2,30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
              points={{-36,5.55112e-16},{-20,5.55112e-16},{-20,-30},{-2,-30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.lat, incAng.lat) annotation (Line(
              points={{-36,0},{38,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          annotation (
          Documentation(info="<html>
<p>
This example computes the solar incidence angle on a tilted surface.
This model is also part of more extensive tests that run the
model for different orientations. These tests are at
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.Examples.IncidenceAngle\">
Buildings.BoundaryConditions.SolarGeometry.Examples.IncidenceAngle</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 24, 2015, by Michael Wetter:<br/>
Assigned azimuth and tilt using the types from
<a href=\"modelica://Buildings.Types.Tilt\">
Buildings.Types.Tilt</a>.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=86400),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/IncidenceAngle.mos"
                "Simulate and plot"));
        end IncidenceAngle;

        model SolarAzimuth "Test model for zenith angle"
          extends Modelica.Icons.Example;

          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle solHouAng
            "Solar hour angle"
            annotation (Placement(transformation(extent={{20,-20},{40,0}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle zen
            "Zenith angle"
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
            "Declination angle"
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth solAzi
            "Solar azimuth"
            annotation (Placement(transformation(extent={{100,10},{120,30}})));
          WeatherData.ReaderTMY3 weaDat(
            filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
          WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{-54,0},{-34,20}})));
        equation
          connect(zen.zen, solAzi.zen) annotation (Line(
              points={{81,50},{90,50},{90,28},{98,28}},
              color={0,0,127}));
          connect(solHouAng.solHouAng, zen.solHouAng) annotation (Line(
              points={{41,-10},{48,-10},{48,45.2},{58,45.2}},
              color={0,0,127}));
          connect(decAng.decAng, solAzi.decAng) annotation (Line(
              points={{1,50},{20,50},{20,22},{98,22}},
              color={0,0,127}));
          connect(decAng.decAng, zen.decAng) annotation (Line(
              points={{1,50},{20,50},{20,55.4},{58,55.4}},
              color={0,0,127}));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-60,10},{-44,10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.cloTim, decAng.nDay) annotation (Line(
              points={{-44,10},{-28,10},{-28,50},{-22,50}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
              points={{-44,10},{-28,10},{-28,-10},{18,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solTim, solAzi.solTim) annotation (Line(
              points={{-44,10},{-28,10},{-28,-28},{92,-28},{92,16},{98,16}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(zen.lat, weaBus.lat) annotation (Line(points={{58,50},{34,50},{34,10},
                  {-44,10}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(solAzi.lat, weaBus.lat) annotation (Line(points={{98,10},{-44,10}},
                color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{150,
                    100}})),
        Documentation(info="<html>
<p>
This example computes the solar azimuth angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=864000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/SolarAzimuth.mos"
                "Simulate and plot"));
        end SolarAzimuth;

        model SolarHourAngle "Test model for solar hour angle"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle solHouAng
            "Solar hour Angle"
            annotation (Placement(transformation(extent={{0,-10},{20,10}})));
          WeatherData.ReaderTMY3 weaDat(
            filNam=Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{-54,-10},{-34,10}})));
        equation
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-60,5.82867e-16},{-56,5.82867e-16},{-56,1.13798e-15},{-52,
                  1.13798e-15},{-52,0},{-44,0}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
              points={{-44,5.55112e-16},{-33.5,5.55112e-16},{-33.5,1.22125e-15},{-23,
                  1.22125e-15},{-23,6.66134e-16},{-2,6.66134e-16}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          annotation (experiment(Tolerance=1e-6, StopTime=86400),
        Documentation(info="<html>
<p>
This example computes the solar hour angle,
which is defined as the angle between the circle
that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/SolarHourAngle.mos"
                "Simulate and plot"));
        end SolarHourAngle;

        model WallSolarAzimuth "Test model for wall solar azimuth angle"
        extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.IncidenceAngle incAng(azi=0,
              til=1.5707963267949) "solar incidence angle"
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{-72,-2},{-48,22}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.WallSolarAzimuth
            walSolAzi "Vertical wall solar azimuth angle"
            annotation (Placement(transformation(extent={{70,0},{90,20}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.AltitudeAngle altAng
            "Altitude angle"
            annotation (Placement(transformation(extent={{-20,20},{0,40}})));
          parameter Modelica.Units.SI.Angle lat=41.98*Modelica.Constants.pi/180
            "Latitude";
        equation
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-80,10},{-60,10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaDat.weaBus, incAng.weaBus) annotation (Line(
              points={{-80,10},{-72,10},{-72,-30},{-20,-30}},
              color={255,204,51},
              thickness=0.5));
          connect(incAng.y, walSolAzi.incAng) annotation (Line(
              points={{1,-30},{14,-30},{14,5.2},{68,5.2}},
              color={0,0,127}));
          connect(altAng.alt, walSolAzi.alt) annotation (Line(
              points={{1,30},{60,30},{60,14.8},{68,14.8}},
              color={0,0,127}));
          connect(weaBus.solZen, altAng.zen) annotation (Line(
              points={{-60,10},{-40,10},{-40,30},{-22,30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          annotation (experiment(Tolerance=1e-6, StopTime=86400),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/WallSolarAzimuth.mos"
                "Simulate and plot"),
        Documentation(info="<html>
<p>
This example calculates the wall solar azimuth angle.
</p>
</html>",
        revisions="<html>
<ul>
<li>
Feb 27, 2012, by Michael Wetter:<br/>
Simplified example by using zenith angle from weather data bus.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak<br/>
First implementation.
</li>
</ul>
</html>"));
        end WallSolarAzimuth;

        model ZenithAngle "Test model for zenith angle"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.ZenithAngle zen
            "Zenith angle"
            annotation (Placement(transformation(extent={{60,-10},{80,10}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.Declination decAng
            "Declination angle"
            annotation (Placement(transformation(extent={{20,20},{40,40}})));
          ProsNet.BoundaryConditions.SolarGeometry.BaseClasses.SolarHourAngle solHouAng
            "Solar hour angle"
            annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather bus"
            annotation (Placement(transformation(extent={{-44,-10},{-24,10}})));
        equation
          connect(decAng.decAng, zen.decAng) annotation (Line(
              points={{41,30},{50,30},{50,5.4},{58,5.4}},
              color={0,0,127}));
          connect(solHouAng.solHouAng, zen.solHouAng) annotation (Line(
              points={{41,-30},{50,-30},{50,-4.8},{58,-4.8}},
              color={0,0,127}));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-60,5.82867e-16},{-53.5,5.82867e-16},{-53.5,1.13798e-15},{-47,
                  1.13798e-15},{-47,5.55112e-16},{-34,5.55112e-16}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.cloTim, decAng.nDay) annotation (Line(
              points={{-34,5.55112e-16},{-18,5.55112e-16},{-18,30},{18,30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solTim, solHouAng.solTim) annotation (Line(
              points={{-34,5.55112e-16},{-18,5.55112e-16},{-18,-30},{18,-30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.lat, zen.lat) annotation (Line(
              points={{-34,0},{58,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          annotation (
          Documentation(info="<html>
<p>
This example computes the zenith angle,
which is the angle between the earth surface normal and the sun's beam.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(StartTime=100000, Tolerance=1e-6, StopTime=300000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarGeometry/BaseClasses/Examples/ZenithAngle.mos"
                "Simulate and plot"));
        end ZenithAngle;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry.BaseClasses\">
Buildings.BoundaryConditions.SolarGeometry.BaseClasses</a>.
</p>
</html>"));
      end Examples;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarGeometry\">Buildings.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
  end SolarGeometry;

  package SolarIrradiation "Package with models to compute solar irradition"
    extends Modelica.Icons.VariantsPackage;

    block DiffuseIsotropic
      "Diffuse solar irradiation on a tilted surface with an isotropic sky model"
      extends
        ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;
      parameter Real rho(min=0, max=1, final unit="1")=0.2 "Ground reflectance";
      parameter Boolean outSkyCon=false
        "Output contribution of diffuse irradiation from sky";
      parameter Boolean outGroCon=false
        "Output contribution of diffuse irradiation from ground";

      Modelica.Blocks.Math.Add add "Block to add radiation"
        annotation (Placement(transformation(extent={{40,-10},{60,10}})));

      Modelica.Blocks.Interfaces.RealOutput HSkyDifTil if outSkyCon
        "Diffuse solar irradiation on a tilted surface from the sky"
        annotation (Placement(transformation(extent={{100,50},{120,70}})));
      Modelica.Blocks.Interfaces.RealOutput HGroDifTil if outGroCon
        "Diffuse solar irradiation on a tilted surface from the ground"
        annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
    protected
      ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.DiffuseIsotropic HDifTilIso(til=til,
          rho=rho) "Diffuse isotropic irradiation on tilted surface"
        annotation (Placement(transformation(extent={{-20,-10},{0,10}})));

    equation
      connect(weaBus.HGloHor, HDifTilIso.HGloHor) annotation (Line(
          points={{-100,5.55112e-16},{-51.5,5.55112e-16},{-51.5,4},{-22,4}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.HDifHor, HDifTilIso.HDifHor) annotation (Line(
          points={{-100,5.55112e-16},{-51.5,5.55112e-16},{-51.5,-4},{-22,-4}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));

      connect(HDifTilIso.HSkyDifTil, add.u1) annotation (Line(
          points={{1,4},{24,4},{24,6},{38,6}},
          color={0,0,127}));
      connect(HDifTilIso.HGroDifTil, add.u2) annotation (Line(
          points={{1,-4},{24,-4},{24,-6},{38,-6}},
          color={0,0,127}));
      connect(add.y, H) annotation (Line(
          points={{61,6.10623e-16},{81.5,6.10623e-16},{81.5,5.55112e-16},{110,
              5.55112e-16}},
          color={0,0,127}));

      connect(HDifTilIso.HSkyDifTil, HSkyDifTil) annotation (Line(
          points={{1,4},{14,4},{14,60},{110,60}},
          color={0,0,127}));
      connect(HDifTilIso.HGroDifTil, HGroDifTil) annotation (Line(
          points={{1,-4},{14,-4},{14,-60},{110,-60}},
          color={0,0,127}));
      annotation (
        defaultComponentName="HDifTilIso",
        Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation
on a tilted surface using an isotropic model.
The irradiation is a sum composed of diffuse solar irradiation and
radiation reflected by the ground.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
<h4>References</h4>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling
Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</html>",     revisions="<html>
<ul>
<li>
November 14, 2015, by Michael Wetter:<br/>
Added <code>min</code>, <code>max</code> and <code>unit</code>
attributes for <code>rho</code>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Added contributions from sky and ground that were separated in base class.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255})}));
    end DiffuseIsotropic;

    block DiffusePerez
      "Hemispherical diffuse irradiation on a tilted surface using Perez's anisotropic sky model"
      extends
        ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

      parameter Real rho(min=0, max=1, final unit="1")=0.2 "Ground reflectance";
      parameter Modelica.Units.SI.Angle azi "Surface azimuth";
      parameter Boolean outSkyCon=false
        "Output contribution of diffuse irradiation from sky";
      parameter Boolean outGroCon=false
        "Output contribution of diffuse irradiation from ground";

      Modelica.Blocks.Interfaces.RealOutput HSkyDifTil if outSkyCon
        "Hemispherical diffuse solar irradiation on a tilted surface from the sky"
        annotation (Placement(transformation(extent={{100,50},{120,70}})));
      Modelica.Blocks.Interfaces.RealOutput HGroDifTil if outGroCon
        "Hemispherical diffuse solar irradiation on a tilted surface from the ground"
        annotation (Placement(transformation(extent={{100,-70},{120,-50}})));

    protected
      BaseClasses.DiffusePerez HDifTil(
        final til=til,
        final rho=rho) "Diffuse irradiation on tilted surface"
        annotation (Placement(transformation(extent={{0,-21},{42,21}})));
      BaseClasses.SkyClearness skyCle "Sky clearness"
        annotation (Placement(transformation(extent={{-62,16},{-54,24}})));
      BaseClasses.BrighteningCoefficient briCoe "Brightening coefficient"
        annotation (Placement(transformation(extent={{-40,-34},{-32,-26}})));
      BaseClasses.RelativeAirMass relAirMas "Relative air mass"
        annotation (Placement(transformation(extent={{-80,-44},{-72,-36}})));
      BaseClasses.SkyBrightness skyBri "Sky brightness"
        annotation (Placement(transformation(extent={{-60,-54},{-52,-46}})));
      SolarGeometry.IncidenceAngle incAng(
        final azi=azi,
        final til=til) "Incidence angle"
        annotation (Placement(transformation(extent={{-86,-96},{-76,-86}})));
      Modelica.Blocks.Math.Add add "Block to add radiations"
        annotation (Placement(transformation(extent={{60,-10},{80,10}})));
    equation
      connect(relAirMas.relAirMas, skyBri.relAirMas) annotation (Line(
          points={{-71.6,-40},{-66,-40},{-66,-47.6},{-60.8,-47.6}},
          color={0,0,127}));
      connect(skyBri.skyBri, briCoe.skyBri) annotation (Line(
          points={{-51.6,-50},{-46,-50},{-46,-30},{-40.8,-30}},
          color={0,0,127}));
      connect(skyCle.skyCle, briCoe.skyCle) annotation (Line(
          points={{-53.6,20},{-46,20},{-46,-27.6},{-40.8,-27.6}},
          color={0,0,127}));
      connect(incAng.y, HDifTil.incAng) annotation (Line(
          points={{-75.5,-91},{-16,-91},{-16,-16},{-4.2,-16},{-4.2,-14.7}},
          color={0,0,127}));
      connect(weaBus.solZen, skyCle.zen) annotation (Line(
          points={{-99.95,0.05},{-86,0.05},{-86,17.6},{-62.8,17.6}},
          color={0,0,127}));
      connect(weaBus.solZen, relAirMas.zen) annotation (Line(
          points={{-99.95,0.05},{-86,0.05},{-86,-42.4},{-80.8,-42.4}},
          color={0,0,127}));
      connect(weaBus.solZen, briCoe.zen) annotation (Line(
          points={{-99.95,0.05},{-86,0.05},{-86,-20},{-66,-20},{-66,-32},{-40.8,
              -32},{-40.8,-32.4}},
          color={0,0,127}));
      connect(weaBus.HDirNor, skyCle.HDirNor) annotation (Line(
          points={{-99.95,0.05},{-92,0.05},{-92,22.4},{-62.8,22.4}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.HDifHor, skyCle.HDifHor) annotation (Line(
          points={{-99.95,0.05},{-92,0.05},{-92,20},{-62.8,20}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.HDifHor, skyBri.HDifHor) annotation (Line(
          points={{-99.95,0.05},{-92,0.05},{-92,-50},{-60.8,-50}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.HGloHor, HDifTil.HGloHor) annotation (Line(
          points={{-99.95,0.05},{-70,0.05},{-38,0.05},{-38,16.8},{-4.2,16.8}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.HDifHor, HDifTil.HDifHor) annotation (Line(
          points={{-99.95,0.05},{-38,0.05},{-38,10},{-4.2,10},{-4.2,10.5}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));

      connect(briCoe.F2, HDifTil.briCof2) annotation (Line(
          points={{-31.6,-31.6},{-24,-31.6},{-24,-2.1},{-4.2,-2.1}},
          color={0,0,127}));
      connect(briCoe.F1, HDifTil.briCof1) annotation (Line(
          points={{-31.6,-28.4},{-28,-28.4},{-28,4.2},{-4.2,4.2}},
          color={0,0,127}));
      connect(weaBus, incAng.weaBus) annotation (Line(
          points={{-100,5.55112e-16},{-92,5.55112e-16},{-92,-91},{-86,-91}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(weaBus.solZen, HDifTil.zen) annotation (Line(
          points={{-99.95,0.05},{-86,0.05},{-86,-58},{-20,-58},{-20,-8.4},{-4.2,
              -8.4}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(HDifTil.HSkyDifTil, add.u1) annotation (Line(
          points={{44.1,8.4},{52,8.4},{52,6},{58,6}},
          color={0,0,127}));
      connect(HDifTil.HGroDifTil, add.u2) annotation (Line(
          points={{44.1,-8.4},{52,-8.4},{52,-6},{58,-6}},
          color={0,0,127}));
      connect(add.y, H) annotation (Line(
          points={{81,6.10623e-16},{90.5,6.10623e-16},{90.5,5.55112e-16},{110,
              5.55112e-16}},
          color={0,0,127}));

      connect(HDifTil.HSkyDifTil, HSkyDifTil) annotation (Line(
          points={{44.1,8.4},{52,8.4},{52,60},{110,60}},
          color={0,0,127}));
      connect(HDifTil.HGroDifTil, HGroDifTil) annotation (Line(
          points={{44.1,-8.4},{52,-8.4},{52,-60},{110,-60}},
          color={0,0,127}));
      connect(weaBus.solTim, skyBri.solTim) annotation (Line(
          points={{-99.95,0.05},{-96,0.05},{-96,-52.4},{-60.8,-52.4}},
          color={255,204,51},
          thickness=0.5), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));
      connect(weaBus.alt, relAirMas.alt) annotation (Line(
          points={{-99.95,0.05},{-84,0.05},{-84,-37.6},{-80.8,-37.6}},
          color={255,204,51},
          thickness=0.5), Text(
          string="%first",
          index=-1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));
      annotation (
        defaultComponentName="HDifTil",
        Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface using an anisotropic
sky model proposed by Perez.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",     revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
November 14, 2015, by Michael Wetter:<br/>
Added <code>min</code>, <code>max</code> and <code>unit</code>
attributes for <code>rho</code>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Added contributions from sky and ground that were separated in base class.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Changed component to get zenith angle from weather bus.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255})}));
    end DiffusePerez;

    block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
      extends
        ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;

      parameter Modelica.Units.SI.Angle azi "Surface azimuth";

      Modelica.Blocks.Interfaces.RealOutput inc(
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg") "Incidence angle"
        annotation (Placement(transformation(extent={{100,-50},{120,-30}})));

    protected
      SolarGeometry.IncidenceAngle incAng(
        final azi=azi,
        final til=til) "Incidence angle"
        annotation (Placement(transformation(extent={{-50,-30},{-30,-10}})));
      ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.DirectTiltedSurface
        HDirTil "Direct irradition on tilted surface"
        annotation (Placement(transformation(extent={{0,-20},{40,20}})));

    equation
      connect(incAng.y, HDirTil.incAng) annotation (Line(
          points={{-29,-20},{-12,-20},{-12,-12},{-4,-12}},
          color={0,0,127}));

      connect(weaBus.HDirNor, HDirTil.HDirNor) annotation (Line(
          points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,12},{-4,12}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      connect(incAng.y, inc) annotation (Line(
          points={{-29,-20},{-20,-20},{-20,-40},{110,-40}},
          color={0,0,127}));
      connect(HDirTil.HDirTil, H) annotation (Line(
          points={{42,1.22125e-15},{72,1.22125e-15},{72,5.55112e-16},{110,
              5.55112e-16}},
          color={0,0,127}));

      connect(weaBus, incAng.weaBus) annotation (Line(
          points={{-100,5.55112e-16},{-80,5.55112e-16},{-80,-20},{-50,-20}},
          color={255,204,51},
          thickness=0.5), Text(
          textString="%first",
          index=-1,
          extent={{-6,3},{-6,3}}));
      annotation (
        defaultComponentName="HDirTil",
        Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">User's Guide</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed duplicate instance <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/461\">
https://github.com/ibpsa/modelica-ibpsa/issues/461</a>.
</li>
<li>
December 12, 2010, by Michael Wetter:<br/>
Added incidence angle as output as this is needed for the room model.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Text(
              extent={{-150,110},{150,150}},
              textString="%name",
              textColor={0,0,255})}));
    end DirectTiltedSurface;

    block GlobalPerezTiltedSurface
      "Global solar irradiation on a tilted surface with diffuse irradiation calculation following Perez"
      extends
        ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;
      parameter Modelica.Units.SI.Angle azi "Surface azimuth";
      parameter Real rho=0.2 "Ground reflectance";
      parameter Boolean outSkyCon=false
        "Output contribution of diffuse irradiation from sky";
      parameter Boolean outGroCon=false
        "Output contribution of diffuse irradiation from ground";
      DiffusePerez HDifTil(
        final til=til,
        final rho=rho,
        final azi=azi,
        final outSkyCon=outSkyCon,
        final outGroCon=outGroCon)
        "Diffuse irradiation on tilted surface"
        annotation (Placement(transformation(extent={{-40,20},{0,60}})));
      DirectTiltedSurface HDirTil(
        final til=til,
        final azi=azi)
        "Direct irradiation on tilted surface"
        annotation (Placement(transformation(extent={{-40,-60},{0,-20}})));
      Modelica.Blocks.Math.Add HGloTil(
          final k1=1,
          final k2=1)
        "Global irradiation on tilted surface"
        annotation (Placement(transformation(extent={{40,-10},{60,10}})));

    equation
      connect(weaBus, HDifTil.weaBus) annotation (Line(
          points={{-100,0},{-100,40},{-40,40}},
          color={255,204,51},
          thickness=0.5));
      connect(weaBus, HDirTil.weaBus) annotation (Line(
          points={{-100,0},{-100,-40},{-40,-40}},
          color={255,204,51},
          thickness=0.5));
      connect(HDifTil.H, HGloTil.u1) annotation (Line(points={{2,40},{26,40},{26,6},{38,
              6}},            color={0,0,127}));
      connect(HDirTil.H, HGloTil.u2) annotation (Line(points={{2,-40},{26,-40},{26,-6},
              {38,-6}}, color={0,0,127}));
      connect(HGloTil.y, H) annotation (Line(points={{61,0},{110,0}}, color={0,0,127}));
      annotation (
        defaultComponentName = "HGloTil",
        Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
            coordinateSystem(preserveAspectRatio=false)),
        Documentation(info="<html>
<p>
This component computes the hemispherical direct and diffuse irradiation on a tilted surface
and outputs the global irradiation.
</p>
<p>
It uses an anisotropic sky model proposed by Perez for the diffuse irradiation computation.
</p>
<p>
For a definition of the parameters, see the
<a href=\"modelica://Buildings.BoundaryConditions.UsersGuide\">
Buildings.BoundaryConditions.UsersGuide</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
Nov 14, 2022, by Laura Maier:<br/>
First implementation.
</li>
</ul>
</html>"));
    end GlobalPerezTiltedSurface;

    package Examples "Collection of models that illustrate model use and test models"
      extends Modelica.Icons.ExamplesPackage;

      model DiffuseIsotropic
        "Test model for diffuse solar irradiation on a tilted surface using the isotropic model"
        extends Modelica.Icons.Example;
        parameter Real rho=0.2 "Ground reflectance";

        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
        ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather data bus"
          annotation (Placement(transformation(extent={{-11,-1},{9,21}}),
              iconTransformation(extent={{1,-1},{2,-2}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DiffuseIsotropic HDifRoo(til=
              Buildings.Types.Tilt.Ceiling, rho=rho)
          "Diffuse irradiation on roof"
          annotation (Placement(transformation(extent={{40,0},{60,20}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DiffuseIsotropic HDifFlo(til=
              Buildings.Types.Tilt.Floor, rho=rho)
          "Diffuse irradiation on floor"
          annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DiffuseIsotropic HDifWal(til=
              Buildings.Types.Tilt.Wall, rho=rho) "Diffuse irradiation on wall"
          annotation (Placement(transformation(extent={{40,-40},{60,-20}})));

      equation
        connect(weaDat.weaBus, weaBus) annotation (Line(
            points={{-20,10},{-1,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(weaBus,HDifRoo. weaBus) annotation (Line(
            points={{-1,10},{40,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(HDifWal.weaBus, weaBus) annotation (Line(
            points={{40,-30},{20,-30},{20,10},{-1,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(HDifFlo.weaBus, weaBus) annotation (Line(
            points={{40,-70},{20,-70},{20,10},{-1,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        annotation (
          Documentation(info="<html>
<p>
This example computes the hemispherical diffuse irradiation
on a roof, wall and a floor, using an isotropic sky model.
Since the floor only sees the ground,
it receives the lowest amount of diffuse solar irradiation.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
      experiment(StartTime=1.82304e+07, Tolerance=1e-6, StopTime=1.83168e+07),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/Examples/DiffuseIsotropic.mos"
              "Simulate and plot"));
      end DiffuseIsotropic;

      model DiffusePerez
        "Test model for diffuse solar irradiation on a tilted surface using the Perez model"
        extends Modelica.Icons.Example;
        parameter Modelica.Units.SI.Angle azi=0.3 "Azi angle";
        parameter Modelica.Units.SI.Angle til=0.5 "Tilted angle";
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
        ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather data bus"
          annotation (Placement(transformation(extent={{1,-1},{21,21}}),
              iconTransformation(extent={{20,20},{21,21}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DiffusePerez HDifRoo(til=
              Buildings.Types.Tilt.Ceiling, azi=0.78539816339745)
          "Diffuse irradiation on roof"
          annotation (Placement(transformation(extent={{40,0},{60,20}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DiffusePerez HDifFlo(til=
              Buildings.Types.Tilt.Floor, azi=0.78539816339745)
          "Diffuse irradiation on floor"
          annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DiffusePerez HDifWal(til=
              Buildings.Types.Tilt.Wall, azi=0.78539816339745)
          "Diffuse irradiation on wall"
          annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
      equation
        connect(weaDat.weaBus, weaBus) annotation (Line(
            points={{-20,10},{11,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(weaBus,HDifRoo. weaBus) annotation (Line(
            points={{11,10},{40,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));

        connect(weaBus, HDifFlo.weaBus) annotation (Line(
            points={{11,10},{30,10},{30,-70},{40,-70}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus, HDifWal.weaBus) annotation (Line(
            points={{11,10},{30,10},{30,-30},{40,-30}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
      experiment(StartTime=1.82304e+07, Tolerance=1e-6, StopTime=1.83168e+07),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/Examples/DiffusePerez.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
This model tests the implementation of Perez' model for diffuse solar radiation.
The three instances of Perez' model compute the diffuse solar
irradiation on a roof, a wall and a floor.
Since the floor only sees the ground but not the radiative heat flow that is
scattered in the atmosphere, it receives the lowest amount of
diffuse solar irradiation.
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DiffusePerez;

      model DirectTiltedSurface
        "Test model for direct solar irradiation on a tilted surface"
        extends Modelica.Icons.Example;

        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirRoo(til=
              Buildings.Types.Tilt.Ceiling, azi=0.78539816339745)
          "Direct irradiation on roof"
          annotation (Placement(transformation(extent={{20,20},{40,40}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirFlo(til=
              Buildings.Types.Tilt.Floor, azi=0.78539816339745)
          "Direct irradiation on floor"
          annotation (Placement(transformation(extent={{20,-60},{40,-40}})));
        ProsNet.BoundaryConditions.SolarIrradiation.DirectTiltedSurface HDirWal(til=
              Buildings.Types.Tilt.Wall, azi=0.78539816339745)
          "Direct irradiation on wall"
          annotation (Placement(transformation(extent={{20,-20},{40,0}})));
        Buildings.Utilities.Diagnostics.AssertEquality assEqu
          "Assert to ensure that direct radiation received by floor construction is zero"
          annotation (Placement(transformation(extent={{60,-66},{80,-46}})));
        Modelica.Blocks.Sources.Constant const(k=0) "Block that outputs zero"
          annotation (Placement(transformation(extent={{-40,-72},{-20,-52}})));
      equation
        connect(assEqu.u1, HDirFlo.H) annotation (Line(
            points={{58,-50},{41,-50}},
            color={0,0,127}));
        connect(const.y, assEqu.u2) annotation (Line(
            points={{-19,-62},{58,-62}},
            color={0,0,127}));
        connect(weaDat.weaBus, HDirRoo.weaBus) annotation (Line(
            points={{-40,30},{20,30}},
            color={255,204,51},
            thickness=0.5));
        connect(HDirWal.weaBus, weaDat.weaBus) annotation (Line(
            points={{20,-10},{-10,-10},{-10,30},{-40,30}},
            color={255,204,51},
            thickness=0.5));
        connect(HDirFlo.weaBus, weaDat.weaBus) annotation (Line(
            points={{20,-50},{-10,-50},{-10,30},{-40,30}},
            color={255,204,51},
            thickness=0.5));
        annotation (
      experiment(StartTime=1.82304e+07, Tolerance=1e-6, StopTime=1.83168e+07),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/Examples/DirectTiltedSurface.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
This model tests the direct solar irradiation received on a ceiling, a wall and a floor.
The assert statement will stop the simulation if the floor receives
any direct solar irradiation.
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DirectTiltedSurface;

      model GlobalPerezTiltedSurface
        "Test model for global solar irradiation on a tilted surface with diffuse
  irradiation calculation based on Perez"
        extends Modelica.Icons.Example;

        parameter Real rho=0.2 "Ground reflectance";

        WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
          annotation (Placement(transformation(extent={{-40,0},{-20,20}})));

        ProsNet.BoundaryConditions.SolarIrradiation.GlobalPerezTiltedSurface HGloRoo(
          til=Buildings.Types.Tilt.Ceiling,
          azi=0.78539816339745,
          rho=rho) "Diffuse irradiation on roof"
          annotation (Placement(transformation(extent={{40,0},{60,20}})));
        ProsNet.BoundaryConditions.SolarIrradiation.GlobalPerezTiltedSurface HGloFlo(
          til=Buildings.Types.Tilt.Floor,
          azi=0.78539816339745,
          rho=rho) "Diffuse irradiation on floor"
          annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
        ProsNet.BoundaryConditions.SolarIrradiation.GlobalPerezTiltedSurface HGloWal(
          til=Buildings.Types.Tilt.Wall,
          azi=0.78539816339745,
          rho=rho) "Diffuse irradiation on wall"
          annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
        WeatherData.Bus weaBus
          "Weather data bus"
          annotation (Placement(
              transformation(extent={{1,-1},{21,21}}), iconTransformation(extent={{20,20},
                  {21,21}})));
      equation
        connect(weaDat.weaBus,weaBus)  annotation (Line(
            points={{-20,10},{11,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(weaBus,HGloRoo. weaBus) annotation (Line(
            points={{11,10},{40,10}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus,HGloFlo. weaBus) annotation (Line(
            points={{11,10},{30,10},{30,-70},{40,-70}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        connect(weaBus,HGloWal. weaBus) annotation (Line(
            points={{11,10},{30,10},{30,-30},{40,-30}},
            color={255,204,51},
            thickness=0.5), Text(
            textString="%first",
            index=-1,
            extent={{-6,3},{-6,3}}));
        annotation (
        experiment(StartTime=1.82304e+07, Tolerance=1e-6, StopTime=1.83168e+07),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/Examples/GlobalPerezTiltedSurface.mos"
              "Simulate and plot"),
        Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)),
          Documentation(info="<html>
<p>This model tests the implementation of global irradiation computation based on Perez&apos; model for diffuse solar radiation.</p>
<p>The three instances of the model compute the global solar irradiation on a roof, a wall and a floor.</p>
<p>Since the floor only sees the ground but not the radiative heat flow that is scattered in the atmosphere,
it receives the lowest amount of diffuse and global solar irradiation.</p>
</html>",
      revisions="<html>
<ul>
<li>
Nov 14, 2022, by Laura Maier:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GlobalPerezTiltedSurface;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">
Buildings.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
    end Examples;

    package BaseClasses "Package with base classes for Buildings.BoundaryConditions.SolarIrradiation"
      extends Modelica.Icons.BasesPackage;

      block BrighteningCoefficient "Circumsolar and horizon brightening coefficients"
        extends Modelica.Blocks.Icons.Block;
        import H = Buildings.Utilities.Math.Functions.regStep;
        Modelica.Blocks.Interfaces.RealInput zen(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Zenith angle of the sun beam"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealInput skyCle
          "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput skyBri "Sky brightness [0,1]"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput F1
          "Circumsolar brightening coefficient"
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
        Modelica.Blocks.Interfaces.RealOutput F2 "Horizon brightening coefficient"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
      protected
        Real F11;
        Real F12;
        Real F13;
        Real F21;
        Real F22;
        Real F23;
        Real d=0.01;
        Real a1;
        Real a2;
        Real a3;
        Real a4;
        Real a5;
        Real a6;
        Real a7;
        Real a8;
        Real b1;
        Real b2;
        Real b3;
        Real b4;
        Real b5;
        Real b6;
        Real b7;
        Real b8;
      equation
        b1 = H(
          y1=1,
          y2=0,
          x=1.065 - skyCle,
          x_small=d);
        b2 = H(
          y1=1,
          y2=0,
          x=1.23 - skyCle,
          x_small=d);
        b3 = H(
          y1=1,
          y2=0,
          x=1.50 - skyCle,
          x_small=d);
        b4 = H(
          y1=1,
          y2=0,
          x=1.95 - skyCle,
          x_small=d);
        b5 = H(
          y1=1,
          y2=0,
          x=2.80 - skyCle,
          x_small=d);

        b6 = H(
          y1=1,
          y2=0,
          x=4.50 - skyCle,
          x_small=d);
        b7 = H(
          y1=1,
          y2=0,
          x=6.20 - skyCle,
          x_small=d);
        b8 = H(
          y1=1,
          y2=0,
          x=skyCle - 6.20,
          x_small=d);

        a1 = b1;
        a2 = b2 - b1;
        a3 = b3 - b2;
        a4 = b4 - b3;
        a5 = b5 - b4;
        a6 = b6 - b5;
        a7 = b7 - b6;
        a8 = b8;

        F11 = -0.0083117*a1 + 0.1299457*a2 + 0.3296958*a3 + 0.5682053*a4 + 0.8730280*
          a5 + 1.1326077*a6 + 1.0601591*a7 + 0.6777470*a8;
        F12 = 0.5877285*a1 + 0.6825954*a2 + 0.4868735*a3 + 0.1874525*a4 - 0.3920403*
          a5 - 1.2367284*a6 - 1.5999137*a7 - 0.3272588*a8;
        F13 = -0.0620636*a1 - 0.1513725*a2 - 0.2210958*a3 - 0.2951290*a4 - 0.3616149*
          a5 - 0.4118494*a6 - 0.3589221*a7 - 0.2504286*a8;
        F21 = -0.0596012*a1 - 0.0189325*a2 + 0.0554140*a3 + 0.1088631*a4 + 0.2255647*
          a5 + 0.2877813*a6 + 0.2642124*a7 + 0.1561313*a8;
        F22 = 0.0721249*a1 + 0.0659650*a2 - 0.0639588*a3 - 0.1519229*a4 - 0.4620442*
          a5 - 0.8230357*a6 - 1.1272340*a7 - 1.3765031*a8;
        F23 = -0.0220216*a1 - 0.0288748*a2 - 0.0260542*a3 - 0.0139754*a4 + 0.0012448*
          a5 + 0.0558651*a6 + 0.1310694*a7 + 0.2506212*a8;
        F1 = Buildings.Utilities.Math.Functions.smoothMax(
          0,
          F11 + F12*skyBri + F13*zen,
          0.01);
        F2 = F21 + F22*skyBri + F23*zen;
        annotation (
          defaultComponentName="briCoe",
          Documentation(info="<html>
<p>
This component computes the circumsolar and horizon brightening coefficients.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
May 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-96,72},{-52,50}},
                textColor={0,0,127},
                textString="skyCle"),
              Text(
                extent={{-96,14},{-52,-8}},
                textColor={0,0,127},
                textString="skyBri"),
              Text(
                extent={{-96,-46},{-52,-68}},
                textColor={0,0,127},
                textString="zen"),
              Text(
                extent={{62,50},{106,28}},
                textColor={0,0,127},
                textString="F1"),
              Text(
                extent={{60,-30},{104,-52}},
                textColor={0,0,127},
                textString="F2")}));
      end BrighteningCoefficient;

      block DiffuseIsotropic
        "Diffuse solar irradiation on a tilted surface with an isotropic model"
        extends Modelica.Blocks.Icons.Block;
        parameter Real rho=0.2 "Ground reflectance";
        parameter Modelica.Units.SI.Angle til(displayUnit="deg") "Surface tilt angle";

        Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal diffuse solar radiation"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
        Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2") "Horizontal global radiation"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

        Modelica.Blocks.Interfaces.RealOutput HGroDifTil(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
          "Diffuse solar irradiation on a tilted surface from the ground"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
        Modelica.Blocks.Interfaces.RealOutput HSkyDifTil(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2")
          "Diffuse solar irradiation on a tilted surface from the sky"
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
      protected
        Real til_c "Cosine of tilt angle";
      equation
        til_c = Modelica.Math.cos(til);
        HSkyDifTil = 0.5*HDifHor*(1 + til_c);
        HGroDifTil = 0.5*HGloHor*rho*(1 - til_c);
        annotation (
          defaultComponentName="HDifTilIso",
          Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface.
The irradiation is composed of the diffuse horizontal solar irradiation and the irradiation
that has been reflected by the ground. Both components are adjusted to take into account
the tilt of the receiving surface.
</p>
<h4>References</h4>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</html>",       revisions="<html>
<ul>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Separated the contributions from the sky and the ground.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255})}));
      end DiffuseIsotropic;

      block DiffusePerez
        "Hemispherical diffuse irradiation on a tilted surface with Perez's anisotropic model"
        extends Modelica.Blocks.Icons.Block;
        parameter Real rho=0.2 "Ground reflectance";
        parameter Modelica.Units.SI.Angle til(displayUnit="deg") "Surface tilt angle";
        Modelica.Blocks.Interfaces.RealInput briCof1 "Brightening Coeffcient F1"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput briCof2 "Brightening Coeffcient F2"
          annotation (Placement(transformation(extent={{-140,-30},{-100,10}})));
        Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2")
          "Diffuse horizontal solar radiation"
          annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
        Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2") "Global horizontal radiation"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

        Modelica.Blocks.Interfaces.RealInput zen(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Zenith angle of the sun beam"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
        Modelica.Blocks.Interfaces.RealInput incAng(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Solar incidence angle on the surface"
          annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));

        Modelica.Blocks.Interfaces.RealOutput HGroDifTil(final quantity=
              "RadiantEnergyFluenceRate", final unit="W/m2")
          "Hemispherical diffuse solar irradiation on a tilted surface from the ground"
          annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
        Modelica.Blocks.Interfaces.RealOutput HSkyDifTil(final quantity=
              "RadiantEnergyFluenceRate", final unit="W/m2")
          "Hemispherical diffuse solar irradiation on a tilted surface from the sky"
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
      protected
        Real a;
        Real b;
        constant Real bMin=Modelica.Math.cos(Modelica.Constants.pi*85/180)
          "Lower bound for b";
      equation
        a = Buildings.Utilities.Math.Functions.smoothMax(
          0,
          Modelica.Math.cos(incAng),
          0.01);
        b = Buildings.Utilities.Math.Functions.smoothMax(
          bMin,
          Modelica.Math.cos(zen),
          0.01);
        HSkyDifTil = HDifHor*(0.5*(1 - briCof1)*(1 + Modelica.Math.cos(til)) +
          briCof1*a/b + briCof2*Modelica.Math.sin(til));
        HGroDifTil = HGloHor*0.5*rho*(1 - Modelica.Math.cos(til));

        annotation (
          defaultComponentName="HDifTil",
          Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface by using an anisotropic model proposed by Perez.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Separated the contribution from the sky and the ground.
</li>
</ul>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-48,74},{-100,86}},
                textColor={0,0,127},
                textString="HGloHor"),
              Text(
                extent={{-50,44},{-102,56}},
                textColor={0,0,127},
                textString="HDifHor"),
              Text(
                extent={{-50,14},{-102,26}},
                textColor={0,0,127},
                textString="briCof1"),
              Text(
                extent={{-50,-16},{-102,-4}},
                textColor={0,0,127},
                textString="briCof2"),
              Text(
                extent={{-50,-46},{-102,-34}},
                textColor={0,0,127},
                textString="zen"),
              Text(
                extent={{-52,-76},{-104,-64}},
                textColor={0,0,127},
                textString="incAng")}));
      end DiffusePerez;

      block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput incAng(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Incidence angle of the sun beam on a tilted surface"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2") "Direct normal radiation"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealOutput HDirTil(final quantity=
              "RadiantEnergyFluenceRate", final unit="W/m2")
          "Direct solar irradiation on a tilted surface"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        HDirTil =  max(0, Modelica.Math.cos(incAng)*HDirNor);
        annotation (
          defaultComponentName="HDirTil",
          Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-50,56},{-102,68}},
                textColor={0,0,127},
                textString="HDirNor"),
              Text(
                extent={{-54,-66},{-106,-54}},
                textColor={0,0,127},
                textString="incAng")}));
      end DirectTiltedSurface;

      partial block PartialSolarIrradiation
        "Partial model that is used to compute the direct and diffuse solar irradiation"
        extends Modelica.Blocks.Icons.Block;
        parameter Modelica.Units.SI.Angle til(displayUnit="deg") "Surface tilt";
        Modelica.Blocks.Interfaces.RealOutput H(
           final quantity="RadiantEnergyFluenceRate",
           final unit="W/m2") "Radiation per unit area"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        WeatherData.Bus weaBus "Bus with weather data"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        annotation (
          Documentation(info="<html>
<p>
This is a partial model that is used to implement the direct and diffuse irradiation.
</p>
</html>",       revisions="<html>
<ul>
<li>
Dec. 12, 2010, by Michael Wetter:<br/>
Changed output signal to avoid ambiguity in blocks that output also other
quantities such as the incidence angle.
</li>
<li>
Sep. 4, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255})}));
      end PartialSolarIrradiation;

      block RelativeAirMass "Relative air mass"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput alt(
          quantity="Length",
          unit="m") "location altitude" annotation (Placement(transformation(extent={{-140,40},
                  {-100,80}}),
              iconTransformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput zen(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Zenith angle of the sun beam"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
              iconTransformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealOutput relAirMas "Relative air mass"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
        Real zenLim "Zenith angle bounded from above by 90 degree";
        Real zenDeg "Zenith angle in degree";
      equation
        zenLim = Buildings.Utilities.Math.Functions.smoothMin(
          zen,
          Modelica.Constants.pi/2,
          0.01);
        zenDeg = zenLim*180/Modelica.Constants.pi;
        relAirMas = exp(-0.0001184*alt)/(Modelica.Math.cos(zenLim) + 0.15*(93.9 - zenDeg)^(-1.253));
        annotation (
          defaultComponentName="relAirMas",
          Documentation(info="<html>
<p>
This component computes the relative air mass for sky brightness.
</p>
<h4>References</h4>
<p>
R. Perez (1999).
<i>Fortran Function irrpz.f</i>,
Emailed by R. Perez to F.C. Winkelmann on May 21, 1999.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:
Introduced altitude attenuation for relative air mass calculation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, issue 1477</a>.
</li>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IBPSA, issue 912</a>.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255})}));
      end RelativeAirMass;

      block SkyBrightness "Sky brightness"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput relAirMas "Relative air mass"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
              iconTransformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal diffuse solar radiation"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}}),
              iconTransformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
          "Solar time"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
              iconTransformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealOutput skyBri "Sky brightness"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        Real extRadCor "Correction for extraterrestrial radiation";
      equation
        extRadCor =1 + 0.033*cos(2*Modelica.Constants.pi*(solTim/86400 + 1)/365);
        skyBri = Buildings.Utilities.Math.Functions.smoothMin(
          HDifHor*relAirMas/(1366.1*extRadCor),
          1,
          0.025);
        annotation (
          defaultComponentName="skyBri",
          Documentation(info="<html>
<p>
This component computes the sky brightness.
</p>
<h4>References</h4>
<p>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
Added input connector <code>solTim</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-46,54},{-98,66}},
                textColor={0,0,127},
                textString="relAirMas"),
              Text(
                extent={{-46,-6},{-98,6}},
                textColor={0,0,127},
                textString="HDifHor"),
              Text(
                extent={{-46,-66},{-98,-54}},
                textColor={0,0,127},
                textString="solTim")}));
      end SkyBrightness;

      block SkyClearness "Sky clearness"
        extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealInput zen(
          quantity="Angle",
          unit="rad",
          displayUnit="deg") "Zenith angle of the sun beam"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal diffuse solar radiation"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
              "RadiantEnergyFluenceRate", unit="W/m2")
          "Horizontal global solar radiation"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealOutput skyCle
          "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        // Set hSmall so that hSmall + deltaX < 1E-4. See info section.
      protected
        constant Modelica.Units.SI.Irradiance hSmall=0.5e-4
          "Small radiation for regularization";
        constant Modelica.Units.SI.Irradiance deltaX=hSmall/2
          "Small radiation for regularization";
        constant Real k = 5.534e-6*(180/Modelica.Constants.pi)^3 "Constant factor";
        Real tmp1 "Intermediate variable";
        Modelica.Units.SI.Irradiance HDifHorBou
          "Diffuse horizontal irradiation, bounded away from zero";
      equation
        tmp1 =  k*zen^3;
        HDifHorBou = Buildings.Utilities.Math.Functions.smoothMax(
                       x1 = HDifHor,
                       x2 = hSmall,
                       deltaX = deltaX);
        // In the Buildings library, HDirNor is always larger than 1E-4
        // (minus some small undershoot due to regularization. Hence,
        // it makes no sense to simplify the equation for
        // HDirNor < Modelica.Constants.small.
        skyCle = Buildings.Utilities.Math.Functions.smoothLimit(
              x = ((HDirNor+HDifHorBou)/HDifHorBou + tmp1)/(1 + tmp1),
              l = 1,
              u = 8,
              deltaX = 0.01);

        annotation (
          defaultComponentName="skyCle",
          Documentation(info="<html>
<p>
This component computes the sky clearness.
</p>
<h4>Implementation</h4>
<p>
In the <code>Buildings</code> library, <code>HDirNor</code>
is always larger than <i>1E-4</i>,
minus some small undershoot due to regularization. Hence,
the implementation is not simplified for
<code>HDirNor &lt; Modelica.Constants.small</code>.
</p>
<p>
The function call
<code>Buildings.Utilities.Math.Functions.smoothMax</code>
is such that the regularization is usually not triggered.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 4, 2024, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1848\">IBPSA, #1848</a>.
</li>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed <code>lat</code> from being a parameter to an input from weather bus.<br/>
Changed input connector <code>HGloHor</code> to <code>HDirNor</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Corrected expression for sky clearness.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">issue 1477</a>.
</li>
<li>
September 23, 2016, by Michael Wetter:<br/>
Changed <code>deltaX</code> from <code>0.1</code> to <code>0.01</code>,
and also optimized the code.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/521\">issue 521</a>.
</li>
<li>
May 5, 2015, by Michael Wetter:<br/>
Introduced constant <code>k</code> to reduce number of operations.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-48,-6},{-100,6}},
                textColor={0,0,127},
                textString="HDifHor"),
              Text(
                extent={{-48,54},{-100,66}},
                textColor={0,0,127},
                textString="HDirNor"),
              Text(
                extent={{-48,-66},{-100,-54}},
                textColor={0,0,127},
                textString="zen")}));
      end SkyClearness;

      package Examples "Collection of models that illustrate model use and test models"
        extends Modelica.Icons.ExamplesPackage;

        model BrighteningCoefficient "Test model for brightening coeffcients"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarGeometry.ZenithAngle zen
            annotation (Placement(transformation(extent={{-42,-20},{-22,0}})));
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.SkyClearness skyCle
            annotation (Placement(transformation(extent={{40,20},{60,40}})));
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.BrighteningCoefficient
            briCoe
            annotation (Placement(transformation(extent={{80,-20},{100,0}})));
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.RelativeAirMass
            relAirMas
            annotation (Placement(transformation(extent={{-8,-20},{12,0}})));
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.SkyBrightness
            skyBri
            annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            annotation (Placement(transformation(extent={{-90,60},{-70,80}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus annotation (
              Placement(transformation(extent={{-60,60},{-40,80}}),
                iconTransformation(extent={{-20,60},{-20,60}})));
        equation
          connect(zen.y, skyCle.zen) annotation (Line(
              points={{-21,-10},{-16,-10},{-16,24},{38,24}},
              color={0,0,127}));
          connect(relAirMas.relAirMas, skyBri.relAirMas) annotation (Line(
              points={{13,-10},{30,-10},{30,-24},{38,-24}},
              color={0,0,127}));
          connect(zen.y, relAirMas.zen) annotation (Line(
              points={{-21,-10},{-16,-10},{-16,-16},{-10,-16}},
              color={0,0,127}));
          connect(skyBri.skyBri, briCoe.skyBri) annotation (Line(
              points={{61,-30},{68,-30},{68,-10},{78,-10}},
              color={0,0,127}));
          connect(skyCle.skyCle, briCoe.skyCle) annotation (Line(
              points={{61,30},{68,30},{68,-4},{78,-4}},
              color={0,0,127}));
          connect(zen.y, briCoe.zen) annotation (Line(
              points={{-21,-10},{-16,-10},{-16,-60},{72,-60},{72,-16},{78,-16}},
              color={0,0,127}));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-70,70},{-50,70}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.HDifHor, skyCle.HDifHor) annotation (Line(
              points={{-50,70},{20,70},{20,30},{38,30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.HDifHor, skyBri.HDifHor) annotation (Line(
              points={{-50,70},{20,70},{20,-34},{38,-34}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus, zen.weaBus) annotation (Line(
              points={{-50,70},{-50,-10},{-42,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.solTim, skyBri.solTim) annotation (Line(
              points={{-50,70},{-50,-38.4},{38,-38.4}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(weaBus.HDirNor, skyCle.HDirNor) annotation (Line(
              points={{-50,70},{20,70},{20,36},{38,36}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(weaBus.alt, relAirMas.alt) annotation (Line(
              points={{-50,70},{-18,70},{-18,-4},{-10,-4}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,6},{-3,6}},
              horizontalAlignment=TextAlignment.Right));
          annotation (
        Documentation(info="<html>
<p>
This example computes the circumsolar and horizon brightening coefficients.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=8640000),
        __Dymola_Commands(
              file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/BaseClasses/Examples/BrighteningCoefficient.mos"
              "Simulate and plot"),
            Diagram(coordinateSystem(extent={{-100,-100},{120,100}})),
            Icon(coordinateSystem(extent={{-100,-100},{100,100}})));
        end BrighteningCoefficient;

        model DiffuseIsotropic
          "Test model for diffuse solar irradiation on a tilted surface by using isotropic model"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.DiffuseIsotropic
            HDifTilIso(til=1.5707963267949)
            annotation (Placement(transformation(extent={{40,0},{60,20}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus
            annotation (Placement(transformation(extent={{-11,-1},{9,21}})));
        equation
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-40,10},{-1,10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.HGloHor, HDifTilIso.HGloHor) annotation (Line(
              points={{-1,10},{24,10},{24,14},{38,14}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.HDifHor, HDifTilIso.HDifHor) annotation (Line(
              points={{-1,10},{24,10},{24,6},{38,6}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          annotation (
          Documentation(info="<html>
<p>
This example computes the hemispherical diffuse irradiation on a tilted surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=0, StopTime=8640000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/BaseClasses/Examples/DiffuseIsotropic.mos"
                "Simulate and plot"));
        end DiffuseIsotropic;

        model RelativeAirMass "Test model for relative air mass"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.RelativeAirMass
            relAirMas
            annotation (Placement(transformation(extent={{20,6},{40,26}})));
          ProsNet.BoundaryConditions.SolarGeometry.ZenithAngle zen
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          WeatherData.Bus weaBus annotation (Placement(transformation(extent={{-52,14},
                    {-12,54}}), iconTransformation(extent={{-232,-2},{-212,18}})));
        equation
          connect(zen.y, relAirMas.zen) annotation (Line(
              points={{1,10},{18,10}},
              color={0,0,127}));
          connect(weaDat.weaBus, zen.weaBus) annotation (Line(
              points={{-40,10},{-20,10}},
              color={255,204,51},
              thickness=0.5));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-40,10},{-32,10},{-32,34}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(weaBus.alt, relAirMas.alt) annotation (Line(
              points={{-32,34},{12,34},{12,22},{18,22}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          annotation (
        Documentation(info="<html>
<p>
This example computes the relative air mass for sky brightness.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=864000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/BaseClasses/Examples/RelativeAirMass.mos"
                "Simulate and plot"));
        end RelativeAirMass;

        model SkyBrightness "Test model for sky brightness"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.RelativeAirMass
            relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{20,30},{40,50}})));
          ProsNet.BoundaryConditions.SolarGeometry.ZenithAngle zen
            "Zenith angle"
            annotation (Placement(transformation(extent={{-26,20},{-6,40}})));
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.SkyBrightness
            skyBri "Sky brightness"
            annotation (Placement(transformation(extent={{60,-20},{80,0}})));
          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
            "Weather data"
            annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus "Weather data bus"
            annotation (Placement(transformation(extent={{-50,-20},{-30,0}}),
                iconTransformation(extent={{-22,-20},{-22,-20}})));
        equation
          connect(zen.y, relAirMas.zen) annotation (Line(
              points={{-5,30},{8,30},{8,34},{18,34}},
              color={0,0,127}));
          connect(relAirMas.relAirMas, skyBri.relAirMas) annotation (Line(
              points={{41,40},{50,40},{50,-4},{58,-4}},
              color={0,0,127}));
          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-60,-10},{-40,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.HDifHor, skyBri.HDifHor) annotation (Line(
              points={{-40,-10},{58,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(zen.weaBus, weaBus) annotation (Line(
              points={{-26,30},{-30,30},{-30,-10},{-40,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.solTim, skyBri.solTim) annotation (Line(
              points={{-40,-10},{-40,-16},{58,-16}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(weaBus.alt, relAirMas.alt) annotation (Line(
              points={{-40,-10},{-40,50},{8,50},{8,46},{18,46}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,6},{-3,6}},
              horizontalAlignment=TextAlignment.Right));
          annotation (
        Documentation(info="<html>
<p>
This example computes the sky brightness.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Changed extraterrestrial radiation and added time dependent correlation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=8640000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/BaseClasses/Examples/SkyBrightness.mos"
                "Simulate and plot"));
        end SkyBrightness;

        model SkyClearness "Test model for sky clearness"
          extends Modelica.Icons.Example;

          ProsNet.BoundaryConditions.SolarGeometry.ZenithAngle zen
            annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
          ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.SkyClearness skyCle
            annotation (Placement(transformation(extent={{40,0},{60,20}})));

          ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
                Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
            annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
          ProsNet.BoundaryConditions.WeatherData.Bus weaBus
            annotation (Placement(transformation(extent={{-2,20},{18,40}})));
        equation
          connect(zen.y, skyCle.zen) annotation (Line(
              points={{-19,-10},{10,-10},{10,4},{38,4}},
              color={0,0,127}));

          connect(weaDat.weaBus, weaBus) annotation (Line(
              points={{-20,30},{8,30}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.HDirNor, skyCle.HDirNor) annotation (Line(
              points={{8,30},{24,30},{24,16},{38,16}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.HDifHor, skyCle.HDifHor) annotation (Line(
              points={{8,30},{24,30},{24,10},{38,10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));

          connect(weaBus, zen.weaBus) annotation (Line(
              points={{8,30},{8,12},{-54,12},{-54,-10},{-40,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              textString="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          annotation (
        Documentation(info="<html>
<p>
This example computes the sky clearness.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(StartTime=100000, Tolerance=1e-6, StopTime=3000000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/SolarIrradiation/BaseClasses/Examples/SkyClearness.mos"
                "Simulate and plot"));
        end SkyClearness;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation.BaseClasses\">
Buildings.BoundaryConditions.SolarIrradiation.BaseClasses</a>.
</p>
</html>"));
      end Examples;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation\">Buildings.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models that compute the solar irradiation
with different sky models.
</html>"));
  end SolarIrradiation;

  package WeatherData "Weather data reader"
    extends Modelica.Icons.VariantsPackage;

    expandable connector Bus "Data bus that stores weather data"
      extends Modelica.Icons.SignalBus;

      Modelica.Units.SI.Temperature TDryBul "Dry bulb temperature";
      Modelica.Units.SI.Temperature TWetBul "Wet bulb temperature";
      Modelica.Units.SI.Temperature TDewPoi "Dew point temperature";
      Modelica.Units.SI.Temperature TBlaSky "Black-body sky temperature";

      Real relHum(final unit="1") "Relative humidity";

      Real HDirNor(final unit="W/m2") "Direct normal solar irradiation";
      Real HGloHor(final unit="W/m2") "Global horizontal solar irradiation";
      Real HDifHor(final unit="W/m2") "Diffuse horizontal solar irradiation";

      Real HHorIR(final unit="W/m2") "Horizontal infrared irradiation";

      Modelica.Units.SI.Angle winDir "Wind direction";
      Modelica.Units.SI.Velocity winSpe "Wind speed";

      Modelica.Units.SI.Height ceiHei "Cloud cover ceiling height";
      Real nOpa(final unit="1") "Opaque sky cover";
      Real nTot(final unit="1") "Total sky cover";

      Modelica.Units.SI.Angle lat "Latitude of the location";
      Modelica.Units.SI.Angle lon "Longitude of the location";
      Modelica.Units.SI.Height alt "Location altitude above sea level";

      Modelica.Units.SI.AbsolutePressure pAtm "Atmospheric pressure";

      Modelica.Units.SI.Angle solAlt "Solar altitude angle";
      Modelica.Units.SI.Angle solDec "Solar declination angle";
      Modelica.Units.SI.Angle solHouAng "Solar hour angle";
      Modelica.Units.SI.Angle solZen "Solar zenith angle";

      Modelica.Units.SI.Time solTim "Solar time";
      Modelica.Units.SI.Time cloTim "Model time";

      annotation (
        defaultComponentName="weaBus",
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={Rectangle(
              extent={{-20,2},{22,-2}},
              lineColor={255,204,51},
              lineThickness=0.5)}),
        Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 22, 2023, by Michael Wetter:<br/>
Declared the variables that are on the bus.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1798\">IBPSA, #1798</a>.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Bus;

    block ReaderTMY3 "Reader for TMY3 weather data"

      Bus weaBus "Weather data bus" annotation (Placement(transformation(extent={{
                290,-10},{310,10}}), iconTransformation(extent={{190,-10},{210,10}})));

      //--------------------------------------------------------------
      parameter String filNam="" "Name of weather data file" annotation (
        Dialog(loadSelector(filter="Weather files (*.mos)",
                            caption="Select weather file")));

      parameter Boolean computeWetBulbTemperature = true
        "If true, then this model computes the wet bulb temperature"
        annotation(Evaluate=true);

      //--------------------------------------------------------------
      // Atmospheric pressure
      parameter ProsNet.BoundaryConditions.Types.DataSource pAtmSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter
        "Atmospheric pressure" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.Pressure pAtm=101325
        "Atmospheric pressure (used if pAtmSou=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput pAtm_in(
        final quantity="Pressure",
        final unit="Pa",
        displayUnit="Pa")
        if (pAtmSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input pressure"
        annotation (Placement(transformation(extent={{-240,254},{-200,294}}),
            iconTransformation(extent={{-240,254},{-200,294}})));

      //--------------------------------------------------------------
      // Dry bulb temperature
      parameter ProsNet.BoundaryConditions.Types.DataSource TDryBulSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Dry bulb temperature" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.Temperature TDryBul(displayUnit="degC") = 293.15
        "Dry bulb temperature (used if TDryBul=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput TDryBul_in(
        final quantity="ThermodynamicTemperature",
        final unit="K",
        displayUnit="degC")
        if (TDryBulSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input dry bulb temperature"
        annotation (Placement(transformation(extent={{-240,160},{-200,200}})));

      //--------------------------------------------------------------
      // Dew point temperature
      parameter ProsNet.BoundaryConditions.Types.DataSource TDewPoiSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Dew point temperature" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.Temperature TDewPoi(displayUnit="degC") = 283.15
        "Dew point temperature (used if TDewPoi=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput TDewPoi_in(
        final quantity="ThermodynamicTemperature",
        final unit="K",
        displayUnit="degC")
        if (TDewPoiSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input dew point temperature"
        annotation (Placement(transformation(extent={{-240,204},{-200,244}})));

      //--------------------------------------------------------------
      // Black body sky temperature
      parameter ProsNet.BoundaryConditions.Types.DataSource TBlaSkySou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Black-body sky temperature" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.Temperature TBlaSky=273.15
        "Black-body sky temperature (used if TBlaSkySou=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput TBlaSky_in(
        final quantity="ThermodynamicTemperature",
        displayUnit="degC",
        final unit="K")
        if (TBlaSkySou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Black-body sky temperature"
        annotation (Placement(transformation(extent={{-240,120},{-200,160}}),
            iconTransformation(extent={{-240,120},{-200,160}})));
      //--------------------------------------------------------------
      // Relative humidity
      parameter ProsNet.BoundaryConditions.Types.DataSource relHumSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Relative humidity" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Real relHum(
        min=0,
        max=1,
        unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput relHum_in(
        min=0,
        max=1,
        unit="1")
        if (relHumSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input relative humidity"
        annotation (Placement(transformation(extent={{-240,80},{-200,120}}),
            iconTransformation(extent={{-240,80},{-200,120}})));
      //--------------------------------------------------------------
      // Wind speed
      parameter ProsNet.BoundaryConditions.Types.DataSource winSpeSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Wind speed" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.Velocity winSpe(min=0) = 1
        "Wind speed (used if winSpe=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput winSpe_in(
        final quantity="Velocity",
        final unit="m/s",
        min=0)
        if (winSpeSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input wind speed"
        annotation (Placement(transformation(extent={{-240,-98},{-200,-58}}),
            iconTransformation(extent={{-240,-98},{-200,-58}})));
      //--------------------------------------------------------------
      // Wind direction
      parameter ProsNet.BoundaryConditions.Types.DataSource winDirSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Wind direction" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.Angle winDir=1.0
        "Wind direction (used if winDir=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput winDir_in(
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg")
        if (winDirSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input wind direction"
        annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),
            iconTransformation(extent={{-240,-140},{-200,-100}})));
      //--------------------------------------------------------------
      // Infrared horizontal radiation
      parameter ProsNet.BoundaryConditions.Types.DataSource HInfHorSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Infrared horizontal radiation" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Modelica.Units.SI.HeatFlux HInfHor=0.0
        "Infrared horizontal radiation (used if HInfHorSou=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput HInfHor_in(
        final quantity="RadiantEnergyFluenceRate",
        final unit="W/m2")
        if (HInfHorSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input infrared horizontal radiation"
        annotation (Placement(transformation(extent={{-240,-180},{-200,-140}}),
            iconTransformation(extent={{-240,-180},{-200,-140}})));

       parameter ProsNet.BoundaryConditions.Types.RadiationDataSource HSou=ProsNet.BoundaryConditions.Types.RadiationDataSource.File
        "Global, diffuse, and direct normal radiation" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      //--------------------------------------------------------------
      // Global horizontal radiation
      Modelica.Blocks.Interfaces.RealInput HGloHor_in(
        final quantity="RadiantEnergyFluenceRate",
        final unit="W/m2") if (HSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor
         or HSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
        "Input global horizontal radiation"
        annotation (Placement(transformation(extent={{-240,-320},{-200,-280}}),
            iconTransformation(extent={{-240,-280},{-200,-240}})));
      //--------------------------------------------------------------
      // Diffuse horizontal radiation
      Modelica.Blocks.Interfaces.RealInput HDifHor_in(
        final quantity="RadiantEnergyFluenceRate",
        final unit="W/m2") if (HSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor
         or HSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor)
        "Input diffuse horizontal radiation"
        annotation (Placement(transformation(extent={{-240,-240},{-200,-200}}),
            iconTransformation(extent={{-240,-210},{-200,-170}})));
      //--------------------------------------------------------------
      // Direct normal radiation
      Modelica.Blocks.Interfaces.RealInput HDirNor_in(final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor
         or HSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
        "Input direct normal radiation"
        annotation (Placement(transformation(extent={{-240,-280},{-200,-240}}),
            iconTransformation(extent={{-240,-240},{-200,-200}})));

    //--------------------------------------------------------------
      // Ceiling height
      parameter ProsNet.BoundaryConditions.Types.DataSource ceiHeiSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Ceiling height" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Real ceiHei(
        final quantity="Height",
        final unit="m",
        displayUnit="m") = 20000 "Ceiling height (used if ceiHei=Parameter)"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput ceiHei_in(
        final quantity="Height",
        final unit="m",
        displayUnit="m")
        if (ceiHeiSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input ceiling height"
        annotation (Placement(transformation(extent={{-240,-10},{-200,30}}),
            iconTransformation(extent={{-240,-10},{-200,30}})));
      //--------------------------------------------------------------
      // Total sky cover
      parameter ProsNet.BoundaryConditions.Types.DataSource totSkyCovSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Total sky cover" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Real totSkyCov(
        min=0,
        max=1,
        unit="1") = 0.5
        "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput totSkyCov_in(
        min=0,
        max=1,
        unit="1")
        if (totSkyCovSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input total sky cover"
        annotation (Placement(transformation(extent={{-240,-58},{-200,-18}}),
            iconTransformation(extent={{-240,-58},{-200,-18}})));
      // Opaque sky cover
      parameter ProsNet.BoundaryConditions.Types.DataSource opaSkyCovSou=ProsNet.BoundaryConditions.Types.DataSource.File
        "Opaque sky cover" annotation (
        Evaluate=true,
        HideResult=true,
        Dialog(tab="Data source"));
      parameter Real opaSkyCov(
        min=0,
        max=1,
        unit="1") = 0.5
        "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1"
        annotation (Dialog(tab="Data source"));
      Modelica.Blocks.Interfaces.RealInput opaSkyCov_in(
        min=0,
        max=1,
        unit="1")
        if (opaSkyCovSou == ProsNet.BoundaryConditions.Types.DataSource.Input)
        "Input opaque sky cover"
        annotation (Placement(transformation(extent={{-240,32},{-200,72}}),
            iconTransformation(extent={{-240,32},{-200,72}})));

      parameter ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.
           TemperaturesAndSkyCover
        "Model choice for black-body sky temperature calculation" annotation (
        choicesAllMatching=true,
        Evaluate=true,
        Dialog(tab="Advanced", group="Sky temperature"));

      final parameter Modelica.Units.SI.Angle lon(displayUnit="deg") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(  filNam)
        "Longitude";
      final parameter Modelica.Units.SI.Angle lat(displayUnit="deg") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(  filNam)
        "Latitude";
      final parameter Modelica.Units.SI.Time timZon(displayUnit="h") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(  filNam)
        "Time zone";
      final parameter Modelica.Units.SI.Length alt(displayUnit="m") =
        ProsNet.BoundaryConditions.WeatherData.BaseClasses.getAltitudeLocationTMY3(
        filNam) "Location altitude above sea level";

      Utilities.Time.ModelTime modTim
        annotation (Placement(transformation(extent={{-372,-10},{-352,10}})));
      Utilities.Psychrometrics.TWetBul_TDryBulPhi tWetBul_TDryBulXi(redeclare
          package Medium = Buildings.Media.Air)
        annotation (Placement(transformation(extent={{326,-62},{360,-28}})));
    protected
      final parameter Modelica.Units.SI.Time[2] timeSpan=
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(  filNam,
          "tab1") "Start time, end time of weather data";

      Modelica.Blocks.Tables.CombiTable1Ds datRea(
        final tableOnFile=true,
        final tableName="tab1",
        final fileName=filNam,
        verboseRead=false,
        final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
        final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
            28,29,30,8}) "Data reader"
        annotation (Placement(transformation(extent={{-70,-40},{-50,-20}})));

      BaseClasses.SourceSelector pAtmSel(
        final datSou=pAtmSou,
        final p=pAtm) "Source selection for atmospheric pressure"
        annotation (Placement(transformation(extent={{0,260},{20,280}})));
      BaseClasses.SourceSelector TDewPoiSel(
        final datSou=TDewPoiSou,
        final p=TDewPoi)
        "Source selection for dewpoint temperature pressure"
        annotation (Placement(transformation(extent={{92,-240},{112,-220}})));
      BaseClasses.SourceSelector TDryBulSel(
        final datSou=TDryBulSou,
        final p=TDryBul)
        "Source selection for drybulb temperature pressure"
        annotation (Placement(transformation(extent={{92,-200},{112,-180}})));
      BaseClasses.SourceSelector TBlaSkySel(
        final datSou=TBlaSkySou,
        final p=TBlaSky)
        "Source selection for sky black body radiation"
        annotation (Placement(transformation(extent={{240,-180},{260,-160}})));
      BaseClasses.SourceSelector relHumSel(
        final datSou=relHumSou,
        final p=relHum)
        "Source selection for relative humidity"
        annotation (Placement(transformation(extent={{120,20},{140,40}})));
      BaseClasses.SourceSelector opaSkyCovSel(
        final datSou=opaSkyCovSou,
        final p=opaSkyCov)
        "Source selection for opaque sky cover"
        annotation (Placement(transformation(extent={{120,-160},{140,-140}})));
      BaseClasses.SourceSelector ceiHeiSel(
        final datSou=ceiHeiSou,
        final p=ceiHei)
        "Source selection for ceiling height"
        annotation (Placement(transformation(extent={{120,-120},{140,-100}})));
      BaseClasses.SourceSelector totSkyCovSel(
        final datSou=totSkyCovSou,
        final p=totSkyCov)
        "Source selection for total sky cover"
        annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
      BaseClasses.SourceSelector winSpeSel(
        final datSou=winSpeSou,
        final p=winSpe)
        "Source selection for wind speed"
        annotation (Placement(transformation(extent={{120,-80},{140,-60}})));
      BaseClasses.SourceSelector winDirSel(
        final datSou=winDirSou,
        final p=winDir)
        "Source selection for wind speed"
        annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
      BaseClasses.SourceSelector horInfRadSel(
        final datSou=HInfHorSou,
        final p=HInfHor)
        "Source selection for horizontal infrared radiation"
        annotation (Placement(transformation(extent={{120,60},{140,80}})));
      BaseClasses.SourceSelectorRadiation souSelRad(
        final datSou=HSou)
        "Source selection for solar irradiation"
        annotation (Placement(transformation(extent={{120,180},{140,200}})));

      BaseClasses.CheckDryBulbTemperature
        cheTemDryBul "Check dry bulb temperature "
        annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.CheckDewPointTemperature
        cheTemDewPoi "Check dew point temperature"
        annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
      Modelica.Blocks.Math.Gain conRelHum(final k=0.01)
        if relHumSou == ProsNet.BoundaryConditions.Types.DataSource.File
        "Convert the relative humidity from percentage to [0, 1] "
        annotation (Placement(transformation(extent={{40,14},{60,34}})));
      BaseClasses.CheckPressure chePre "Check the air pressure"
        annotation (Placement(transformation(extent={{160,260},{180,280}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterRelativeHumidity
        limRelHum "Limiter for relative humidity"
        annotation (Placement(transformation(extent={{160,20},{180,40}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterTotalSkyCover limTotSkyCov
        "Limits the total sky cover"
        annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterOpaqueSkyCover limOpaSkyCov
        "Limits the opaque sky cover"
        annotation (Placement(transformation(extent={{160,-160},{180,-140}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterCeilingHeight limCeiHei
        "Limits the ceiling height"
        annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterWindSpeed limWinSpe
        "Limits the wind speed"
        annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterHorizontalInfraredIrradiation
        limHorInfRad "Limits the horizontal infrared irradiation"
        annotation (Placement(transformation(extent={{160,60},{180,80}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterWindDirection limWinDir
        "Limits the wind direction"
        annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
      SkyTemperature.BlackBody TBlaSkyCom(final calTSky=calTSky)
        if TBlaSkySou == ProsNet.BoundaryConditions.Types.DataSource.File
        "Computation of the black-body sky temperature"
        annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
      Modelica.Blocks.Math.Add add30Min
        "Add 30 minutes to time to shift weather data reader"
        annotation (Placement(transformation(extent={{-112,180},{-92,200}})));
      Modelica.Blocks.Sources.Constant con30Min(final k=1800)
        "Constant used to shift weather data reader"
        annotation (Placement(transformation(extent={{-160,186},{-140,206}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(final lon
          =lon, final timZon=timZon) "Local civil time" annotation (Placement(
            transformation(extent={{-118,-160},{-98,-140}})));
      Modelica.Blocks.Tables.CombiTable1Ds datRea30Min(
        final tableOnFile=true,
        final tableName="tab1",
        final fileName=filNam,
        verboseRead=false,
        final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
        final columns=9:11) "Data reader with 30 min offset for solar irradiation"
        annotation (Placement(transformation(extent={{-50,180},{-30,200}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTimMin(final
          weaDatStaTim=timeSpan[1], final weaDatEndTim=timeSpan[2])
        "Convert simulation time to calendar time"
        annotation (Placement(transformation(extent={{-80,180},{-60,200}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(final
          weaDatStaTim=timeSpan[1], final weaDatEndTim=timeSpan[2])
        "Convert simulation time to calendar time"
        annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
      BaseClasses.EquationOfTime eqnTim "Equation of time"
        annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
      BaseClasses.SolarTime solTim "Solar time"
        annotation (Placement(transformation(extent={{-88,-140},{-68,-120}})));

      Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
        "Convert the wind direction unit from [deg] to [rad]"
        annotation (Placement(transformation(extent={{40,-286},{60,-266}})));
      Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
        annotation (Placement(transformation(extent={{40,-200},{60,-180}})));

      Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
        "Convert the dew point temperature form [degC] to [K]"
        annotation (Placement(transformation(extent={{40,-240},{60,-220}})));
      SolarGeometry.BaseClasses.AltitudeAngle altAng "Solar altitude angle"
        annotation (Placement(transformation(extent={{-28,-226},{-8,-206}})));
       SolarGeometry.BaseClasses.ZenithAngle zenAng
                          "Zenith angle"
        annotation (Placement(transformation(extent={{-70,-226},{-50,-206}})));
       SolarGeometry.BaseClasses.Declination decAng "Declination angle"
        annotation (Placement(transformation(extent={{-120,-220},{-100,-200}})));
       SolarGeometry.BaseClasses.SolarHourAngle
        solHouAng "Solar hour angle"
        annotation (Placement(transformation(extent={{-120,-250},{-100,-230}})));
      Latitude latitude(final latitude=lat) "Latitude"
        annotation (Placement(transformation(extent={{-150,-290},{-130,-270}})));
      Longitude longitude(final longitude=lon) "Longitude"
        annotation (Placement(transformation(extent={{-120,-282},{-100,-262}})));
      Altitude altitude(final Altitude=alt) "Altitude"
        annotation (Placement(transformation(extent={{226,94},{246,114}})));
      //---------------------------------------------------------------------------
      // Optional instanciation of a block that computes the wet bulb temperature.
      // This block may be needed for evaporative cooling towers.
      // By default, it is enabled. This introduces a nonlinear equation, but
      // we have not observed an increase in computing time because of this equation.

      //---------------------------------------------------------------------------
      // Conversion blocks for sky cover
      Modelica.Blocks.Math.Gain conTotSkyCov(final k=0.1)
        if totSkyCovSou == ProsNet.BoundaryConditions.Types.DataSource.File
        "Convert sky cover from [0...10] to [0...1]"
        annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
      Modelica.Blocks.Math.Gain conOpaSkyCov(final k=0.1)
        if opaSkyCovSou == ProsNet.BoundaryConditions.Types.DataSource.File
        "Convert sky cover from [0...10] to [0...1]"
        annotation (Placement(transformation(extent={{40,-166},{60,-146}})));
      ProsNet.BoundaryConditions.WeatherData.BaseClasses.CheckBlackBodySkyTemperature
        cheTemBlaSky(TMin=0) "Check black body sky temperature"
        annotation (Placement(transformation(extent={{240,-140},{260,-120}})));

      // Blocks that are added in order to set the name of the output signal,
      // which then is displayed in the GUI of the weather data connector.
      block Latitude "Generate constant signal of type Real"
        extends Modelica.Blocks.Icons.Block;

        parameter Modelica.Units.SI.Angle latitude "Latitude";

        Modelica.Blocks.Interfaces.RealOutput y(
          unit="rad",
          displayUnit="deg") "Latitude of the location"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        y = latitude;
        annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-81,32},{84,-24}},
              textColor={0,0,0},
                textString="Latitude")}),
        Documentation(info="<html>
<p>
Block to output the latitude of the location.
This block is added so that the latitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the latitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Latitude;

      block Longitude "Generate constant signal of type Real"
        extends Modelica.Blocks.Icons.Block;

        parameter Modelica.Units.SI.Angle longitude "Longitude";

        Modelica.Blocks.Interfaces.RealOutput y(
          unit="rad",
          displayUnit="deg") "Longitude of the location"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        y = longitude;
        annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-81,32},{84,-24}},
              textColor={0,0,0},
                textString="Longitude")}),
        Documentation(info="<html>
<p>
Block to output the longitude of the location.
This block is added so that the longitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the longitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Longitude;

      block Altitude "Generate constant signal of type Real"
        extends Modelica.Blocks.Icons.Block;

        parameter Modelica.Units.SI.Length Altitude
          "Location altitude above sea level";

        Modelica.Blocks.Interfaces.RealOutput y(
          unit="m") "Location altitude above sea level"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        y = Altitude;
        annotation (
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={
            Text(
              extent={{-81,32},{84,-24}},
              textColor={0,0,0},
                textString="Altitude")}),
        Documentation(info="<html>
<p>
Block to output the altitude of the location.
This block is added so that the altitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the Altitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",     revisions="<html>
<ul>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Altitude;

    equation

      connect(con30Min.y, add30Min.u1)
        annotation (Line(points={{-139,196},{-114,196}}, color={0,0,127}));
      connect(add30Min.y, conTimMin.modTim)
        annotation (Line(points={{-91,190},{-82,190}}, color={0,0,127}));
      connect(conTimMin.calTim, datRea30Min.u)
        annotation (Line(points={{-59,190},{-52,190}}, color={0,0,127}));
      connect(conTim.calTim, datRea.u) annotation (Line(
          points={{-79,-30},{-72,-30}},
          color={0,0,127}));
      connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
          points={{-99,-110},{-94,-110},{-94,-124},{-90,-124}},
          color={0,0,127}));
      connect(locTim.locTim, solTim.locTim) annotation (Line(
          points={{-97,-150},{-96,-150},{-96,-135.4},{-90,-135.4}},
          color={0,0,127}));
      connect(datRea.y[11], conWinDir.u) annotation (Line(
          points={{-49,-30},{20,-30},{20,-276},{38,-276}},
          color={0,0,127}));
      connect(datRea.y[1], conTDryBul.u) annotation (Line(
          points={{-49,-30},{20,-30},{20,-190},{38,-190}},
          color={0,0,127}));
      connect(datRea.y[2], conTDewPoi.u) annotation (Line(
          points={{-49,-30},{20,-30},{20,-230},{38,-230}},
          color={0,0,127}));
      connect(conRelHum.u, datRea.y[3]) annotation (Line(points={{38,24},{20,24},{20,
              -30},{-49,-30}},    color={0,0,127}));

      connect(decAng.decAng, zenAng.decAng)
                                      annotation (Line(
          points={{-99,-210},{-72,-210},{-72,-210.6}},
          color={0,0,127}));
      connect(solHouAng.solHouAng, zenAng.solHouAng)  annotation (Line(
          points={{-99,-240},{-80,-240},{-80,-220.8},{-72,-220.8}},
          color={0,0,127}));
      connect(solHouAng.solTim, solTim.solTim) annotation (Line(
          points={{-122,-240},{-140,-240},{-140,-174},{-10,-174},{-10,-130},{-67,-130}},
          color={0,0,127}));
      connect(zenAng.zen, altAng.zen) annotation (Line(
          points={{-49,-216},{-30,-216}},
          color={0,0,127}));

      connect(limOpaSkyCov.nOpa, TBlaSkyCom.nOpa) annotation (Line(points={{181,-150},
              {220,-150},{220,-213},{238,-213}}, color={0,0,127}));

      connect(pAtmSel.y, chePre.PIn)
        annotation (Line(points={{21,270},{158,270}},   color={0,0,127}));
      connect(pAtmSel.uCon, pAtm_in) annotation (Line(points={{-1,278},{-110,278},{-110,
              274},{-220,274}}, color={0,0,127}));
      connect(datRea.y[4], pAtmSel.uFil) annotation (Line(points={{-49,-30},{-20,-30},
              {-20,262},{-1,262}}, color={0,0,127}));
      connect(cheTemDewPoi.TIn, TDewPoiSel.y)
        annotation (Line(points={{158,-230},{113,-230}}, color={0,0,127}));
      connect(TDewPoiSel.uFil, conTDewPoi.y) annotation (Line(points={{91,-238},{76,
              -238},{76,-230},{61,-230}}, color={0,0,127}));
      connect(TDewPoiSel.uCon, TDewPoi_in) annotation (Line(points={{91,-222},{82,-222},
              {82,146},{-168,146},{-168,224},{-220,224}}, color={0,0,127}));
      connect(TDryBulSel.y, cheTemDryBul.TIn)
        annotation (Line(points={{113,-190},{158,-190}}, color={0,0,127}));
      connect(TDryBulSel.uFil, conTDryBul.y) annotation (Line(points={{91,-198},{70,
              -198},{70,-190},{61,-190}}, color={0,0,127}));
      connect(TDryBulSel.uCon, TDryBul_in) annotation (Line(points={{91,-182},{78,-182},
              {78,142},{-176,142},{-176,180},{-220,180}}, color={0,0,127}));

      connect(TBlaSkySel.y, cheTemBlaSky.TIn) annotation (Line(points={{261,-170},{270,
              -170},{270,-148},{230,-148},{230,-130},{238,-130}}, color={0,0,127}));
      connect(TBlaSkyCom.TBlaSky, TBlaSkySel.uFil) annotation (Line(points={{261,-210},
              {268,-210},{268,-186},{232,-186},{232,-178},{239,-178}}, color={0,0,127}));
      connect(TBlaSky_in, TBlaSkySel.uCon) annotation (Line(points={{-220,140},{74,140},
              {74,-168},{228,-168},{228,-162},{239,-162}}, color={0,0,127}));
      connect(relHumSel.y, limRelHum.u)
        annotation (Line(points={{141,30},{158,30}}, color={0,0,127}));
      connect(relHumSel.uFil, conRelHum.y)
        annotation (Line(points={{119,22},{90,22},{90,24},{61,24}},
                                                     color={0,0,127}));
      connect(relHum_in, relHumSel.uCon) annotation (Line(points={{-220,100},{110,100},
              {110,38},{119,38}}, color={0,0,127}));
      connect(conOpaSkyCov.y, opaSkyCovSel.uFil)
        annotation (Line(points={{61,-156},{90,-156},{90,-158},{119,-158}},
                                                        color={0,0,127}));
      connect(opaSkyCov_in, opaSkyCovSel.uCon) annotation (Line(points={{-220,52},{70,
              52},{70,-142},{119,-142}}, color={0,0,127}));
      connect(ceiHeiSel.y, limCeiHei.u)
        annotation (Line(points={{141,-110},{158,-110}}, color={0,0,127}));
      connect(ceiHeiSel.uFil, datRea.y[16]) annotation (Line(points={{119,-118},{20,
              -118},{20,-30},{-49,-30}}, color={0,0,127}));
      connect(ceiHeiSel.uCon, ceiHei_in) annotation (Line(points={{119,-102},{-40,-102},
              {-40,-90},{-180,-90},{-180,10},{-220,10}}, color={0,0,127}));
      connect(totSkyCovSel.uFil, conTotSkyCov.y) annotation (Line(points={{119,-38},
              {100,-38},{100,-30},{61,-30}}, color={0,0,127}));
      connect(totSkyCovSel.uCon, totSkyCov_in) annotation (Line(points={{119,-22},{108,
              -22},{108,-50},{-190,-50},{-190,-38},{-220,-38}}, color={0,0,127}));
      connect(totSkyCovSel.y, limTotSkyCov.u)
        annotation (Line(points={{141,-30},{158,-30}}, color={0,0,127}));
      connect(winSpeSel.y, limWinSpe.u)
        annotation (Line(points={{141,-70},{158,-70}}, color={0,0,127}));
      connect(conTotSkyCov.u, datRea.y[13])
        annotation (Line(points={{38,-30},{-49,-30}}, color={0,0,127}));
      connect(winSpeSel.uFil, datRea.y[12]) annotation (Line(points={{119,-78},{-20,
              -78},{-20,-30},{-49,-30}}, color={0,0,127}));
      connect(winSpeSel.uCon, winSpe_in) annotation (Line(points={{119,-62},{-190,-62},
              {-190,-78},{-220,-78}}, color={0,0,127}));
      connect(winDirSel.y, limWinDir.u)
        annotation (Line(points={{141,-270},{158,-270}}, color={0,0,127}));
      connect(conWinDir.y, winDirSel.uFil)
        annotation (Line(points={{61,-276},{90,-276},{90,-278},{119,-278}},
                                                        color={0,0,127}));
      connect(winDirSel.uCon, winDir_in) annotation (Line(points={{119,-262},{66,-262},
              {66,-80},{-190,-80},{-190,-120},{-220,-120}}, color={0,0,127}));
      connect(conOpaSkyCov.u, datRea.y[14]) annotation (Line(points={{38,-156},{20,-156},
              {20,-30},{-49,-30}},       color={0,0,127}));
      connect(horInfRadSel.y, limHorInfRad.u) annotation (Line(points={{141,70},{158,
              70}},                      color={0,0,127}));
      connect(horInfRadSel.uFil, datRea.y[26]) annotation (Line(points={{119,62},{20,
              62},{20,-30},{-49,-30}},  color={0,0,127}));
      connect(horInfRadSel.uCon, HInfHor_in) annotation (Line(points={{119,78},{-174,
              78},{-174,-160},{-220,-160}},  color={0,0,127}));

      connect(souSelRad.HDifHorFil, datRea30Min.y[3]) annotation (Line(points={{119,199},
              {44,199},{44,190},{-29,190}}, color={0,0,127}));
      connect(souSelRad.HDifHorIn, HDifHor_in) annotation (Line(points={{119,196},{
              98,196},{98,166},{-170,166},{-170,-220},{-220,-220}},
                                                                 color={0,0,127}));
      connect(souSelRad.HDirNorFil, datRea30Min.y[2]) annotation (Line(points={{119,192},
              {44,192},{44,190},{-29,190}}, color={0,0,127}));
      connect(souSelRad.HDirNorIn, HDirNor_in) annotation (Line(points={{119,188},{
              100,188},{100,160},{-168,160},{-168,-260},{-220,-260}},
                                                                  color={0,0,127}));
      connect(souSelRad.HGloHorIn, HGloHor_in) annotation (Line(points={{119,181},{
              102,181},{102,156},{-164,156},{-164,-300},{-220,-300}},
                                                                  color={0,0,127}));
      connect(souSelRad.zen, zenAng.zen) annotation (Line(points={{124,179},{124,
              152},{-40,152},{-40,-216},{-49,-216}},
                                                color={0,0,127}));
      connect(souSelRad.HGloHorFil, datRea30Min.y[1]) annotation (Line(points={{119,
              184},{44,184},{44,190},{-29,190}}, color={0,0,127}));

      connect(TBlaSkyCom.HHorIR, limHorInfRad.HHorIR) annotation (Line(points={{238,
              -218},{220,-218},{220,70},{181,70}}, color={0,0,127}));

      connect(opaSkyCovSel.y, limOpaSkyCov.u)
        annotation (Line(points={{141,-150},{158,-150}}, color={0,0,127}));
      connect(cheTemDryBul.TDryBul, TBlaSkyCom.TDryBul) annotation (Line(points={{
              181,-190},{220,-190},{220,-202},{238,-202}}, color={0,0,127}));

      connect(cheTemDewPoi.TDewPoi, TBlaSkyCom.TDewPoi) annotation (Line(points={{
              181,-230},{220,-230},{220,-207},{238,-207}}, color={0,0,127}));

      // Connections to weather data bus
      connect(cheTemDryBul.TDryBul, weaBus.TDryBul) annotation (Line(points={{181,
              -190},{220,-190},{220,0.05},{300.05,0.05}},
                                                 color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(cheTemDewPoi.TDewPoi, weaBus.TDewPoi) annotation (Line(points={{181,
              -230},{280,-230},{280,0.05},{300.05,0.05}},
                                                 color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(limRelHum.relHum, weaBus.relHum) annotation (Line(points={{181,30},
              {280,30},{280,0.05},{300.05,0.05}},
                                color={0,0,127}), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(souSelRad.HDirNor, weaBus.HDirNor) annotation (Line(points={{141,190},
              {220,190},{220,0.05},{300.05,0.05}},
                                          color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));
      connect(souSelRad.HDifHor, weaBus.HDifHor) annotation (Line(points={{141,
              197.8},{220,197.8},{220,0.05},{300.05,0.05}},
                                            color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(souSelRad.HGloHor, weaBus.HGloHor) annotation (Line(points={{141,182},
              {220,182},{220,0.05},{300.05,0.05}},
                                          color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(cheTemBlaSky.TBlaSky, weaBus.TBlaSky) annotation (Line(points={{261,
              -130},{280,-130},{280,0.05},{300.05,0.05}},
                                                 color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));
      connect(limHorInfRad.HHorIR, weaBus.HHorIR) annotation (Line(points={{181,70},
              {220,70},{220,0.05},{300.05,0.05}},
                                         color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(limWinSpe.winSpe, weaBus.winSpe) annotation (Line(points={{181,-70},
              {220,-70},{220,0.05},{300.05,0.05}},
                                     color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(limWinDir.winDir, weaBus.winDir) annotation (Line(points={{181,
              -270},{280,-270},{280,0.05},{300.05,0.05}},
                                      color={0,0,127}), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(limCeiHei.ceiHei, weaBus.ceiHei) annotation (Line(points={{181,
              -110},{220,-110},{220,0.05},{300.05,0.05}},
                                          color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(limTotSkyCov.nTot, weaBus.nTot) annotation (Line(points={{181,-30},
              {220,-30},{220,0.05},{300.05,0.05}},
                                     color={0,0,127}), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));
      connect(limOpaSkyCov.nOpa, weaBus.nOpa) annotation (Line(points={{181,
              -150},{220,-150},{220,0.05},{300.05,0.05}},
                                      color={0,0,127}), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(solTim.solTim, weaBus.solTim) annotation (Line(
          points={{-67,-130},{-10,-130},{-10,0.05},{300.05,0.05}},
          color={0,0,127}), Text(
          textString="%second",
          index=1,
          extent={{6,3},{6,3}}));

      connect(altAng.alt, weaBus.solAlt) annotation (Line(
          points={{-7,-216},{0,-216},{0,-290},{290,-290},{290,0.05},{300.05,
              0.05}},
          color={0,0,127}));
      connect(zenAng.zen, weaBus.solZen) annotation (Line(
          points={{-49,-216},{-40,-216},{-40,-290},{290,-290},{290,0.05},{
              300.05,0.05}},
          color={0,0,127}));
      connect(decAng.decAng, weaBus.solDec) annotation (Line(
          points={{-99,-210},{-90,-210},{-90,-290},{290,-290},{290,0.05},{
              300.05,0.05}},
          color={0,0,127}));
      connect(solHouAng.solHouAng, weaBus.solHouAng) annotation (Line(
          points={{-99,-240},{-90,-240},{-90,-290},{290,-290},{290,0.05},{
              300.05,0.05}},
          color={0,0,127}));
      connect(longitude.y, weaBus.lon) annotation (Line(
          points={{-99,-272},{-90,-272},{-90,-290},{290,-290},{290,0.05},{
              300.05,0.05}},
          color={0,0,127}));
      connect(latitude.y, weaBus.lat) annotation (Line(
          points={{-129,-280},{-124,-280},{-124,-290},{290,-290},{290,0.05},{
              300.05,0.05}},
          color={0,0,127}));
      connect(altitude.y, weaBus.alt) annotation (Line(points={{247,104},{290,
              104},{290,0.05},{300.05,0.05}},
                               color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));
      connect(chePre.pAtm, weaBus.pAtm) annotation (Line(points={{181,270},{220,
              270},{220,0.05},{300.05,0.05}},
                                color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));

      connect(latitude.y, zenAng.lat) annotation (Line(points={{-129,-280},{-124,
              -280},{-124,-290},{-90,-290},{-90,-216},{-72,-216}}, color={0,0,127}));
      connect(modTim.y, decAng.nDay) annotation (Line(points={{-351,0},{-351,
              -46},{-352,-46},{-352,-92},{-244,-92},{-244,-196},{-136,-196},{
              -136,-210},{-122,-210}}, color={0,0,127}));
      connect(modTim.y, add30Min.u2) annotation (Line(points={{-351,0},{-351,
              -38},{-352,-38},{-352,-74},{-244,-74},{-244,-196},{-144,-196},{
              -144,0},{-116,0},{-116,172},{-124,172},{-124,184},{-114,184}},
            color={0,0,127}));
      connect(modTim.y, locTim.cloTim) annotation (Line(points={{-351,0},{-351,
              -28},{-352,-28},{-352,-54},{-244,-54},{-244,-196},{-144,-196},{
              -144,-150},{-120,-150}}, color={0,0,127}));
      connect(modTim.y, conTim.modTim) annotation (Line(points={{-351,0},{-351,
              -16},{-352,-16},{-352,-32},{-244,-32},{-244,-196},{-144,-196},{
              -144,-30},{-102,-30}}, color={0,0,127}));
      connect(modTim.y, eqnTim.nDay) annotation (Line(points={{-351,0},{-351,-2},
              {-244,-2},{-244,-196},{-144,-196},{-144,-110},{-122,-110}}, color
            ={0,0,127}));
      connect(modTim.y, weaBus.cloTim) annotation (Line(points={{-351,0},{-351,
              32},{-352,32},{-352,62},{-244,62},{-244,-196},{-144,-196},{-144,
              0.05},{300.05,0.05}}, color={0,0,127}), Text(
          string="%second",
          index=1,
          extent={{6,3},{6,3}},
          horizontalAlignment=TextAlignment.Left));
      connect(tWetBul_TDryBulXi.TWetBul, weaBus.TWetBul) annotation (Line(
            points={{361.7,-45},{372,-45},{372,0.05},{300.05,0.05}}, color={0,0,
              127}), Text(
          string="%second",
          index=1,
          extent={{-6,3},{-6,3}},
          horizontalAlignment=TextAlignment.Right));
      connect(tWetBul_TDryBulXi.TDryBul, cheTemDryBul.TDryBul) annotation (Line(
            points={{324.3,-31.4},{220,-31.4},{220,-190},{181,-190}}, color={0,
              0,127}));
      connect(tWetBul_TDryBulXi.phi, limRelHum.relHum) annotation (Line(points=
              {{324.3,-45},{216,-45},{216,30},{181,30}}, color={0,0,127}));
      connect(tWetBul_TDryBulXi.p, chePre.pAtm) annotation (Line(points={{324.3,
              -58.6},{212,-58.6},{212,36},{220,36},{220,270},{181,270}}, color=
              {0,0,127}));
        annotation (
        defaultComponentName="weaDat",
        Icon(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-200,-200},{200,200}},
            initialScale=0.05), graphics={
            Rectangle(
              extent={{-200,200},{200,-200}},
              lineColor={124,142,255},
              fillColor={124,142,255},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-162,270},{138,230}},
              textString="%name",
              textColor={0,0,255}),
            Text(
              visible=(pAtmSou == Buildings.BoundaryConditions.Types.DataSource.Input),
              extent={{-190,216},{-164,184}},
              lineColor={0,0,127},
              textString="p"),
            Text(
              visible=(TDryBulSou == Buildings.BoundaryConditions.Types.DataSource.Input),
              extent={{-194,162},{-118,118}},
              lineColor={0,0,127},
              textString="TDryBul"),
            Text(
              visible=(relHumSou == Buildings.BoundaryConditions.Types.DataSource.Input),
              extent={{-190,92},{-104,66}},
              lineColor={0,0,127},
              textString="relHum"),
            Text(
            visible=(winSpeSou == Buildings.BoundaryConditions.Types.DataSource.Input),
              extent={{-196,44},{-110,2}},
              lineColor={0,0,127},
              textString="winSpe"),
            Text(
              visible=(winDirSou == Buildings.BoundaryConditions.Types.DataSource.Input),
              extent={{-192,-18},{-106,-60}},
              lineColor={0,0,127},
              textString="winDir"),
            Text(
            visible=(HSou ==  Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor),
            extent={{-202,-88},{-112,-108}},
              lineColor={0,0,127},
              textString="HGloHor"),
            Text(visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
            extent={{-202,-142},{-116,-164}},
              lineColor={0,0,127},
              textString="HDifHor"),
            Text(
            visible=(HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == Buildings.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
            extent={{-200,-186},{-126,-214}},
              lineColor={0,0,127},
              textString="HDirNor"),
            Ellipse(
              extent={{-146,154},{28,-20}},
              lineColor={255,220,220},
              lineThickness=1,
              fillPattern=FillPattern.Sphere,
              fillColor={255,255,0}),
            Polygon(
              points={{94,106},{77.9727,42.9844},{78,42},{110,52},{138,50},{164,38},
                  {182,-28},{138,-102},{10,-110},{-140,-106},{-166,-30},{-150,24},{-102,
                  26},{-78.2109,8.1582},{-78,8},{-92,70},{-58,120},{34,140},{94,106}},
              lineColor={220,220,220},
              lineThickness=0.1,
              fillPattern=FillPattern.Sphere,
              smooth=Smooth.Bezier,
              fillColor={230,230,230}),
            Text(
              extent={{140,-106},{-126,-192}},
              textColor={255,255,255},
              textString=DynamicSelect("", String(weaBus.TDryBul-273.15, format=".1f")))}),
        Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data.
The Modelica built-in variable <code>time</code> determines what row
of the weather file is read.
The value of <code>time</code> is the number of seconds
that have passed since January 1st at midnight (00:00) in the local time zone.
The local time zone value, longitude and latitute are also read from the weather data,
such that the solar position computations are consistent with the weather data.
</p>
<p>
The weather data format is the Typical Meteorological Year (TMY3)
as obtained from the EnergyPlus web site at
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>. These
data, which are in the EnergyPlus format, need to be converted as described
below.
</p>
<!-- ============================================== -->
<h4>Output to weaBus</h4>
<p>
The following variables serve as output and are accessible via <code>weaBus</code>:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Name
  </th>
  <th>Unit
  </th>
  <th>Description
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal diffuse solar radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifNor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Direct normal radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HGloHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal global radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HHorIR</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal infrared irradiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TBlaSky</code>
  </td>
  <td>
    K
  </td>
  <td>
    Output temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDewPoi</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dew point temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDryBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dry bulb temperature at ground level.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TWetBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Wet bulb temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>celHei</code>
  </td>
  <td>
    m
  </td>
  <td>
    Ceiling height.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>cloTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    One-based day number in seconds.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lat</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Latitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lon</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Longitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nOpa</code>
  </td>
  <td>
    1
  </td>
  <td>
  Opaque sky cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nTot</code>
  </td>
  <td>
    1
  </td>
  <td>
   Total sky Cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>pAtm</code>
  </td>
  <td>
    Pa
  </td>
  <td>
    Atmospheric pressure.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>relHum</code>
  </td>
  <td>
    1
  </td>
  <td>
    Relative humidity.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solAlt</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Altitude angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solDec</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Declination angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solHouAng</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Solar hour angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    Solar time.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solZen</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Zenith angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winDir</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Wind direction.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winSpe</code>
  </td>
  <td>
    m/s
  </td>
  <td>
    Wind speed.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Adding new weather data</h4>
<p>
To add new weather data, proceed as follows:
</p>
<ol>
<li>
Download the weather data file with the <code>epw</code> extension from
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>.
</li>
<li>
Add the file to <code>Buildings/Resources/weatherdata</code> (or to any directory
for which you have write permission).
</li>
<li>
On a console window, type<pre>
  cd Buildings/Resources/weatherdata
  java -jar ../bin/ConvertWeatherData.jar inputFile.epw
</pre>
  if inputFile contains space in the name:
<pre>
  java -jar ../bin/ConvertWeatherData.jar \"inputFile .epw\"
</pre>
This will generate the weather data file <code>inputFile.mos</code>, which can be read
by the model
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.ReaderTMY3\">
Buildings.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</li>
</ol>
<!-- ============================================== -->
<h4>Location data that are read automatically from the weather data file</h4>
<p>
The following location data are automatically read from the weather file:
</p>
<ul>
<li>
The latitude of the weather station, <code>lat</code>,
</li>
<li>
the longitude of the weather station, <code>lon</code>, and
</li>
<li>
the time zone relative to Greenwich Mean Time, <code>timZone</code>.
</li>
</ul>
<!-- ============================================== -->
<h4>Wet bulb temperature</h4>
<p>
By default, the data bus contains the wet bulb temperature.
This introduces a nonlinear equation.
However, we have not observed an increase in computing time because
of this equation.
To disable the computation of the wet bulb temperature, set
<code>computeWetBulbTemperature=false</code>.
</p>
<!-- ============================================== -->
<h4>Using constant or user-defined input signals for weather data</h4>
<p>
This model has the option of using a constant value, using the data from the weather file,
or using data from an input connector for the following variables:
</p>
<ul>
<li>
The atmospheric pressure,
</li>
<li>
the ceiling height,
</li>
<li>
the total sky cover,
</li>
<li>
the opaque sky cover,
</li>
<li>
the dry bulb temperature,
</li>
<li>
the dew point temperature,
</li>
<li>
the sky black body temperature,
</li>
<li>
the relative humidity,
</li>
<li>
the wind direction,
</li>
<li>
the wind speed,
</li>
<li>
the global horizontal radiation, direct normal and diffuse horizontal radiation,
and
</li>
<li>
the infrared horizontal radiation.
</li>
</ul>
<p>
By default, all data are obtained from the weather data file,
except for the atmospheric pressure, which is set to the
parameter <code>pAtm=101325</code> Pascals.
</p>
<p>
The parameter <code>*Sou</code> configures the source of the data.
For the atmospheric pressure, temperatures, relative humidity, wind speed and wind direction,
the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.DataSource\">
Buildings.BoundaryConditions.Types.DataSource</a>
is used as follows:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>*Sou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Parameter
  </td>
  <td>
    Use value specified by the parameter.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input
  </td>
  <td>
    Use value from the input connector.
  </td>
</tr>
</table>
<p>
Because global, diffuse and direct radiation are related to each other, the parameter
<code>HSou</code> is treated differently.
It is set to a value of the enumeration
<a href=\"modelica://Buildings.BoundaryConditions.Types.RadiationDataSource\">
Buildings.BoundaryConditions.Types.RadiationDataSource</a>,
and allows the following configurations:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>HSou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input_HGloHor_HDifHor
  </td>
  <td>
    Use global horizontal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HDifHor
  </td>
  <td>
    Use direct normal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HGloHor
  </td>
  <td>
    Use direct normal and global horizontal radiation from input connector.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Length of weather data and simulation period</h4>
<p>
If weather data span a year, which is the default for TMY3 data, or multiple years,
then this model can be used for simulations that span multiple years. The simulation
start time needs to be set to the clock time of the respective start time. For example,
to start at January 2 at 10am, set start time to <code>t=(24+10)*3600</code> seconds.
For this computation, the used date and time (here January 2, 10 am) must be expressed in the same time zone
as the one that is used to define the TMY3 file. This is usually the local (winter) time zone.
The parameter `timZon` represents the TMY3 file time zone, expressed in seconds compared to UTC.
</p>
<p>
Moreover, weather data need not span a whole year, or it can span across New Year.
In this case, the simulation cannot exceed the time of the weather data file. Otherwise,
the simulation stops with an error.
</p>
<p>
As weather data have one entry at the start of the time interval, the end time of the weather
data file is computed as the last time entry plus the average time increment of the file.
For example, an hourly weather data file has 8760 entries, starting on January 1 at 0:00.
The last entry in the file will be for December 31 at 23:00. As the time increment is 1 hour,
the model assumes the weather file to end at December 31 at 23:00 plus 1 hour, e.g., at January 1 at 0:00.
</p>
<!-- ============================================== -->
<h4>Notes</h4>
<ol>
<li>
<p>
In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model).
This may increase computing time. Therefore, the default value for the atmospheric pressure is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
For medium models for moist air and dry air, the default is
<code>Medium.p_default=101325</code> Pascals.
</p>
</li>
<li>
<p>
Different units apply depending on whether data are obtained from a file, or
from a parameter or an input connector:
</p>
<ul>
<li>
When using TMY3 data from a file (e.g. <code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos</code>), the units must be the same as the original TMY3 file used by EnergyPlus (e.g.
<code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.epw</code>).
The TMY3 data used by EnergyPlus are in both SI units and non-SI units.
If <code>Resources/bin/ConvertWeatherData.jar</code> is used to convert the <code>.epw</code> file to an <code>.mos</code> file, the units of the TMY3 data are preserved and the file can be directly
used by this data reader.
The data reader will automatically convert units to the SI units used by Modelica.
For example, the dry bulb temperature <code>TDryBul</code> in TMY3 is in degree Celsius.
The data reader will automatically convert the data to Kelvin.
The wind direction <code>winDir</code> in TMY3 is degrees and will be automatically converted to radians.
</li>
<li>
When using data from a parameter or from an input connector,
the data must be in the SI units used by Modelica.
For instance, the unit must be
<code>Pa</code> for pressure,
<code>K</code> for temperature,
<code>W/m2</code> for solar radiations and
<code>rad</code> for wind direction.
</li>
</ul>
</li>
<li>
<p>
Hourly and subhourly timestamp are handled in a different way in <code>.epw</code> files.
From the EnergyPlus Auxiliary Programs Document (v9.3.0, p. 63):
In hourly data the minute field can be <code>00</code> or <code>60</code>. In this case as mentioned in the previous section, the weather data
is reported at the hourly value and the minute field has to be ignored, writing <code>1, 60</code> or <code>1, 00</code> is equivalent.
If the minute field is between <code>00</code> and <code>60</code>, the file becomes subhourly, in this case the timestamp corresponds to the
minute field in the considered hour. For example: <code>1, 30</code> is equivalent to <i>00:30</i> and <code>3, 45</code> is equivalent to <i>02:45</i>.<br/>
(Note the offset in the hour digit.)
</p>
</li>
<li>
The ReaderTMY3 should only be used with TMY3 data. It contains a time shift for solar radiation data
that is explained below. This time shift needs to be removed if the user may want to
use the ReaderTMY3 for other weather data types.
</li>
</ol>
<h4>Implementation</h4>
<h5>Start and end data for annual weather data files</h5>
<p>
The TMY3 weather data, as well as the EnergyPlus weather data, start at 1:00 AM
on January 1, and provide hourly data until midnight on December 31.
Thus, the first entry for temperatures, humidity, wind speed etc. are values
at 1:00 AM and not at midnight. Furthermore, the TMY3 weather data files can have
values at midnight of December 31 that may be significantly different from the values
at 1:00 AM on January 1.
Since annual simulations require weather data that start at 0:00 on January 1,
data need to be provided for this hour. Due to the possibly large change in
weatherdata between 1:00 AM on January 1 and midnight at December 31,
the weather data files in the Buildings library do not use the data entry from
midnight at December 31 as the value for <i>t=0</i>. Rather, the
value from 1:00 AM on January 1 is duplicated and used for 0:00 on January 1.
To maintain a data record with <i>8760</i> hours, the weather data record from
midnight at December 31 is deleted.
These changes in the weather data file are done in the Java program
<code>Buildings/Resources/bin/ConvertWeatherData.jar</code> that converts
EnergyPlus weather data file to Modelica weather data files, and which is described
above.
The length of the weather data is calculated as the
end time stamp minus start time stamp plus average increment, where the
average increment is equal to the end time stamp minus start time stamp divided
by the number of rows minus 1.
This only works correctly for weather files with equidistant time stamps.
</p>
<h5>Time shift for solar radiation data</h5>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if
time is shifted by <i>30</i> minutes prior to reading the weather data.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://Buildings/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\"
border=\"1\" />
</p>
<h4>References</h4>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>.
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</html>",     revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Changed alt and lat to real inputs.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Added altitude to parameters.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 4, 2020, by Ettore Zanetti:<br/>
Updated documentation for Java weather file generator.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1396\">#1396</a>.
</li>
<li>
August 20, 2019, by Filip Jorissen:<br/>
Better clarified the meaning of <code>time</code> in the documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1192\">#1192</a>.
</li>
<li>
March 5, 2019, by Michael Wetter:<br/>
Updated documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
September 20, 2018, by Michael Wetter:<br/>
Corrected documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1022\">#1022</a>.
</li>
<li>
December 4, 2017, by Michael Wetter:<br/>
Removed function call to <code>getAbsolutePath</code>, as this causes in Dymola 2018FD01
the error
\"A call of loadResource with a non-literal string remains in the generated code; it will not work for an URI.\"
when exporting <a href=\"modelica://Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone\">
Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone</a>
as an FMU. Instead, if the weather file is specified as a Modelica, URI, syntax such as
<code>Modelica.Utilities.Files.loadResource(\"modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos\")</code>
should be used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/867\">#867</a>.
</li>
<li>
February 18, 2017, by Filip Jorissen:<br/>
Infrared radiation on horizontal surface is now delayed by 30 minutes
such that the results in
<a href=\"modelica://Buildings.BoundaryConditions.SkyTemperature.Examples.BlackBody\">TBlaSky</a>
are consistent.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/648\">#648</a>.
</li>
<li>
December 06, 2016, by Thierry S. Nouidui:<br/>
Constrained the direct normal radiation to not be bigger than the solar constant when using
global and diffuse solar radiation data provided via the inputs connectors.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/608\">#608</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Introduced <code>absFilNam</code> to avoid multiple calls to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed output <code>radHorIR</code> to <code>HHorIR</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
January 4, 2016, by Moritz Lauster:<br/>
Added a table in documentation with output variables accessible via <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
December 15, 2015, by Michael Wetter:<br/>
Added the block <code>cheTemBlaSky</code>. This also allows to graphically
connect the black body sky temperature to the weather bus, which is required
in Dymola 2016 for the variable <code>weaBus.TBlaSky</code> to appear
in the graphical editor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/377\">#377</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed redundant but consistent
<code>connect(TBlaSkyCom.TBlaSky, weaBus.TBlaSky)</code>
statement.
This avoids a warning if
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness\">
Buildings.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness</a>
is translated in pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
March 26, 2015, by Michael Wetter:<br/>
Added option to obtain the black body sky temperature
from a parameter or an input signal.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected error that led the total and opaque sky cover to be ten times
too low if its value was obtained from the parameter or the input connector.
For the standard configuration in which the sky cover is obtained from
the weather data file, the model was correct. This error only affected
the other two possible configurations.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Removed redundant connection <code>connect(conHorRad.HOut, cheHorRad.HIn);</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
May 5, 2013, by Thierry S. Nouidui:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the ceiling height, the total sky cover, the opaque sky cover, the dew point temperature,
and the infrared horizontal radiation <code>HInfHor</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved the algorithm that determines the absolute path of the file.
Now weather files are searched in the path specified, and if not found, the urls
<code>file://</code>, <code>modelica://</code> and <code>modelica://Buildings</code>
are added in this order to search for the weather file.
This allows using the data reader without having to specify an absolute path,
as long as the <code>Buildings</code> library
is on the <code>MODELICAPATH</code>.
This change was implemented in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
and improves this weather data reader.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
October 16, 2012, by Michael Wetter:<br/>
Added computation of the wet bulb temperature.
Computing the wet bulb temperature introduces a nonlinear
equation. As we have not observed an increase in computing time
because of computing the wet bulb temperature, it is computed
by default. By setting the parameter
<code>computeWetBulbTemperature=false</code>, the computation of the
wet bulb temperature can be removed.
Revised documentation.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code> and
improved the optional inputs for radiation data.
</li>
<li>
July 24, 2012, by Wangda Zuo:<br/>
Corrected the notes of SI unit requirements for input files.
</li>
<li>
July 13, 2012, by Michael Wetter:<br/>
Removed assignment of <code>HGloHor_in</code> in its declaration,
because this gives an overdetermined system if the input connector
is used.
Removed non-required assignments of attribute <code>displayUnit</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Added subbus for solar position, which is needed by irradition and
shading model.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed wrong display unit for <code>pAtm_in_internal</code> and
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
<ol>
<li>
Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br/>
</li>
<li>
Separate the unit conversion for TMY3 data and data validity check.
</li>
</ol>
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br/>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br/>
Added wet bulb temperature. Changed reader to read only needed columns.
Added explanation for 30 minutes shift for radiation data.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        Diagram(coordinateSystem(preserveAspectRatio=false,
         extent={{-200,-300},{300,300}})));
    end ReaderTMY3;

    package Examples "Collection of models that illustrate model use and test models"
      extends Modelica.Icons.ExamplesPackage;

      model ReaderTMY3 "Test model for reading weather data"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"))
          "Weather data reader"
          annotation (Placement(transformation(extent={{-20,30},{0,50}})));
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDatInpCon(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"),
            HSou=ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor)
          "Weather data reader with radiation data obtained from input connector"
          annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
        Modelica.Blocks.Sources.Constant HDifHor(k=0) "Diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
        Modelica.Blocks.Sources.Constant HGloHor(k=0) "Horizontal global radiation"
          annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
      equation
        connect(HGloHor.y, weaDatInpCon.HGloHor_in)
                                               annotation (Line(
            points={{-59,-10},{-28,-10},{-28,-63},{-21,-63}},
            color={0,0,127}));
        connect(HDifHor.y, weaDatInpCon.HDifHor_in)
                                               annotation (Line(
            points={{-59,-50},{-40,-50},{-40,-59.5},{-21,-59.5}},
            color={0,0,127}));
        annotation (experiment(Tolerance=1e-6, StartTime=0, StopTime=8640000),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Examples/ReaderTMY3.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
This model tests the TMY3 data reader.
The instance <code>weaDat</code> obtains all weather data from the weather file,
whereas the instance <code>weaDatInpCon</code> obtains the global horizontal and
the diffuse horizontal solar radiation from its input connectors.
</p>
</html>",
      revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ReaderTMY3;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">
Buildings.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
    end Examples;

    package Validation "Collection of validation models"
      extends Modelica.Icons.ExamplesPackage;

      model DecemberToJanuary
        "Validation model for a data reader that has data spanning only some hours in December to January"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          computeWetBulbTemperature=false,
          TDewPoiSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter,
          HInfHorSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter,
          HInfHor=100,
          calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.HorizontalRadiation,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/WeatherData/Validation/DecemberToJanuary.mos"))
          "Weather data reader with data file going from December to January"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

        annotation (experiment(
            StartTime=30992400,
            StopTime=31860000,
            Interval=3600,
            Tolerance=1e-006),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Validation/DecemberToJanuary.mos"
              "Simulate and plot"),
            Documentation(info="<html>
<p>
This is a validation case for a data file that has a few incomplete days in December and goes into
a few days into January. The data does not start and does not end at midnight.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 26, 2017, by Michael Wetter:<br/>
First implementation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">issue 842</a>.
</li>
</ul>
</html>"));

      end DecemberToJanuary;

      model OverAYear_usingOneYearData
        "Validation model for a simulation extending with two months over one year but using data for only one year"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          computeWetBulbTemperature=false,
          TDewPoiSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter,
          HInfHorSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter,
          HInfHor=100,
          calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.HorizontalRadiation,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos"))
          "Weather data reader with data file for one year, hourly data"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

        annotation (experiment(
            StopTime=36633600,
            Tolerance=1e-006),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Validation/OverAYear_usingOneYearData.mos"
              "Simulate and plot"),
            Documentation(info="<html>
<p>
This is a validation case for a simulation extending with two months over one year,
but using data for only one year.
</p>
<p>
The test script plots the dry bulb temperature for the days 0-10 and 365-375 for comparison.
</p>
</html>",       revisions="<html>
<ul>
<li>September 3, 2018 by Ana Constantin:<br/>
First implementation for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">issue 842</a>.
</li>
</ul>
</html>"));

      end OverAYear_usingOneYearData;

      model ReaderTMY3HDirNor
        "Test model for calculating the direct normal radiation"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDatInpCon(filNam=
              Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos"),
            HSou=ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor)
          "Weather data reader with radiation data obtained from the inputs' connectors"
          annotation (Placement(transformation(extent={{68,-10},{88,10}})));
      protected
        Modelica.Blocks.Sources.Sine HGloHor1(
          f=1/86400,
          startTime=25200,
          offset=0,
          amplitude=100) "Horizontal global radiation"
          annotation (Placement(transformation(extent={{-88,-30},{-68,-10}})));

        Modelica.Blocks.Sources.Sine HGloHor(
          f=1/86400,
          startTime=68428,
          offset=0,
          amplitude=100) "Horizontal global radiation"
          annotation (Placement(transformation(extent={{-88,10},{-68,30}})));
        Modelica.Blocks.Math.Add add
          annotation (Placement(transformation(extent={{-32,-10},{-12,10}})));
        Modelica.Blocks.Math.Gain gaiHDifHor(k=0.5)
          "Gain for diffuse solar radiation"
          annotation (Placement(transformation(extent={{0,10},{20,30}})));
      equation
        connect(HGloHor.y, add.u1) annotation (Line(points={{-67,20},{-52,20},{-52,6},
                {-34,6}}, color={0,0,127}));
        connect(HGloHor1.y, add.u2) annotation (Line(points={{-67,-20},{-50.5,-20},{-50.5,
                -6},{-34,-6}}, color={0,0,127}));
        connect(add.y, weaDatInpCon.HGloHor_in) annotation (Line(points={{-11,0},{28,0},
                {28,-13},{67,-13}}, color={0,0,127}));
        connect(add.y, gaiHDifHor.u) annotation (Line(points={{-11,0},{-6,0},{-6,0},{
                -6,20},{-2,20}},   color={0,0,127}));
        connect(gaiHDifHor.y, weaDatInpCon.HDifHor_in) annotation (Line(points={{21,20},
                {21,20},{50,20},{50,-7.6},{67,-7.6}},   color={0,0,127}));
        annotation (experiment(StopTime=86400, Tolerance=1e-06),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Validation/ReaderTMY3HDirNor.mos"
              "Simulate and plot"),
          Documentation(info="<html>
<p>
This model tests the calculation of the direct normal radiation.
The instance <code>weaDatInpCon</code> obtains the global horizontal and
the diffuse horizontal solar radiation from its inputs connectors.
</p>
</html>",
      revisions="<html>
<ul>
<li>
December 06, 2016, by Thierry S. Nouidui:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ReaderTMY3HDirNor;

      model ThreeYears_usingTwoYearData
        "Validation model for a simulation spanning three years but using only two years of data"
        extends Modelica.Icons.Example;
        ProsNet.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          computeWetBulbTemperature=false,
          TDewPoiSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter,
          HInfHorSou=ProsNet.BoundaryConditions.Types.DataSource.Parameter,
          HInfHor=100,
          calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.HorizontalRadiation,
          filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/WeatherData/Validation/TwoYears_DataOnceAMonth_TMY3.mos"))
          "Weather data reader with data for two years, only monthly values"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}})));

        annotation (experiment(
            StopTime=94608000,
            Tolerance=1e-006),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Validation/ThreeYears_usingTwoYearData.mos"
              "Simulate and plot"),
            Documentation(info="<html>
<p>
This is a validation case for a simulation extending over three years,
but using only two years of data with equidistant monthly values.
</p>
</html>",       revisions="<html>
<ul>
<li>September 3, 2018 by Ana Constantin:<br/>
First implementation for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">issue 842</a>.
</li>
</ul>
</html>"));

      end ThreeYears_usingTwoYearData;

      model ThreeYears_usingTwoYearDataNegativeStart
        "Validation model for a simulation spanning three years, starting at a negative time and using only two years of data"
        extends
          ProsNet.BoundaryConditions.WeatherData.Validation.ThreeYears_usingTwoYearData;

        annotation (experiment(
            StartTime=-47174400,
            StopTime=47433600,
            Tolerance=1e-006),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Validation/ThreeYears_usingTwoYearDataNegativeStart.mos"
              "Simulate and plot"),
            Documentation(info="<html>
<p>
This is a validation case for a simulation extending over six years
starting at a negative start date,
but using only two years of data with equidistant monthly values.
</p>
</html>",       revisions="<html>
<ul>
<li>March 5, 2019 by Michael Wetter:<br/>
First implementation for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">issue 842</a>.
</li>
</ul>
</html>"));

      end ThreeYears_usingTwoYearDataNegativeStart;

      model ThreeYears_usingTwoYearDataPositiveStart
        "Validation model for a simulation spanning three years, starting at a positive time and using only two years of data"
        extends
          ProsNet.BoundaryConditions.WeatherData.Validation.ThreeYears_usingTwoYearData;

        annotation (experiment(
            StartTime=15638400,
            StopTime=110246400,
            Tolerance=1e-006),
      __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/Validation/ThreeYears_usingTwoYearDataPositiveStart.mos"
              "Simulate and plot"),
            Documentation(info="<html>
<p>
This is a validation case for a simulation extending over six years
starting at a positive start date,
but using only two years of data with equidistant monthly values.
</p>
</html>",       revisions="<html>
<ul>
<li>March 5, 2019 by Michael Wetter:<br/>
First implementation for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">issue 842</a>.
</li>
</ul>
</html>"));

      end ThreeYears_usingTwoYearDataPositiveStart;
    annotation (Documentation(info="<html>
<p>
This package contains models for validation of weather data models.
</p>
</html>"));
    end Validation;

    package BaseClasses "Package with base classes for Buildings.BoundaryConditions.WeatherData"
      extends Modelica.Icons.BasesPackage;

      block CheckBlackBodySkyTemperature
        "Check the validity of the black-body sky temperature data"
        extends Modelica.Blocks.Icons.Block;

        parameter Modelica.Units.SI.Temperature TMin(displayUnit="degC") = 203.15
          "Minimum allowed temperature";
        parameter Modelica.Units.SI.Temperature TMax(displayUnit="degC") = 343.15
          "Maximum allowed temperature";

        Modelica.Blocks.Interfaces.RealInput TIn(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        TBlaSky = TIn;
        assert(noEvent(TIn > TMin and TIn < TMax),
          "In " + getInstanceName() + ": Weather data black-body sky temperature out of bounds.\n" + "   TIn = " +
           String(TIn));

        annotation (
          defaultComponentName="cheSkyBlaBodTem",
          Documentation(info="<html>
<p>
This component checks the value of the black-body sky temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> and removed output connector.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
January 5, 2015 by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature</a>.
This was implemented to get the corrected documentation string in the weather bus connector.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-20,-78},{20,-40}},
                lineColor={99,17,20},
                lineThickness=0.5,
                fillColor={99,17,20},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,40},{-12,40}}),
              Line(points={{-40,10},{-12,10}}),
              Line(points={{-40,-20},{-12,-20}}),
              Rectangle(
                extent={{-12,40},{12,-44}},
                lineColor={99,17,20},
                fillColor={99,17,20},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,40},{-12,60},{-10,66},{-6,68},{0,70},{6,68},{10,66},{12,
                    60},{12,40},{-12,40}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-12,40},{-12,-45}},
                thickness=0.5)}));
      end CheckBlackBodySkyTemperature;

      block CheckDewPointTemperature
        "Check the validity of the dew point temperature data"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput TIn(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Input Temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput TDewPoi(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        parameter Modelica.Units.SI.Temperature TMin(displayUnit="degC") = 203.15
          "Minimum allowed temperature";
        parameter Modelica.Units.SI.Temperature TMax(displayUnit="degC") = 343.15
          "Maximum allowed temperature";

      equation
        TDewPoi = TIn;
        assert(noEvent(TIn > TMin and TIn < TMax), "In " + getInstanceName() +
           ": Weather data dew point temperature out of bounds.\n" + "   TIn = " + String(
          TIn));
        annotation (
          defaultComponentName="cheTem",
          Documentation(info="<html>
<p>
This component checks the value of temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-22,-74},{18,-36}},
                lineColor={0,0,127},
                lineThickness=0.5,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Line(points={{-42,44},{-14,44}}),
              Line(points={{-42,14},{-14,14}}),
              Line(points={{-42,-16},{-14,-16}}),
              Rectangle(
                extent={{-14,44},{10,-40}},
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-14,44},{-14,64},{-12,70},{-8,72},{-2,74},{4,72},{8,70},{10,64},
                    {10,44},{-14,44}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-14,44},{-14,-41}},
                thickness=0.5)}));
      end CheckDewPointTemperature;

      block CheckDryBulbTemperature
        "Check the validity of the dry bulb temperature data"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput TIn(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Input Temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput TDryBul(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        parameter Modelica.Units.SI.Temperature TMin(displayUnit="degC") = 203.15
          "Minimum allowed temperature";
        parameter Modelica.Units.SI.Temperature TMax(displayUnit="degC") = 343.15
          "Maximum allowed temperature";

      equation
        TDryBul = TIn;
        assert(noEvent(TIn > TMin and TIn < TMax), "In " + getInstanceName() +
           ": Weather data dry bulb temperature out of bounds.\n" + "   TIn = " + String(
          TIn));
        annotation (
          defaultComponentName="cheTem",
          Documentation(info="<html>
<p>
This component checks the value of the dry bulb temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Ellipse(
                extent={{-18,-72},{22,-34}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-38,46},{-10,46}}),
              Line(points={{-38,16},{-10,16}}),
              Line(points={{-38,-14},{-10,-14}}),
              Rectangle(
                extent={{-10,46},{14,-38}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-10,46},{-10,66},{-8,72},{-4,74},{2,76},{8,74},{12,72},{14,66},
                    {14,46},{-10,46}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Line(
                points={{-10,46},{-10,-39}},
                thickness=0.5)}));
      end CheckDryBulbTemperature;

      block CheckPressure
        "Ensures that the interpolated pressure is between prescribed bounds"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput PIn(
          final quantity="Pressure",
          final unit="Pa") "Atmospheric pressure"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput pAtm(
          final quantity="Pressure",
          final unit="Pa") "Atmospheric pressure"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        constant Modelica.Units.SI.Pressure PMin=3100 "Minimum allowed pressure";
        constant Modelica.Units.SI.Pressure PMax=120000 "Maximum allowed pressure";
      equation
        pAtm = PIn;
        assert(noEvent(PIn > PMin and PIn < PMax), "In " + getInstanceName() +
          ": Weather data atmospheric pressure out of bounds.\n" + "   PIn = " + String(PIn));

        annotation (
          defaultComponentName="chePre",
          Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> and removed output connector.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1340\">#1340</a>.
</li>
<li>
January 31, 2020 by Filip Jorissen:<br/>
Improved error message.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-28,42},{26,-34}},
                textColor={0,0,255},
                textString="P")}));
      end CheckPressure;

      block ConvertTime
        "Converts the simulation time to calendar time in scale of 1 year (365 days), or a multiple of a year"
        extends PartialConvertTime;
        Modelica.Blocks.Interfaces.RealInput modTim(
          final quantity="Time",
          final unit="s") "Simulation time"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput calTim(
          final quantity="Time",
          final unit="s") "Calendar time"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
        constant Modelica.Units.SI.Time shiftSolarRad=1800
          "Number of seconds for the shift for solar radiation calculation";

      equation
        calTim = calTimAux;
        modTimAux = modTim;
        assert(canRepeatWeatherFile or noEvent((time - weaDatEndTim) < shiftSolarRad),
          "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    The simulation time "       + String(time) +
          " exceeds the end time " + String(weaDatEndTim) + " of the weather data file.",
          AssertionLevel.error);

        assert(canRepeatWeatherFile or noEvent(time >= weaDatStaTim),
          "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    The simulation time "       + String(time) +
          " is less than the start time " + String(weaDatStaTim) + " of the weather data file.",
          AssertionLevel.error);

        annotation (
          defaultComponentName="conTim",
          Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days),
or a multiple of it, if this is the length of the weather file.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
April 15, 2020, by Michael Wetter:<br/>
Added <code>noEvent</code> to assertion to remove zero crossing function in OPTIMICA.
</li>
<li>
January 29, 2020, by Filip Jorissen:<br/>
Revised end time assert and added assert that verifies whether the time is before the
start time of the weather file.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1281\">#1281</a>.
</li>
<li>
June 12, 2019, by Michael Wetter:<br/>
Reformulated model to avoid having to evaluate the weather file during compilation
(as it determined the structural parameter <code>lenWea</code>). The new formulation
allows inclusion of the weather file in JModelica-generated FMUs, and it works with
Dymola as well.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1147\">#1147</a>.
</li>
<li>
May 21, 2019, by Michael Wetter:<br/>
Corrected code to avoid wrong type conversion.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1142\">#1142</a>.
</li>
<li>
March 4, 2019, by Michael Wetter:<br/>
Refactored implementation to correctly account for negative start times.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
July 27, 2018, by Ana Constantin:<br/>
Added shift for multiple time spans.
</li>
<li>
September 27, 2011, by Wangda Zuo and Michael Wetter:<br/>
Modify it to convert negative value of time.
Use the when-then to allow dymola differentiating this model when
conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-98,6},{-74,-4}},
                textColor={0,0,127},
                textString="modTim"),
              Text(
                extent={{74,6},{98,-4}},
                textColor={0,0,127},
                textString="calTim"),
              Rectangle(
                extent={{-66,76},{60,58}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={120,120,120}),
              Rectangle(extent={{-66,58},{60,-62}}, lineColor={0,0,0}),
              Line(
                points={{-24,-62},{-24,58}}),
              Line(
                points={{18,-62},{18,58}}),
              Line(
                points={{60,28},{-66,28}}),
              Line(
                points={{60,-2},{-66,-2}}),
              Line(
                points={{60,-32},{-66,-32}})}));
      end ConvertTime;

      block EquationOfTime "Equation of time"
        extends PartialConvertTime;
        Modelica.Blocks.Interfaces.RealInput nDay(
          quantity="Time",
          unit="s")
          "Zero-based day number in seconds (January 1=0, January 2=86400)"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealOutput eqnTim(
          final quantity="Time",
          final unit="s",
          displayUnit="min") "Equation of time"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
        Real Bt "Intermediate variable";
      equation
        modTimAux = nDay;
        Bt = Modelica.Constants.pi*((calTimAux + 86400)/86400 - 81)/182
          "Our unit is s instead of day in (A.4.2b)";
        eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
          Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
        annotation (
          defaultComponentName="eqnTim",
          Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civil time.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-58,38},{38,-24}},
                textColor={0,0,255},
                textString="t"),
              Text(
                extent={{-6,4},{52,-24}},
                textColor={0,0,255},
                textString="equ")}));
      end EquationOfTime;

      block LimiterCeilingHeight "Block that limits the relative humidity"
        extends PartialLimiterMin;

        Modelica.Blocks.Interfaces.RealOutput ceiHei(
          final unit="m") = max(0, u) "Cloud cover ceiling height"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      annotation (
      defaultComponentName="limMin",
      Documentation(info="<html>
<p>
Block that limits the cloud cover ceiling height to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterCeilingHeight;

      block LimiterHorizontalInfraredIrradiation
        "Block that limits the horizontal infrared irradiation"
        extends PartialLimiterMin;

        Modelica.Blocks.Interfaces.RealOutput HHorIR(
          final unit="W/m2") = max(0, u) "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (
      defaultComponentName="limMin",
      Documentation(info="<html>
<p>
Block that limits the horizontal infrared irradiation to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterHorizontalInfraredIrradiation;

      block LimiterOpaqueSkyCover "Block that limits the opaque sky cover"
        extends PartialLimiter;

        Modelica.Blocks.Interfaces.RealOutput nOpa(
          final unit="1") "Opaque sky cover"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        nOpa = min(uMax, max(uMin, u));

        annotation (
      defaultComponentName="lim",
      Documentation(info="<html>
<p>
Block that limits the opaque sky cover.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterOpaqueSkyCover;

      block LimiterRelativeHumidity "Block that limits the relative humidity"
        extends PartialLimiter;

        Modelica.Blocks.Interfaces.RealOutput relHum(
          final unit="1") "Relative humidity"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        relHum = min(uMax, max(uMin, u));

        annotation (
      defaultComponentName="lim",
      Documentation(info="<html>
<p>
Block that limits the relative humidity.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterRelativeHumidity;

      block LimiterTotalSkyCover "Block that limits the total sky cover"
        extends PartialLimiter;

        Modelica.Blocks.Interfaces.RealOutput nTot(
          final unit="1") "Total sky cover"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        nTot = min(uMax, max(uMin, u));

        annotation (
      defaultComponentName="lim",
      Documentation(info="<html>
<p>
Block that limits the total sky cover.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterTotalSkyCover;

      block LimiterWindDirection "Block that limits the wind direction"
        extends PartialLimiter(
          final uMax=2*Modelica.Constants.pi);

        Modelica.Blocks.Interfaces.RealOutput winDir(
          final unit="rad") "Wind direction"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        winDir = min(uMax, max(uMin, u));

        annotation (
      defaultComponentName="lim",
      Documentation(info="<html>
<p>
Block that limits the wind direction.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterWindDirection;

      block LimiterWindSpeed "Block that limits the wind speed"
        extends PartialLimiterMin;

        Modelica.Blocks.Interfaces.RealOutput winSpe(
          final unit="m/s") = max(0, u) "Wind speed"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (
      defaultComponentName="limMin",
      Documentation(info="<html>
<p>
Block that limits the wind speed to be positive.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LimiterWindSpeed;

      block LocalCivilTime "Converts the clock time to local civil time."
        extends PartialConvertTime;
        Modelica.Blocks.Interfaces.RealInput cloTim(
          final quantity="Time",
          final unit="s") "Clock time"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        parameter Modelica.Units.SI.Time timZon(displayUnit="h") "Time zone";
        parameter Modelica.Units.SI.Angle lon(displayUnit="deg") "Longitude";
        Modelica.Blocks.Interfaces.RealOutput locTim(
          final quantity="Time",
          final unit="s") "Local civil time"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
        final parameter Modelica.Units.SI.Time diff=-timZon + lon*43200/Modelica.Constants.pi
          "Difference between local and clock time";
      equation
        modTimAux = cloTim;
        locTim = calTimAux + diff;

        annotation (
          defaultComponentName="locTim",
          Documentation(info="<html>
<p>
This component converts the clock time to local civil time.
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative;
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):
</p>
<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi
</pre>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Updated to use partial class for conversion from simulation time to calendar time.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
<li>
November 14, 2015, by Michael Wetter:<br/>
Introduced <code>diff</code>.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-98,6},{-60,-6}},
                textColor={0,0,127},
                textString="cloTim"), Text(
                extent={{74,6},{98,-4}},
                textColor={0,0,127},
                textString="calTim")}));
      end LocalCivilTime;

      partial block PartialConvertTime
        "Converts the simulation time to calendar time in scale of 1 year (365 days), or a multiple of a year"
        extends Modelica.Blocks.Icons.Block;
        parameter Modelica.Units.SI.Time weaDatStaTim(displayUnit="d") = 0
          "Start time of weather data";
        parameter Modelica.Units.SI.Time weaDatEndTim(displayUnit="d") = 31536000
          "End time of weather data";
        Modelica.Units.SI.Time modTimAux "Model time";
        Modelica.Units.SI.Time calTimAux "Calendar time";

      protected
        parameter Modelica.Units.SI.Time lenWea=weaDatEndTim - weaDatStaTim
          "Length of weather data";

        parameter Boolean canRepeatWeatherFile = abs(mod(lenWea, 365*24*3600)) < 1E-2
          "=true, if the weather file can be repeated, since it has the length of a year or a multiple of it";

        discrete Modelica.Units.SI.Time tNext(start=0, fixed=true)
          "Start time of next period";

      equation
        when {initial(), canRepeatWeatherFile and modTimAux > pre(tNext)} then
          // simulation time stamp went over the end time of the weather file
          //(last time stamp of the weather file + average increment)
          tNext = if canRepeatWeatherFile then integer(modTimAux/lenWea)*lenWea + lenWea else time;
        end when;
        calTimAux = if canRepeatWeatherFile then modTimAux - tNext + lenWea else modTimAux;

        annotation (
          defaultComponentName="conTim",
          Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days),
or a multiple of it, if this is the length of the weather file.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2023, by Ettore Zanetti:<br/>
Added partial class for conversion from simulation time to calendar time, to be
used by solar models that require calendar time for calculations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1716\">IBPSA #1716</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}})));
      end PartialConvertTime;

      partial block PartialLimiter
        "Partial block to limit a signal"
        extends Modelica.Blocks.Icons.Block;

        constant Real uMin = 0 "Minimum value";
        constant Real uMax = 1 "Maximum value";

        Modelica.Blocks.Interfaces.RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));

      annotation (
      defaultComponentName="lim",
      Documentation(info="<html>
<p>
Block that computes <i>y_internal=min(uMax, max(uMin, u))</i>,
where <code>y_internal</code> is a protected connector.
</p>
<p>
This block is used because interpolation of weather data can lead to
a slight overshoot of values. This block is extended by other blocks
that then provide the output connector.
Extending this block is needed for the output connector to have the correct
comment string in the weather data bus, because the weather
data bus displays the comment string of the output signal
that is connected to the weather data bus.
Without this construct, the weather data bus would simply show
\"Connector of Real output signal\".
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"), Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{0,-90},{0,68}}, color={192,192,192}),
          Polygon(
            points={{0,90},{-8,68},{8,68},{0,90}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,-8},{68,8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
          Text(
            extent={{-150,-150},{150,-110}},
                textString="%uMin <= u <= %uMax",
                textColor={0,0,0})}),
          Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}})));
      end PartialLimiter;

      partial block PartialLimiterMin
        "Partial block to limit a signal"
        extends Modelica.Blocks.Icons.Block;

        Modelica.Blocks.Interfaces.RealInput u "Connector of Real input signal"
        annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));

      annotation (
      defaultComponentName="limMin",
      Documentation(info="<html>
<p>
Partial block that is used to limit a signal by a minimum value.
</p>
<p>
This block is used because interpolation of weather data can lead to slightly
negative values. This block is extended by other blocks
that then provide the output connector.
Extending this block is needed for the output connector to have the correct
comment string in the weather data bus, because the weather
data bus displays the comment string of the output signal
that is connected to the weather data bus.
Without this construct, the weather data bus would simply show
\"Connector of Real output signal\".
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(
            graphics={
              Text(
                extent={{-100,30},{98,-16}},
                textColor={0,0,0},
                textString="0 <= u")}));
      end PartialLimiterMin;

      block SolarTime "Solar time"
        extends Modelica.Blocks.Icons.Block;
        Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
          "Local time" annotation (Placement(transformation(extent={{-140,-74},{-100,
                  -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
        Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
          "Equation of time" annotation (Placement(transformation(extent={{-140,40},{
                  -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealOutput solTim(
          final quantity="Time",
          final unit="s",
          displayUnit="s") "Solar time"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        solTim = locTim + equTim "Our unit is s in stead of h in (A.4.3)";

        annotation (
          defaultComponentName="solTim",
          Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
<p>
<b>Note:</b> To avoid events, this block does not convert solar time to a scale of 24 hours.
</p>
</html>",       revisions="<html>
<ul>
<li>
Feb. 16, 2012, by Michael Wetter:<br/>
Removed section that limits solar time to
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                textColor={0,0,255}),
              Text(
                extent={{-54,38},{42,-24}},
                textColor={0,0,255},
                textString="t"),
              Text(
                extent={{-4,4},{52,-24}},
                textColor={0,0,255},
                textString="sol"),
              Text(
                extent={{-94,66},{-42,50}},
                textColor={0,0,127},
                textString="equTim"),
              Text(
                extent={{-96,-44},{-44,-60}},
                textColor={0,0,127},
                textString="locTim")}));
      end SolarTime;

      block SourceSelector
        "Block that selects as its output either a parameter value or its input"
        extends Modelica.Blocks.Interfaces.SO;
        parameter ProsNet.BoundaryConditions.Types.DataSource datSou
          "Data source" annotation (Evaluate=true);
        parameter Real p "Parameter value";
        Modelica.Blocks.Interfaces.RealInput uFil
          if datSou == ProsNet.BoundaryConditions.Types.DataSource.File
          "Input signal from file reader"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}}),
              iconTransformation(extent={{-120,-90},{-100,-70}})));
        Modelica.Blocks.Interfaces.RealInput uCon
          if datSou == ProsNet.BoundaryConditions.Types.DataSource.Input
          "Input signal from input connector"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}}),
              iconTransformation(extent={{-120,70},{-100,90}})));
      equation
        if datSou == ProsNet.BoundaryConditions.Types.DataSource.Parameter then
          y = p;
        end if;
        connect(uCon, y);
        connect(uFil, y);
        annotation (
        defaultComponentName="souSel",
      Documentation(info="<html>
<p>
Block that produces at its output the input value <code>uCon</code>, <code>uFil</code>
or the parameter value <code>p</code> depending on the parameter value
<code>datSou</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={
            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Line(points={{12,0},{100,0}},
                color={0,0,127}),
              Line(points={{-100,-80},{-40,-80},{-40,-80}},
                color={0,0,127}),
              Line(points={{-100,80},{-38,80}},
                color={0,0,127}),
              Line(points={{-38,80},{6,2}},
                color={0,0,127},
                visible=datSou == Buildings.BoundaryConditions.Types.DataSource.File,
                thickness=1),
              Line(points={{-40,-80},{8,0}},
                color={0,0,127},
                visible=datSou == Buildings.BoundaryConditions.Types.DataSource.Input,
                thickness=1),
              Ellipse(lineColor={0,0,255},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{2,-8},{18,8}})}));
      end SourceSelector;

      block SourceSelectorRadiation
        "Block that selects the solar radiation source and outputs the solar radiation quantities"
        extends Modelica.Blocks.Icons.Block;
        parameter ProsNet.BoundaryConditions.Types.RadiationDataSource datSou
          "Data source" annotation (Evaluate=true);

        Modelica.Blocks.Interfaces.RealInput HDirNorFil(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.File
          "Direct normal solar irradiation from weather data file" annotation (Placement(transformation(extent={{-140,
                  -10},{-100,30}}), iconTransformation(extent={{-120,10},{-100,30}})));

        Modelica.Blocks.Interfaces.RealInput HDirNorIn(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor
           or datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor
          "Direct normal solar irradiation from input connector" annotation (Placement(transformation(extent={{-140,
                  -40},{-100,0}}),  iconTransformation(extent={{-120,-30},{-100,-10}})));

        Modelica.Blocks.Interfaces.RealInput HDifHorFil(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.File
          "Diffuse horizontal solar irradiation from weather data file" annotation (Placement(transformation(
                extent={{-140,60},{-100,100}}), iconTransformation(extent={{-120,80},{
                  -100,100}})));

        Modelica.Blocks.Interfaces.RealInput HDifHorIn(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor
           or datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor
          "Diffuse horizontal solar irradiation from input connector" annotation (Placement(transformation(
                extent={{-140,30},{-100,70}}),  iconTransformation(extent={{-120,50},{
                  -100,70}})));

        Modelica.Blocks.Interfaces.RealInput HGloHorFil(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.File
          "Global horizontal solar irradiation from weather data file" annotation (Placement(transformation(extent={{-140,
                  -70},{-100,-30}}),        iconTransformation(extent={{-120,-70},{-100,
                  -50}})));

        Modelica.Blocks.Interfaces.RealInput HGloHorIn(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor
           or datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor
          "Global horizontal solar irradiation from input connector" annotation (Placement(transformation(extent={{-140,
                  -98},{-100,-58}}),        iconTransformation(extent={{-120,-100},{-100,
                  -80}})));

        Modelica.Blocks.Interfaces.RealInput zen(
          final quantity="Angle",
          final unit="rad")
          "Zenith angle"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={0,-120}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-60,-110})));

        Modelica.Blocks.Interfaces.RealOutput HDirNor(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2")
          "Direct normal solar irradiation" annotation (Placement(
              transformation(extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},
                  {120,10}})));
        Modelica.Blocks.Interfaces.RealOutput HDifHor(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2")
          "Diffuse horizontal solar irradiation" annotation (Placement(
              transformation(extent={{100,60},{120,80}}),  iconTransformation(extent={{100,68},
                  {120,88}})));
        Modelica.Blocks.Interfaces.RealOutput HGloHor(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2")
          "Global horizontal solar irradiation" annotation (Placement(
              transformation(extent={{100,-80},{120,-60}}),iconTransformation(extent={{100,-90},
                  {120,-70}})));

      protected
        constant Real epsCos = 1e-6 "Small value to avoid division by 0";
        constant Modelica.Units.SI.HeatFlux solCon=1367.7 "Solar constant";

        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDirNor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";

      equation
        // Conditional connect statements
        connect(HGloHor_in_internal, HGloHorFil);
        connect(HDifHor_in_internal, HDifHorFil);
        connect(HDirNor_in_internal, HDirNorFil);
        connect(HGloHor_in_internal, HGloHorIn);
        connect(HDifHor_in_internal, HDifHorIn);
        connect(HDirNor_in_internal, HDirNorIn);

        //---------------------------------------------------------------------------
        // Select global horizontal radiation connector
        if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
          HGloHor = max(0, HDirNor_in_internal*cos(zen)+HDifHor_in_internal)
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
          HGloHor_in_internal = 0;
        else
          HGloHor = max(0, HGloHor_in_internal)
            "Get HGloHor using weather data file or input connector of weather data reader";
        end if;

        //---------------------------------------------------------------------------
        // Select diffuse horizontal radiation connector
        if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
          HDifHor = max(0, HGloHor_in_internal - HDirNor_in_internal*cos(zen))
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
          HDifHor_in_internal = 0;
        else
          HDifHor = max(0, HDifHor_in_internal)
            "Get HDifHor using weather data file or input connector of weather data reader";
        end if;

        //---------------------------------------------------------------------------
        // Select direct normal radiation connector
        if datSou == ProsNet.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor then
            HDirNor = max(0, min(
              solCon,
              (HGloHor_in_internal -HDifHor_in_internal)*
                Buildings.Utilities.Math.Functions.spliceFunction(
                  x=cos(zen),
                  pos=Buildings.Utilities.Math.Functions.inverseXRegularized(cos(zen), epsCos),
                  neg=0,
                  deltax=epsCos)))
            "Calculate the HDirNor using HGloHor and HDifHor according to (A.4.14) and (A.4.15)";
          HDirNor_in_internal = 0;
        else
          HDirNor = max(0, HDirNor_in_internal)
            "Get HDirNor using weather data file or input connector of weather data reader";
        end if;

        annotation (
        defaultComponentName="souSel",
      Documentation(info="<html>
<p>
Block that outputs the direct normal, diffuse horizontal and diffuse global
solar irradiation.
This block computes these output quantities based on conditionally provided
input signals.
</p>
<p>
The computations are based on Wetter (2004).
</p>
<h4>References</h4>
<ul>
<li>
Michael Wetter.<br/>
<a href=\"http://simulationresearch.lbl.gov/wetter/download/mwdiss.pdf\">
Simulation-based Building Energy Optimization</a>.<br/>
Dissertation. University of California at Berkeley. 2004.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
April 14, 2020, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(graphics={
            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Line(points={{12,0},{100,0}},
                color={0,0,127}),
              Line(points={{40,-80},{100,-80},{100,-80}},
                color={0,0,127}),
              Line(points={{40,80},{100,78}},
                color={0,0,127}),
              Line(points={{6,0},{40,-82},{40,-80}},
                color={0,0,127}),
              Line(points={{40,80},{6,0},{6,0}},
                color={0,0,127}),
              Ellipse(lineColor={0,0,255},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{-2,-8},{14,8}})}));
      end SourceSelectorRadiation;

      pure function getAbsolutePath "Gets the absolute path of a URI"
        extends Modelica.Icons.Function;
        input String uri "A URI";
        output String path "The absolute path of the file pointed to by the URI";
      algorithm
        path := Modelica.Utilities.Files.loadResource(uri);
        annotation (Documentation(info="<html>
<p>
The function returns the absolute path of a
uniform resource identifier (URI) or local file name.
If the file is not found, then this function
terminates with an <code>assert</code>.
</p>
<p>
This function has been introduced to allow users
to specify the name of weather data files with a path
that is relative to the library path. This allows users
to change the current working directory while still
being able to read the files.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Removed assertion if file does not exist. This has been removed because it
makes the function impure, and then the test
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.Examples.GetAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.Examples.GetAbsolutePath</a>
fails.
</li>
<li>
July 07, 2016, by Thierry S. Nouidui:<br/>
Removed the use of <code>Modelica.Utilities.Files.fullPathName</code>
which is implicitly done in <code>Modelica.Utilities.Files.loadResource</code>. <br/>
Removed the addition of <code>file://</code> to file names which do not start
with <code>file://</code>, or <code>modelica://</code>.
This is not required when using <code>Modelica.Utilities.Files.loadResource</code>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Replaced <code>ModelicaServices.ExternalReferences.loadResource</code> with
<code>Modelica.Utilities.Files.loadResource</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved algorithm that determines the absolute path of the file.
Now the function works from any directory as long as the <code>Buildings</code> library
is on the <code>MODELICAPATH</code>.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getAbsolutePath;

      impure function getAltitudeLocationTMY3 "Gets the altitude from TMY3 file"
        extends Modelica.Icons.Function;
       input String filNam "Name of weather data file"
       annotation (Dialog(
              loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
        output Modelica.Units.SI.Length alt "Altitude of TMY3 location";
      protected
       Integer nexInd "Next index, used for error handling";
       String element "String representation of the returned element";
      algorithm
        element :=
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLastHeaderElementTMY3(
                filNam=filNam,
                start="#LOCATION",
                name="Altitude");
         (nexInd, alt) :=Modelica.Utilities.Strings.Advanced.scanReal(
          string=element,
          startIndex=1,
          unsigned=false);

        annotation (Documentation(info="<html>
This function returns the altitude of the TMY3 weather data file.
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getAltitudeLocationTMY3;

      impure function getHeaderElementTMY3
        "Gets an element from the header of a TMY3 weather data file"
        extends Modelica.Icons.Function;
       input String filNam "Name of weather data file"
       annotation (Dialog(
              loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
       input String start "Start of the string that contains the elements";
       input String name "Name of data element, used in error reporting";
       input Integer position(min=1)
          "Position of the element on the line that contains 'start'";
       output String element
          "Element at position 'pos' of the line that starts with 'start'";
      protected
       String lin "Line that is used in parser";
       Integer iLin "Line number";
       Integer index =  0 "Index of string #LOCATION";
       Integer staInd "Start index used when parsing a real number";
       Integer nexInd "Next index used when parsing a real number";
       Boolean found "Flag, true if #LOCATION has been found";
       Boolean EOF "Flag, true if EOF has been reached";
       String fouDel "Found delimiter";
      algorithm
        // Get line that starts with 'start'
        iLin :=0;
        EOF :=false;
        while (not EOF) and (index == 0) loop
          iLin:=iLin + 1;
          (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
            lineNumber=iLin);
          index :=Modelica.Utilities.Strings.find(
            string=lin,
            searchString=start,
            startIndex=1,
            caseSensitive=false);
        end while;
        assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                            + "\n   Check for correct weather file syntax.");
        // Loop over the tokens until the position is reached
        nexInd :=1;
        for i in 1:position-1 loop
        nexInd :=Modelica.Utilities.Strings.find(
            string=lin,
            searchString = ",",
            startIndex=nexInd+1);
         assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
               + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
              lin + "'.");
        end for;
        staInd := nexInd;
        // Find the next delimiter
        nexInd :=Modelica.Utilities.Strings.find(
            string=lin,
            searchString = ",",
            startIndex=nexInd+1);
        assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
               + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
               lin + "'.");
        // Get the element
        element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
        annotation (Inline=false,
        Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getHeaderElementTMY3;

      impure function getLastHeaderElementTMY3
        "Gets last element from the header of a TMY3 weather data file"
        extends Modelica.Icons.Function;
       input String filNam "Name of weather data file"
       annotation (Dialog(
              loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
       input String start "Start of the string that contains the elements";
       input String name "Name of data element, used in error reporting";
       output String element
          "Element at position 'pos' of the line that starts with 'start'";
      protected
       String lin "Line that is used in parser";
       Integer iLin "Line number";
       Integer index =  0 "Index of string #LOCATION";
       Integer staInd "Start index used when parsing a real number";
       Integer lasInd "Next index used when parsing a real number";
       Boolean EOF "Flag, true if EOF has been reached";
      algorithm
        // Get line that starts with 'start'
        iLin :=0;
        EOF :=false;
        while (not EOF) and (index == 0) loop
          iLin:=iLin + 1;
          (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
            lineNumber=iLin);
          index :=Modelica.Utilities.Strings.find(
            string=lin,
            searchString=start,
            startIndex=1,
            caseSensitive=false);
        end while;
        assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                            + "\n   Check for correct weather file syntax.");
          // gest first and last index of the last string header element
          staInd := Modelica.Utilities.Strings.findLast(
              string=lin,
              searchString = ",",
              startIndex=0);
          lasInd := integer(Modelica.Utilities.Strings.length(lin));
        // Get the element
        element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=lasInd);
        annotation (Inline=false,
        Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getLastHeaderElementTMY3;

      impure function getLatitudeTMY3 "Gets the latitude from a TMY3 weather data file"
        extends Modelica.Icons.Function;
       input String filNam "Name of weather data file"
       annotation (Dialog(
              loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
        output Modelica.Units.SI.Angle lat "Latitude from the weather file";
      protected
       Integer nexInd "Next index, used for error handling";
       String element "String representation of the returned element";
      algorithm
        element :=
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
                filNam=filNam,
                start="#LOCATION",
                name="latitude",
                position=7);
         (nexInd, lat) :=Modelica.Utilities.Strings.Advanced.scanReal(
          string=element,
          startIndex=1,
          unsigned=false);
         assert(nexInd > 1, "Error when converting the latitude '" +
                            element + "' from a String to a Real.");
         // Convert from degree to rad
         lat :=lat*Modelica.Constants.pi/180;
         // Check if latitude is valid
         assert(abs(lat) <= Modelica.Constants.pi+Modelica.Constants.eps,
             "Wrong value for latitude. Received lat = " +
             String(lat) + " (= " + String(lat*180/Modelica.Constants.pi) + " degrees).");

        annotation (Documentation(info="<html>
This function returns the latitude of the TMY3 weather data file.
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getLatitudeTMY3;

      impure function getLongitudeTMY3 "Gets the longitude from a TMY3 weather data file"
        extends Modelica.Icons.Function;
       input String filNam "Name of weather data file"
       annotation (Dialog(
              loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
        output Modelica.Units.SI.Angle lon "Longitude from the weather file";
      protected
       Integer nexInd "Next index, used for error handling";
       String element "String representation of the returned element";
      algorithm
        element :=
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
                filNam=filNam,
                start="#LOCATION",
                name="longitude",
                position=8);
         (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
          string=element,
          startIndex=1,
          unsigned=false);
         assert(nexInd > 1, "Error when converting the longitude '" +
                            element + "' from a String to a Real.");
         // Convert from degree to rad
         lon :=lon*Modelica.Constants.pi/180;
         // Check if longitude is valid
         assert(abs(lon) < 2*Modelica.Constants.pi,
             "Wrong value for longitude. Received lon = " +
             String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");

        annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getLongitudeTMY3;

      impure function getTimeSpanTMY3
          "Get the time span of the weather data from the file"
        extends Modelica.Icons.Function;

        input String filNam "Name of weather data file";
        input String tabNam "Name of table on weather file";
        output Modelica.Units.SI.Time[2] timeSpan
          "Start time, end time of weather data";

      external "C" getTimeSpan(filNam, tabNam, timeSpan)
        annotation (
        Include="#include <getTimeSpan.c>",
        IncludeDirectory="modelica://Buildings/Resources/C-Sources");

        annotation (Documentation(info="<html>
<p>
This function returns the start time (first time stamp) and end time
(last time stamp plus average increment) of the TMY3 weather data file.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
April 16, 2019, by Jianjun Hu:<br/>
Reimplemented to use a C function, this is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1108\">#1108</a>.
</li>
<li>
November 15, 2017, by Ana Constantin:<br/>
First implementation, as part of solution to <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
</ul>
</html>"));
      end getTimeSpanTMY3;

      impure function getTimeZoneTMY3 "Gets the time zone from a TMY3 weather data file"
        extends Modelica.Icons.Function;
       input String filNam "Name of weather data file"
       annotation (Dialog(
              loadSelector(filter="Weather files (*.mos)", caption=
                  "Select weather file")));
        output Modelica.Units.SI.Time timZon "Time zone from the weather file";
      protected
       Integer nexInd "Next index, used for error handling";
       String element "String representation of the returned element";
      algorithm
        element :=
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
                filNam=filNam,
                start="#LOCATION",
                name="longitude",
                position=9);
         (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
          string=element,
          startIndex=1,
          unsigned=false);
         assert(nexInd > 1, "Error when converting the time zone '" +
                            element + "' from a String to a Real.");
         timZon :=timZon*3600;
         // Check if time zone is valid
         assert(abs(timZon) < 24*3600,
             "Wrong value for time zone. Received timZon = " +
             String(timZon) + " (= " + String(timZon/3600) + " hours).");

        annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",       revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>impure</code> declaration for MSL 4.0.0.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end getTimeZoneTMY3;

      package Examples "Collection of models that illustrate model use and test models"
      extends Modelica.Icons.ExamplesPackage;

        model CheckBlackBodySkyTemperature
          "Test model for CheckBlackBodySkyTemperature"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.CheckBlackBodySkyTemperature
            cheSkyBlaBodTem "Check for the black body sky temperature"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          Modelica.Blocks.Sources.Ramp TBlaBod(
            height=140-0.02,
            duration=1,
            offset=273.15 - 69.99) "Black body sky temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
        equation
          connect(TBlaBod.y, cheSkyBlaBodTem.TIn)
            annotation (Line(points={{-19,0},{18,0}}, color={0,0,127}));
          annotation (
        Documentation(info="<html>
<p>
This example tests the model that checks the black-body sky temperature.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/CheckBlackBodySkyTemperature.mos"
                "Simulate and plot"));
        end CheckBlackBodySkyTemperature;

        model CheckPressure "Test model for pressure check"
          extends Modelica.Icons.Example;

          ProsNet.BoundaryConditions.WeatherData.BaseClasses.CheckPressure chePre
            "Block that checks the pressure"
            annotation (Placement(transformation(extent={{20,0},{40,20}})));
          Buildings.Utilities.Time.ModelTime modTim
            "Block that outputs simulation time"
            annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
              weaDatStaTim=0, weaDatEndTim=31536000) "Block that converts time"
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
        protected
          Modelica.Blocks.Tables.CombiTable1Ds datRea(
            tableOnFile=true,
            tableName="tab1",
            fileName=Modelica.Utilities.Files.loadResource(
               Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")),
            columns=2:30,
            smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative)
            "Data reader"
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));
        equation
          connect(datRea.y[4], chePre.PIn) annotation (Line(
              points={{1,10},{10,10},{10,10},{18,10}},
              color={0,0,127}));
          connect(modTim.y, conTim.modTim) annotation (Line(
              points={{-79,10},{-62,10}},
              color={0,0,127}));
          connect(conTim.calTim, datRea.u) annotation (Line(
              points={{-39,10},{-22,10}},
              color={0,0,127}));
          annotation (
        Documentation(info="<html>
<p>
This example tests the model that asserts that the pressure is within acceptable bounds.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Replaced <code>ModelicaServices.ExternalReferences.loadResource</code> with
<code>Modelica.Utilities.Files.loadResource</code>.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=0, StopTime=8640000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/CheckPressure.mos"
                "Simulate and plot"));
        end CheckPressure;

        model CheckTemperature "Test model for CheckTemperature"
          extends Modelica.Icons.Example;
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.CheckDryBulbTemperature
            cheTemDryBul "Check dry bulb temperature "
            annotation (Placement(transformation(extent={{60,20},{80,40}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.CheckDewPointTemperature
            cheTemDewPoi "Check dew point temperature"
            annotation (Placement(transformation(extent={{60,-20},{80,0}})));
          Buildings.Utilities.Time.ModelTime modTim
            "Block that outputs the model time"
            annotation (Placement(transformation(extent={{-90,0},{-70,20}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
              weaDatStaTim=0, weaDatEndTim=31536000) "Block that converts time"
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          Modelica.Blocks.Math.UnitConversions.From_degC from_degC
            "Block that converts temperature"
            annotation (Placement(transformation(extent={{20,20},{42,40}})));
          Modelica.Blocks.Math.UnitConversions.From_degC from_degC1
            "Block that converts temperature"
            annotation (Placement(transformation(extent={{20,-20},{42,0}})));
        protected
          Modelica.Blocks.Tables.CombiTable1Ds datRea(
            tableOnFile=true,
            tableName="tab1",
            fileName=Modelica.Utilities.Files.loadResource(
               Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")),
            columns=2:30,
            smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative)
            "Data reader"
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));
        equation
          connect(modTim.y, conTim.modTim) annotation (Line(
              points={{-69,10},{-62,10}},
              color={0,0,127}));
          connect(conTim.calTim, datRea.u) annotation (Line(
              points={{-39,10},{-22,10}},
              color={0,0,127}));
          connect(datRea.y[1], from_degC.u) annotation (Line(
              points={{1,10},{10,10},{10,30},{17.8,30}},
              color={0,0,127}));
          connect(from_degC.y, cheTemDryBul.TIn) annotation (Line(
              points={{43.1,30},{58,30}},
              color={0,0,127}));
          connect(datRea.y[2], from_degC1.u) annotation (Line(
              points={{1,10},{10,10},{10,-10},{17.8,-10}},
              color={0,0,127}));
          connect(from_degC1.y, cheTemDewPoi.TIn) annotation (Line(
              points={{43.1,-10},{58,-10}},
              color={0,0,127}));
          annotation (
        Documentation(info="<html>
<p>
This example tests the model that checks the temperature.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Replaced <code>ModelicaServices.ExternalReferences.loadResource</code> with
<code>Modelica.Utilities.Files.loadResource</code>.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=0, StopTime=8640000),
        __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/CheckTemperature.mos"
                "Simulate and plot"));
        end CheckTemperature;

        model ConvertTime "Test model for converting time"
          extends Modelica.Icons.Example;
          Buildings.Utilities.Time.ModelTime modTim
            "Block that outputs simulation time"
            annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
              weaDatStaTim=0, weaDatEndTim=31536000) "Block that converts time"
            annotation (Placement(transformation(extent={{0,0},{20,20}})));
        equation
          connect(modTim.y, conTim.modTim) annotation (Line(
              points={{-19,10},{-2,10}},
              color={0,0,127}));
          annotation (
          Documentation(info="<html>
<p>
This example tests the model that converts time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=77760000),
        __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/ConvertTime.mos"
                "Simulate and plot"));
        end ConvertTime;

        model ConvertTimeNegativeStart
          "Validation of time conversion for negative start time"
          extends
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.Examples.ConvertTime;
          annotation (
          Documentation(info="<html>
<p>
This example tests the model that converts time for negative start time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 4, 2019, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=-31536000, StopTime=31536000),
        __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/ConvertTimeNegativeStart.mos"
                "Simulate and plot"));
        end ConvertTimeNegativeStart;

        model ConvertTimePositiveStart
          "Validation of time conversion for positive start time"
          extends
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.Examples.ConvertTime;
          annotation (
          Documentation(info="<html>
<p>
This example tests the model that converts time for positive start time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 4, 2019, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=47174400, StopTime=126144000),
        __Dymola_Commands(file=
                  "modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/ConvertTimePositiveStart.mos"
                "Simulate and plot"));
        end ConvertTimePositiveStart;

        model EquationOfTime "Test model for equation of time"
          extends Modelica.Icons.Example;
          Buildings.Utilities.Time.ModelTime modTim
            "Block that outputs simulation time"
            annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.EquationOfTime eqnTim
            "Block that computes the equation of time"
            annotation (Placement(transformation(extent={{0,0},{20,20}})));
        equation
          connect(modTim.y, eqnTim.nDay) annotation (Line(
              points={{-19,10},{-2,10}},
              color={0,0,127}));
          annotation (
          Documentation(info="<html>
<p>
This example tests the model that computes the equation of time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StopTime=86400),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/EquationOfTime.mos"
                "Simulate and plot"));
        end EquationOfTime;

        model GetAbsolutePath "Test model to get the absolute path of a URI"
          extends Modelica.Icons.Example;
          parameter String f = Modelica.Utilities.Files.loadResource("modelica://Buildings/package.mo")
           "Name of a file that exists";
          parameter String fAbs=
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath(  uri=f)
            "Absolute path of f";
          final parameter Integer dummy = 1
            "Dummy variable, used to have a result as needed for the unit tests";
        initial algorithm
          Modelica.Utilities.Streams.print("Absolute path = " + fAbs);

          annotation (
        experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/GetAbsolutePath.mos"
                "Simulate and plot"),
            Documentation(info="<html>
<p>
This model tests the function that gets the absolute path of a URI.
</p>
</html>",         revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Added <code>loadResource</code> call.
</li>
<li>
November 18, 2016, by Michael Wetter:<br/>
Removed tests that assumed that the regression test is run
from the library root directory.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/596\">#596</a>.
</li>
<li>
October 9, 2013, by Michael Wetter:<br/>
Removed incorrect call to <code>Modelica.Utilities.Files.exist</code>.
</li>
<li>
May 9, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end GetAbsolutePath;

        model GetAltitudeTMY3 "Test model to get Altitude of TMY3"
          extends Modelica.Icons.Example;
          parameter String filNam = Modelica.Utilities.Files.loadResource(
          "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")
            "Name of weather data file";
          parameter Modelica.Units.SI.Length alt = ProsNet.BoundaryConditions.WeatherData.BaseClasses.getAltitudeLocationTMY3(
          filNam) "Altitude of TMY3 location";

          annotation (
            Documentation(info="<html>
<p>
This example tests getting the location altitude of a TMY3 weather data file.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 11, 2021, by Michael Wetter:<br/>
Changed <code>alt</code> from variable to parameter as it is evaluated using an impure function call.
</li>
<li>
September 16, 2021, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/GetAltitudeTMY3.mos"
                "Simulate and plot"));
        end GetAltitudeTMY3;

        model GetHeaderElement "Test model to get header element"
          extends Modelica.Icons.Example;
          parameter Modelica.Units.SI.Angle longitude(fixed=false, displayUnit="deg")
            "Longitude";
          parameter Modelica.Units.SI.Angle latitude(fixed=false, displayUnit="deg")
            "Latitude";
          parameter Modelica.Units.SI.Time timeZone(fixed=false, displayUnit="h")
            "Time zone";

          parameter String filNam = Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")
            "Name of weather data file";

          final parameter String absFilNam = ProsNet.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath(  filNam)
            "Absolute path of the file";
        initial equation
          longitude =
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
             filNam=absFilNam);
          latitude =
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(
            filNam=absFilNam);
          timeZone =
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(
            filNam=absFilNam);
          assert(abs(longitude*180/Modelica.Constants.pi+87.92) < 1,
              "Error when parsing longitude, longitude = " + String(longitude));
          assert(abs(latitude*180/Modelica.Constants.pi-41.98) < 1,
              "Error when parsing latitude, latitude = " + String(latitude));
          assert(abs(timeZone+6*3600) < 1, "Error when parsing time zone, timeZone = "
            + String(timeZone));

          annotation (
            Documentation(info="<html>
<p>
This example tests getting the header of the TMY3 weather data file.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Added call to
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
as this call has been removed from the function
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3\">
Buildings.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/GetHeaderElement.mos"
                "Simulate and plot"));
        end GetHeaderElement;

        model GetTimeSpanTMY3 "Test model to get the time span of a weather file"
          extends Modelica.Icons.Example;

          parameter String filNam = Modelica.Utilities.Files.loadResource(
          "modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")
            "Name of weather data file";
          parameter String tabNam = "tab1" "Name of table on weather file";

          parameter Modelica.Units.SI.Time[2] timeSpan(each fixed=false)
            "Start time, end time of weather data";

        protected
          constant Modelica.Units.SI.Time endTim=365*24*3600.;
          constant Modelica.Units.SI.Time staTim=0.;

        initial equation
          timeSpan =
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(
            filNam, tabNam);

          assert(abs(timeSpan[2]-endTim) < 1E-5  and abs(timeSpan[1]-staTim) < 1E-5,
              "Error in weather file, start time " + String(timeSpan[1]) +
              " and end time " + String(timeSpan[2]) +
              ", but expected " + String(staTim) + " and " + String(endTim) + ".");

          annotation (
            Documentation(info="<html>
<p>
This example tests getting the time span of a TMY3 weather data file.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 16, 2019, by Michael Wetter:<br/>
Removed call to get the absolute path of the file, corrected the <code>.mos</code>
file name and updated the documentation
</li>
<li>
April 15, 2019, by Ana Constantin:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/GetTimeSpanTMY3.mos"
                "Simulate and plot"));
        end GetTimeSpanTMY3;

        model GetTimeSpanTMY3LongHeader
          "Test model to get the time span of a weather file with a long header line"
          extends Modelica.Icons.Example;

          parameter String filNam=Modelica.Utilities.Files.loadResource(
          "modelica://Buildings/Resources/Data/BoundaryConditions/WeatherData/BaseClasses/Examples/weatherWithLongHeader.mos")
           "Name of weather data file";

          final parameter Modelica.Units.SI.Time[2] timeSpan=
              ProsNet.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(  filNam,
              "tab1") "Start time, end time of weather data";

        initial equation
          assert(abs(timeSpan[2]-14400) < 0.1, "Error in getting time span.");
          annotation (
            Documentation(info="<html>
<p>
This example tests getting the time span of a TMY3 weather data file with a long line in the
header of the weather file.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 27, 2021, by Michael Wetter:<br/>
First implementation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1432\">#1432</a>.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/GetTimeSpanTMY3LongHeader.mos"
                "Simulate and plot"));
        end GetTimeSpanTMY3LongHeader;

        model GetTimeSpanTMY3_NonzeroStart
          "Test model to get time span of a weather file, start time is non zero"
          extends Modelica.Icons.Example;
          extends
            ProsNet.BoundaryConditions.WeatherData.BaseClasses.Examples.GetTimeSpanTMY3(
            filNam=Modelica.Utilities.Files.loadResource(
                "modelica://Buildings/Resources/Data/BoundaryConditions/WeatherData/Validation/DecemberToJanuary.mos"),
            staTim=30992400,
            endTim=31863600);

          annotation (
            Documentation(info="<html>
<p>
This example tests getting time span of a TMY3 weather data file that
starts at a non-zero time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 17, 2019, by Jianjun Hu:<br/>
First implementation.
</li>
</ul>
</html>"),
        experiment(Tolerance=1e-6, StopTime=1.0),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/GetTimeSpanTMY3_NonzeroStart.mos"
                "Simulate and plot"));
        end GetTimeSpanTMY3_NonzeroStart;

        model LimitMin "Test model for ceiling height check"
          extends Modelica.Icons.Example;
          Buildings.Utilities.Time.ModelTime modTim
            annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.LimiterCeilingHeight
            limCeiHei "Block that constrains the ceiling height"
            annotation (Placement(transformation(extent={{40,-20},{60,0}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
              weaDatStaTim=0, weaDatEndTim=31536000) "Block that converts time"
            annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
        protected
          Modelica.Blocks.Tables.CombiTable1Ds datRea(
            tableOnFile=true,
            tableName="tab1",
            fileName=Modelica.Utilities.Files.loadResource(
               Modelica.Utilities.Files.loadResource("modelica://Buildings/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos")),
            columns=2:30,
            smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative)
            "Data reader"
            annotation (Placement(transformation(extent={{0,-20},{20,0}})));
        equation
          connect(datRea.y[20],limCeiHei.u) annotation (Line(
              points={{21,-10},{30,-10},{30,-10},{38,-10}},
              color={0,0,127}));
          connect(modTim.y, conTim.modTim) annotation (Line(
              points={{-59,-10},{-42,-10}},
              color={0,0,127}));
          connect(conTim.calTim, datRea.u) annotation (Line(
              points={{-19,-10},{-2,-10}},
              color={0,0,127}));
          annotation (
        Documentation(info="<html>
<p>
This example tests the model that constrains the ceiling height.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Replaced <code>ModelicaServices.ExternalReferences.loadResource</code> with
<code>Modelica.Utilities.Files.loadResource</code>.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=0, StopTime=432000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/LimitMin.mos"
                "Simulate and plot"));
        end LimitMin;

        model LocalCivilTime "Test model for calculate local civil time"
          extends Modelica.Icons.Example;
          Buildings.Utilities.Time.ModelTime modTim
            "Block that outputs the model time"
            annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(timZon=-21600,
              lon=-1.5293932423067)
            annotation (Placement(transformation(extent={{0,0},{20,20}})));
        equation
          connect(modTim.y, locTim.cloTim) annotation (Line(
              points={{-19,10},{-2,10}},
              color={0,0,127}));
          annotation (
          Documentation(info="<html>
<p>
This example tests the model that computes the local civil time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),experiment(Tolerance=1e-6, StartTime=0, StopTime=172800),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/LocalCivilTime.mos"
                "Simulate and plot"));
        end LocalCivilTime;

        model SolarTime "Test model for solar time"
          extends Modelica.Icons.Example;
          Buildings.Utilities.Time.ModelTime modTim
            "Block that outputs simulation time"
            annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(timZon=-21600,
              lon=-1.7039261675061) "Block that computes the local civil time"
            annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.SolarTime solTim
            "Block that computes the solar time"
            annotation (Placement(transformation(extent={{20,-20},{40,0}})));
          ProsNet.BoundaryConditions.WeatherData.BaseClasses.EquationOfTime eqnTim
            "Block that computes the equation of time"
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));
        equation
          connect(modTim.y, locTim.cloTim) annotation (Line(
              points={{-39,-10},{-30,-10},{-30,-30},{-22,-30}},
              color={0,0,127}));
          connect(locTim.locTim, solTim.locTim) annotation (Line(
              points={{1,-30},{8,-30},{8,-15.4},{18,-15.4}},
              color={0,0,127}));
          connect(modTim.y, eqnTim.nDay) annotation (Line(
              points={{-39,-10},{-30,-10},{-30,10},{-22,10}},
              color={0,0,127}));
          connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
              points={{1,10},{8,10},{8,-4},{18,-4}},
              color={0,0,127}));
          annotation (
          Documentation(info="<html>
<p>
This example tests the model that computes the solar time.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),          experiment(Tolerance=1e-6, StopTime=864000),
        __Dymola_Commands(file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/WeatherData/BaseClasses/Examples/SolarTime.mos"
                "Simulate and plot"));
        end SolarTime;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains examples for the use of models that can be found in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.BaseClasses\">
Buildings.BoundaryConditions.WeatherData.BaseClasses</a>.
</p>
</html>"));
      end Examples;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData\">Buildings.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to read weather data. It also contains
the <code>expandable connector</code>
<a href=\"modelica://Buildings.BoundaryConditions.WeatherData.Bus\">
Buildings.BoundaryConditions.WeatherData.Bus</a>
that is used in the library to provide weather data to the different models.
</html>"));
  end WeatherData;

  package Types "Package with type definitions"
   extends Modelica.Icons.TypesPackage;
    type DataSource = enumeration(
        File "Use data from file",
        Parameter "Use parameter",
        Input "Use input connector") "Enumeration to define data source"
          annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

    type RadiationDataSource = enumeration(
        File "Use data from file",
        Input_HGloHor_HDifHor
          "Global horizontal and diffuse horizontal radiation from connector",
        Input_HDirNor_HDifHor
          "Direct normal and diffuse horizontal radiation from connector",
        Input_HDirNor_HGloHor
          "Direct normal and global horizontal radiation from connector")
      "Enumeration to define solar radiation data source"
          annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",   revisions="<html>
<ul>
<li>
August 13, 2012, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
    type SkyTemperatureCalculation = enumeration(
        HorizontalRadiation
          "Use horizontal irradiation",
        TemperaturesAndSkyCover
          "Use dry-bulb and dew-point temperatures and sky cover")
      "Enumeration for computation of sky temperature" annotation (Documentation(
          info =                 "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",   revisions="<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

  annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
  end Types;

  package Validation "Collection of validation models Validation"
    extends Modelica.Icons.ExamplesPackage;

    package UsersGuide
      "User's Guide"
      extends Modelica.Icons.Information;
      annotation (
        preferredView="info",
        Documentation(
          info="<html>
<p>
The package <a href=\"modelica://Buildings.BoundaryConditions.Validation.BESTEST\">Buildings.BoundaryConditions.Validation.BESTEST</a>
contains the models that are used for the BESTEST validation ASHRAE 2020 for weather data acquisition and postprocessing.
</p>
<p>
Each model represents a different climate with different days as shown in the tables below.
All examples have a script that runs the simulation according to the specifications and derive the required Json file as reported below.
</p>
<p>
The weather radiation data has to be provided at different orientations and inclinations.
</p>
<p><i>Table 2:&nbsp;</i>Azimuth and Slope for Surfaces</p>
<table summary = \"Azimuth and Slope for Surfaces\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Azimuth</p></td>
<td><p>Slope</p></td>
</tr>
<tr>
<td><p>Horizontal</p></td>
<td><p>0&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>South</p></td>
<td><p>90&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>East</p></td>
<td><p>90&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>North</p></td>
<td><p>90&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>West</p></td>
<td><p>90&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>45&deg; East of South</p></td>
<td><p>90&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>45&deg; West of South</p></td>
<td><p>90&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>East</p></td>
<td><p>30&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>South</p></td>
<td><p>30&deg; from horizontal</p></td>
</tr>
<tr>
<td><p>West</p></td>
<td><p>30&deg; from horizontal</p></td>
</tr>
</table>

<br><p><i>Additional parameters and correlations</i></p>
<ul>
<li>Ground reflectance &rho; is set to 0 for cases from WD100 to WD500 and 0.2 for WD600</li>
<li>
<a href=\"modelica://Buildings.BoundaryConditions.SkyTemperature.BlackBody\">Sky black body temperature</a>
calculated using Horizontal radiation or dew point temperature and sky cover.
</li>
<li>Diffused radiation calculated using <a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation.DiffusePerez\">Perez</a> and
<a href=\"modelica://Buildings.BoundaryConditions.SolarIrradiation.DiffuseIsotropic\">Isotropic</a> sky models</li>
</ul>
<h4>Outputs required</h4>
<p><i>Annual Outputs</i></p>
<p><b>&nbsp;</b>The following outputs are  provided for an annual simulation:</p>
<ul>
<li>Average dry bulb temperature (&deg;C)</li>
<li>Average relative humidity (%)</li>
<li>Average dewpoint temperature (&deg;C)</li>
<li>Average humidity ratio (kg moisture/kg dry air)</li>
<li>Average wet bulb temperature (&deg;C)</li>
<li>Sum of total, beam, and diffuse solar radiation incident on each surface (Wh/m2)</li>
</ul>
<br><p><i>Hourly Outputs</i></p>
<p>The following outputs are  provided for each hour of the days specified for each test case in Table 3:</p>
<ul>
<li>Dry bulb temperature (&deg;C)</li>
<li>Relative humidity (%)</li>
<li>Dewpoint temperature (&deg;C)</li>
<li>Humidity ratio (kg moisture/kg dry air)</li>
<li>Wet bulb temperature (&deg;C)</li>
<li>Windspeed (m/s)</li>
<li>Wind direction (degrees from north)</li>
<li>Station pressure (mbar)</li>
<li>Total cloud cover (tenths of sky)</li>
<li>Opaque cloud cover (tenths of sky)</li>
<li>Sky temperature (&deg;C)</li>
<li>Sum of total, beam, and diffuse solar radiation incident on each surface (Wh/m2)&nbsp;</li>
</ul>
<br><p><i>Table 3: Specific Days for Output</i></p>
<table summary = \"Specific Days for Output\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Case </p></td>
<td><p>Days</p></td>
</tr>
<tr>
<td><p>WD100 </p></td>
<td><p>May 4th, July 14th, September 6th</p></td>
</tr>
<tr>
<td><p>WD200 </p></td>
<td><p>May 24th, August 26th</p></td>
</tr>
<tr>
<td><p>WD300 </p></td>
<td><p>February 7th, August 13th</p></td>
</tr>
<tr>
<td><p>WD400 </p></td>
<td><p>January 24th, July 1st</p></td>
</tr>
<tr>
<td><p>WD500 </p></td>
<td><p>March 1st, September 14th</p></td>
</tr>
<tr>
<td><p>WD600 </p></td>
<td><p>May 4th, July 14th, September 6th</p></td>
</tr>
</table>
<br><p><i>Sub-hourly Outputs</i></p>
<p>The following outputs are  provided at each timestep of the days specified for each test case in Table 3:</p>
<ul>
<li>Dry bulb temperature (C)</li>
<li>Relative humidity (%)</li>
<li>Sum of total, beam, and diffuse solar radiation incident on each surface (Wh/m2) </li>
</ul>
<p>The following outputs are  provided integrated hourly for the days specified for each test case in Table 3:</p>
<ul>
<li>Total incident horizontal solar radiation (Wh/m2)</li>
<li>Total incident horizontal beam solar radiation (Wh/m2)</li>
<li>Total incident horizontal diffuse solar radiation (Wh/m2) </li>
</ul>
<h4>Validation results</h4>
<p>(Not available yet)</p>
<h4>Implementation</h4>
<p>To generate the data shown in this user guide, run </p>
<pre>
cd Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST
python3 generateResults.py -p
</pre>
<p>At the beginning of the Python script there are several options that the user can choose, by default the script will:
</p>
<ul>
<li>Clone the last master branch of the Buildings repository into a temporary directory</li>
<li>Execute all the simulations and create the folders with the .mat and .json files inside the BESTEST/Simulations folder</li>
</ul>
<h4>References</h4>
<p>(Not available yet)</p>
</html>", revisions="<html>
<ul>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
first implementation of BESTEST weather validation
</li>
</ul>
</html>"));
    end UsersGuide;

    model IsotropicAndPerezDiffuseRadiation
      "Partial model to run BESTEST validation case studies for weather data processing"
      extends
        ProsNet.BoundaryConditions.SolarIrradiation.BaseClasses.PartialSolarIrradiation;
      Modelica.Blocks.Interfaces.RealOutput HPer(
        final quantity="RadiantEnergyFluenceRate",
        final unit="W/m2")
        "Radiation per unit area using Perez Model"
        annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
      parameter Modelica.Units.SI.Angle til(displayUnit="deg") "Surface tilt angle";
      parameter Modelica.Units.SI.Angle azi(displayUnit="deg") "Azimuth angle";
      parameter Real rho=0.2
        "Ground reflectance";
      SolarIrradiation.DirectTiltedSurface HDir(
        til=til,
        azi=azi)
        "Direct Irradiation on tilted surface"
        annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
      SolarIrradiation.DiffuseIsotropic HDiffIso(
        til=til,
        rho=rho,
        outSkyCon=true,
        outGroCon=true)
        "Isoentropic diffuse radiation"
        annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
      SolarIrradiation.DiffusePerez HDiffPer(
        til=til,
        rho=rho,
        azi=azi,
        outSkyCon=true,
        outGroCon=true)
        "Diffused radiation using Perez"
        annotation (Placement(transformation(extent={{-40,-50},{-20,-30}})));

    protected
      Modelica.Blocks.Math.Add addHDirHDiffIso
        "Sum of Direct radiation and Isoentropic radiation"
        annotation (Placement(transformation(extent={{40,24},{60,44}})));
      Modelica.Blocks.Math.Add addHDirHDiffPer
        "Sum of Direct radiation and Perez radiation"
        annotation (Placement(transformation(extent={{40,-42},{60,-22}})));

    equation
      connect(weaBus,HDiffIso.weaBus)
        annotation (Line(points={{-100,0},{-74,0},{-74,40},{-40,40}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-6,3},{-6,3}},horizontalAlignment=TextAlignment.Right));
      connect(HDir.weaBus,HDiffIso.weaBus)
        annotation (Line(points={{-40,0},{-74,0},{-74,40},{-40,40}},color={255,204,51},thickness=0.5));
      connect(HDiffPer.weaBus,HDiffIso.weaBus)
        annotation (Line(points={{-40,-40},{-74,-40},{-74,40},{-40,40}},color={255,204,51},thickness=0.5));
      connect(HDir.H,addHDirHDiffPer.u1)
        annotation (Line(points={{-19,0},{0,0},{0,-20},{20,-20},{20,-26},{38,-26}},color={0,0,127}));
      connect(HDiffPer.H,addHDirHDiffPer.u2)
        annotation (Line(points={{-19,-40},{32,-40},{32,-38},{38,-38}},color={0,0,127}));
      connect(HDiffIso.H,addHDirHDiffIso.u1)
        annotation (Line(points={{-19,40},{38,40}},color={0,0,127}));
      connect(HDir.H,addHDirHDiffIso.u2)
        annotation (Line(points={{-19,0},{0,0},{0,20},{20,20},{20,28},{38,28}},color={0,0,127}));
      connect(addHDirHDiffIso.y,H)
        annotation (Line(points={{61,34},{80,34},{80,0},{110,0}},color={0,0,127}));
      connect(addHDirHDiffPer.y,HPer)
        annotation (Line(points={{61,-32},{80,-32},{80,-40},{110,-40}},color={0,0,127}));
      annotation (
        Icon(
          coordinateSystem(
            preserveAspectRatio=false)),
        Diagram(
          coordinateSystem(
            preserveAspectRatio=false)),
        Documentation(
          revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Added altitude to parameters.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
October 25, 2020, by Ettore Zanetti:<br/>
Updated comments for variable descriptions
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1351\">#1351</a>.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
</ul>
</html>", info="<html>
<p>
This model outputs the global radiation with a certain inclination and orientation
using the isotropic sky model and the Perez sky model. The variable <code>H</code> is
the global radiation calculated using the isotropic sky model, while <code>HPer</code> is
the global radiation calculated using the Perez sky model.</p>
</html>"));
    end IsotropicAndPerezDiffuseRadiation;

    package BESTEST "Boundary conditions validation according to BESTEST specifications"
      extends Modelica.Icons.ExamplesPackage;

      model WD100
        "Test model for BESTEST weather data: base case"
        extends Modelica.Icons.Example;

        parameter Real rho=0
          "Ground reflectance";
        WeatherData.ReaderTMY3 weaDatHHorIR(
          pAtmSou=ProsNet.BoundaryConditions.Types.DataSource.File,
          filNam=Modelica.Utilities.Files.loadResource(
            "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD100.mos"),
          calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.HorizontalRadiation)
          "Reads all weather data and Tsky using horizontal radiation"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},rotation=90,origin={0,-90})));
        WeatherData.Bus weaBusHHorIR
          "weather bus to read all weather data and Tsky using horizontal radiation"
          annotation (Placement(transformation(extent={{-14,-82},{16,-54}}),iconTransformation(extent={{-220,70},{-200,90}})));
        IsotropicAndPerezDiffuseRadiation azi000til00(
          til=Buildings.Types.Tilt.Ceiling,
          azi=Buildings.Types.Azimuth.S,
          rho=rho)
          "Azimuth = Horizontal, Tilt = 0 °"
          annotation (Placement(transformation(extent={{60,70},{80,90}})));
        IsotropicAndPerezDiffuseRadiation azi000til90(
          til=Buildings.Types.Tilt.Wall,
          azi=Buildings.Types.Azimuth.S,
          rho=rho)
          "Azimuth = South, Tilt = 90 °"
          annotation (Placement(transformation(extent={{60,40},{80,60}})));
        IsotropicAndPerezDiffuseRadiation azi270til90(
          til=Buildings.Types.Tilt.Wall,
          azi=Buildings.Types.Azimuth.E,
          rho=rho)
          "Azimuth = East, Tilt = 90 °"
          annotation (Placement(transformation(extent={{60,10},{80,30}})));
        IsotropicAndPerezDiffuseRadiation azi180til90(
          til=Buildings.Types.Tilt.Wall,
          azi=Buildings.Types.Azimuth.N,
          rho=rho)
          "Azimuth = North, Tilt = 90 °"
          annotation (Placement(transformation(extent={{60,-20},{80,0}})));
        IsotropicAndPerezDiffuseRadiation azi090til90(
          til=Buildings.Types.Tilt.Wall,
          azi=Buildings.Types.Azimuth.W,
          rho=rho)
          "Azimuth =  West, Tilt = 90 °"
          annotation (Placement(transformation(extent={{60,-50},{80,-30}})));
        IsotropicAndPerezDiffuseRadiation azi315til90(
          til=Buildings.Types.Tilt.Wall,
          azi=Buildings.Types.Azimuth.SE,
          rho=rho)
          "Azimuth = 45 ° SE, Tilt = 0 °"
          annotation (Placement(transformation(extent={{-60,70},{-80,90}})));
        IsotropicAndPerezDiffuseRadiation azi045til90(
          til=Buildings.Types.Tilt.Wall,
          azi=Buildings.Types.Azimuth.SW,
          rho=rho)
          "Azimuth = 45 SW, Tilt = 90 °"
          annotation (Placement(transformation(extent={{-60,40},{-80,60}})));
        IsotropicAndPerezDiffuseRadiation azi270til30(
          til=0.5235987755983,
          azi=Buildings.Types.Azimuth.E,
          rho=rho)
          "Azimuth = East, Tilt = 30 °"
          annotation (Placement(transformation(extent={{-60,10},{-80,30}})));
        IsotropicAndPerezDiffuseRadiation azi000til30(
          til=0.5235987755983,
          azi=Buildings.Types.Azimuth.S,
          rho=rho)
          "Azimuth = South, Tilt = 0 °"
          annotation (Placement(transformation(extent={{-60,-20},{-80,0}})));
        IsotropicAndPerezDiffuseRadiation azi090til30(
          til=0.5235987755983,
          azi=Buildings.Types.Azimuth.W,
          rho=rho)
          "Azimuth = West, Tilt = 0 °"
          annotation (Placement(transformation(extent={{-60,-50},{-80,-30}})));
        Buildings.Utilities.Psychrometrics.X_pTphi x_pTphi
          annotation (Placement(transformation(extent={{-40,-80},{-60,-60}})));
        Buildings.Utilities.Psychrometrics.ToDryAir toDryAir
          annotation (Placement(transformation(extent={{-72,-80},{-92,-60}})));
        WeatherData.ReaderTMY3 weaDatTDryBulTDewPoinOpa(
          pAtmSou=ProsNet.BoundaryConditions.Types.DataSource.File,
          filNam=Modelica.Utilities.Files.loadResource(
            "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD100.mos"),
          calTSky=ProsNet.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover)
          "Reads all weather data and Tsky using dry bulb temperature, dew point temperature and sky cover"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},rotation=90,origin={70,-90})));
        WeatherData.Bus weaBusTDryBulTDewPoiOpa
          "Weather bus to read Tsky using dew point temperature and sky cover"
          annotation (Placement(transformation(extent={{52,-84},{84,-54}}),iconTransformation(extent={{-220,70},{-200,90}})));

      equation
        connect(weaDatHHorIR.weaBus,weaBusHHorIR)
          annotation (Line(points={{4.44089e-16,-80},{4.44089e-16,-74},{0,-74},{0,-68},{1,-68}},color={255,204,51},thickness=0.5),Text(string="%second",index=1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR.pAtm,x_pTphi.p_in)
          annotation (Line(points={{1,-68},{-18,-68},{-18,-64},{-38,-64}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-3,-6},{-3,-6}},horizontalAlignment=TextAlignment.Right));
        connect(weaBusHHorIR.TDryBul,x_pTphi.T)
          annotation (Line(points={{1,-68},{-18,-68},{-18,-70},{-38,-70}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR.relHum,x_pTphi.phi)
          annotation (Line(points={{1,-68},{-18,-68},{-18,-76},{-38,-76}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(x_pTphi.X[1],toDryAir.XiTotalAir)
          annotation (Line(points={{-61,-70},{-71,-70}},color={0,0,127}));
        connect(weaDatTDryBulTDewPoinOpa.weaBus,weaBusTDryBulTDewPoiOpa)
          annotation (Line(points={{70,-80},{70,-69},{68,-69}},color={255,204,51},thickness=0.5),Text(string="%second",index=1,extent={{-3,6},{-3,6}},horizontalAlignment=TextAlignment.Right));
        connect(weaBusHHorIR,azi090til90.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,-40},{60,-40}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-6,3},{-6,3}},horizontalAlignment=TextAlignment.Right));
        connect(weaBusHHorIR,azi090til30.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,-40},{-60,-40}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR,azi000til30.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,-10},{-60,-10}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR,azi180til90.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,-10},{60,-10}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-6,3},{-6,3}},horizontalAlignment=TextAlignment.Right));
        connect(weaBusHHorIR,azi270til30.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,20},{-60,20}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR,azi270til90.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,20},{60,20}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-6,3},{-6,3}},horizontalAlignment=TextAlignment.Right));
        connect(weaBusHHorIR,azi045til90.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,50},{-60,50}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR,azi000til90.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,50},{60,50}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-6,3},{-6,3}},horizontalAlignment=TextAlignment.Right));
        connect(weaBusHHorIR,azi315til90.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,80},{-60,80}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{6,3},{6,3}},horizontalAlignment=TextAlignment.Left));
        connect(weaBusHHorIR,azi000til00.weaBus)
          annotation (Line(points={{1,-68},{0,-68},{0,80},{60,80}},color={255,204,51},thickness=0.5),Text(string="%first",index=-1,extent={{-6,3},{-6,3}},horizontalAlignment=TextAlignment.Right));
        annotation (
          experiment(
            StopTime=3.1536e+07,
            Interval=900,
            Tolerance=1e-6),
          __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/Validation/BESTEST/WD100.mos" "Simulate and plot"),
          Documentation(
            info="<html>
<h4>WD100: Base Case</h4>
<p>Weather data file : WD100.epw</p>
<p><i>Table 1: Site Data for Weather file WD100.epw</i></p>
<table summary=\"Site Data for Weather file WD100.epw\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Latitude</p></td>
<td><p>39.833&deg; north</p></td>
</tr>
<tr>
<td><p>Longitude</p></td>
<td><p>104.65&deg; west</p></td>
</tr>
<tr>
<td><p>Altitude</p></td>
<td><p>1650 m</p></td>
</tr>
<tr>
<td><p>Time Zone</p></td>
<td><p>-7</p></td>
</tr>
</table>
<p>This model is a template for all the other test cases.
It allows to extrapolate all the weather data from the Reader TMY3 for a specific location, incliation and azimuth.
The model
<a href=\"modelica://Buildings.BoundaryConditions.Validation.IsotropicAndPerezDiffuseRadiation\">Buildings.BoundaryConditions.Validation.IsotropicAndPerezDiffuseRadiation</a>
outputs radiation data using the available Isotropic and Perez methodlogies.
The sky temperature is calculated using both the Horizontal radiation model,
from data reader weaBusHorRad and the dew point temperature plus sky cover model from the datareader weaBusSkyCovDewTem.</p>
</html>",   revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Updated weather file as explained in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1478\">#1478</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Added altitude to parameters.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
</ul>
</html>"));
      end WD100;

      model WD200
        "Test model for BESTEST weather data: Low Elevation, Hot and Humid Case"
        extends WD100(
          rho=0,
          weaDatHHorIR(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD200.mos")),
          weaDatTDryBulTDewPoinOpa(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD200.mos")));
        annotation (
          experiment(
            StopTime=3.1536e+07,
            Interval=900,
            Tolerance=1e-6),
          __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/Validation/BESTEST/WD200.mos" "Simulate and plot"),
          Documentation(
            revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Updated weather file as explained in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1478\">#1478</a>.
</li>
</ul>
</html>",   info="<html>
<h4>WD200: Low Elevation, Hot and Humid Case.</h4>
<p>Weather data file : WD200.epw</p>
<p><i>Table 1: Site Data for Weather file WD200.epw</i></p>
<table summary=\"Site Data for Weather file WD200.epw\"cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Latitude</p></td>
<td><p>33.633&deg; north</p></td>
</tr>
<tr>
<td><p>Longitude</p></td>
<td><p>84.433&deg; west</p></td>
</tr>
<tr>
<td><p>Altitude</p></td>
<td><p>308 m</p></td>
</tr>
<tr>
<td><p>Time Zone</p></td>
<td><p>-5</p></td>
</tr>
</table>
</html>"));
      end WD200;

      model WD300
        "Test model for BESTEST weather data: Southern hemisphere case"
        extends WD100(
          rho=0,
          weaDatHHorIR(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD300.mos")),
          weaDatTDryBulTDewPoinOpa(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD300.mos")));
        annotation (
          experiment(
            StopTime=3.1536e+07,
            Interval=900,
            Tolerance=1e-6),
          __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/Validation/BESTEST/WD300.mos" "Simulate and plot"),
          Documentation(
            revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Updated weather file as explained in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1478\">#1478</a>.
</li>
</ul>
</html>",   info="<html>
<h4>WD300: Southern Hemisphere Case</h4>
<p>Weather data file : WD300.epw</p>
<p><i>Table 1: Site Data for Weather file WD300.epw</i></p>
<table summary=\"Site Data for Weather file WD300.epw\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Latitude</p></td>
<td><p>33.393&deg; south</p></td>
</tr>
<tr>
<td><p>Longitude</p></td>
<td><p>70.786&deg; west</p></td>
</tr>
<tr>
<td><p>Altitude</p></td>
<td><p>474 m</p></td>
</tr>
<tr>
<td><p>Time Zone</p></td>
<td><p>-4</p></td>
</tr>
</table>
</html>"));
      end WD300;

      model WD400
        "Test model for BESTEST weather data: high latitude case"
        extends WD100(
          rho=0,
          weaDatHHorIR(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD400.mos")),
          weaDatTDryBulTDewPoinOpa(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD400.mos")));
        annotation (
          experiment(
            StopTime=3.1536e+07,
            Interval=900,
            Tolerance=1e-6),
          __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/Validation/BESTEST/WD400.mos" "Simulate and plot"),
          Documentation(
            revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Updated weather file as explained in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1478\">#1478</a>.
</li>
</ul>
</html>",   info="<html>
<h4>WD400: High Latitude Case</h4>
<p>Weather data file : WD400.epw</p>
<p><i>Table 1: Site Data for Weather file WD400.epw</i></p>
<table summary=\"Site Data for Weather file WD400.epw\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Latitude</p></td>
<td><p>71.286&deg; north</p></td>
</tr>
<tr>
<td><p>Longitude</p></td>
<td><p>156.767&deg; west</p></td>
</tr>
<tr>
<td><p>Altitude</p></td>
<td><p>10 m</p></td>
</tr>
<tr>
<td><p>Time Zone</p></td>
<td><p>-9</p></td>
</tr>
</table>
</html>"));
      end WD400;

      model WD500
        "Test model for BESTEST weather data: time zone case"
        extends WD100(
          rho=0,
          weaDatHHorIR(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD500.mos")),
          weaDatTDryBulTDewPoinOpa(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD500.mos")));
        annotation (
          experiment(
            StopTime=3.1536e+07,
            Interval=900,
            Tolerance=1e-6),
          __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/Validation/BESTEST/WD500.mos" "Simulate and plot"),
          Documentation(
            revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
<li>
May 2, 2021, by Ettore Zanetti:<br/>
Updated weather file as explained in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1478\">#1478</a>.
</li>
</ul>
</html>",   info="<html>
<h4>WD500: Time Zone Case</h4>
<p>Weather data file : WD500.epw</p>
<p><i>Table 1: Site Data for Weather file WD500epw</i></p>
<table summary=\"Site Data for Weather file WD500epw\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Latitude</p></td>
<td><p>28.567&deg; north</p></td>
</tr>
<tr>
<td><p>Longitude</p></td>
<td><p>77.103&deg; east</p></td>
</tr>
<tr>
<td><p>Altitude</p></td>
<td><p>236.9 m</p></td>
</tr>
<tr>
<td><p>Time Zone</p></td>
<td><p>5.5</p></td>
</tr>
</table>
</html>"));
      end WD500;

      model WD600
        "Test model for BESTEST weather data: ground reflectance"
        extends WD100(
          rho=0.2,
          weaDatHHorIR(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD600.mos")),
          weaDatTDryBulTDewPoinOpa(
            filNam=Modelica.Utilities.Files.loadResource(
              "modelica://Buildings/Resources/Data/BoundaryConditions/Validation/BESTEST/WD600.mos")));
        annotation (
          experiment(
            StopTime=3.1536e+07,
            Interval=900,
            Tolerance=1e-6),
          __Dymola_Commands(
            file="modelica://Buildings/Resources/Scripts/Dymola/BoundaryConditions/Validation/BESTEST/WD600.mos" "Simulate and plot"),
          Documentation(
            revisions="<html>
<ul>
<li>
September 6, 2021, by Ettore Zanetti:<br/>
Removed parameter <code>lat</code> as it is now obtained from the weather data bus.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1477\">IBPSA, #1477</a>.
</li>
<li>
March 11, 2020, by Ettore Zanetti:<br/>
First implementation.
</li>
<li>
April 14, 2020, by Ettore Zanetti:<br/>
Rework after comments from pull request
<a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1339\">#1339</a>.
</li>
</ul>
</html>",   info="<html>
<h4>WD600: Ground Reflactance</h4>
<p>Weather data file : WD600.epw</p>
<p><i>Table 1: Site Data for Weather file WD600.epw</i></p>
<table summary=\"Site Data for Weather file WD600.epw\" cellspacing=\"2\" cellpadding=\"0\" border=\"1\"><tr>
<td><p>Latitude</p></td>
<td><p>39.833&deg; north</p></td>
</tr>
<tr>
<td><p>Longitude</p></td>
<td><p>104.65&deg; west</p></td>
</tr>
<tr>
<td><p>Altitude</p></td>
<td><p>1650 m</p></td>
</tr>
<tr>
<td><p>Time Zone</p></td>
<td><p>-7</p></td>
</tr>
</table>
</html>"));
      end WD600;
      annotation (
        Documentation(
          info="<html>
<p>This package contains the validation models used to read extract the weather data required by the BESTEST cases.
</p>
<p>
More details in the
<a href=\"modelica://Buildings.BoundaryConditions.Validation.UsersGuide\">Buildings.BoundaryConditions.Validation.UsersGuide</a> </p>
</html>"));
    end BESTEST;
    annotation (
      Documentation(
        info="<html>
<p>
This package contains models for validation of weather data models.
</p>
</html>"));
  end Validation;
annotation (preferredView="info",
Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data.
For models that set boundary conditions for fluid flow systems,
see
<a href=\"modelica://Buildings.Fluid.Sources\">
Buildings.Fluid.Sources</a>.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
      graphics={
        Ellipse(
        extent={{-76,80},{6,-2}},
        lineColor={255,255,255},
        lineThickness=1,
        fillPattern=FillPattern.Sphere,
        fillColor={255,255,255}),
      Line(
        points={{32,-24},{76,-82}},
        color={95, 95, 95}),
      Line(
        points={{4,-24},{48,-82}},
        color={95, 95, 95}),
      Line(
        points={{-26,-24},{18,-82}},
        color={95, 95, 95}),
      Line(
        points={{-56,-24},{-12,-82}},
        color={95, 95, 95}),
      Polygon(
        points={{64,6},{50,-2},{40,-18},{70,-24},{78,-52},{26,-52},{-6,-54},{
            -72,-52},{-72,-22},{-52,-10},{-42,10},{-78,34},{-44,52},{40,56},{76,
            40},{64,6}},
        lineColor={150,150,150},
        lineThickness=0.1,
        fillPattern=FillPattern.Sphere,
        smooth=Smooth.Bezier,
        fillColor={150,150,150})}));
end BoundaryConditions;
